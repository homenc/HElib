/**
@mainpage HElib Documentation

HElib is a software library that implements homomorphic encryption
(HE). Currently available is an implementation of the
Brakerski-Gentry-Vaikuntanathan (BGV) scheme, along with many
optimizations to make homomorphic evaluation runs faster, focusing
mostly on effective use of the Smart-Vercauteren ciphertext packing
techniques and the Gentry-Halevi-Smart optimizations. Articles that
describe some aspects of HElib include:

  - A (somewhat outdated) <a href="http://people.csail.mit.edu/shaih/pubs/he-library.pdf">design document</a>, Shai Halevi and Victor Shoup, April 2013.
  - <a href="http://eprint.iacr.org/2014/106">Algorithms in HElib</a>, Shai Halevi and Victor Shoup, published in <a href="http://www.iacr.org/conferences/crypto2014/">CRYPTO 2014</a>.
  - <a href="http://eprint.iacr.org/2014/873">Bootstrapping for HElib</a>, Shai Halevi and Victor Shoup, September 2014.

At its present state, this library is mostly meant for researchers
working on HE and its uses. Also currently it is fairly low-level,
and is best thought of as "assembly language for HE". That is, it
provides low-level routines (set, add, multiply, shift, etc.), with
as much access to optimizations as we can give. Hopefully in time we
will be able to provide higher-level routines.

This library is written in C++ and uses the NTL mathematical
library, over GMP. It is distributed under the terms of the GNU
General Public License (GPL).

\section building Building HElib
To build HElib, you will need to have GMP and NTL libraries installed.
Many distributions come with GMP pre-installed. If not, you can install
GMP as follows.
  -# Download GMP from http://www.gmplib.org
  -# Uncompress and cd into the directory `gmp-XXX`
  -# On the command line:
@code
     ./configure
     make
     sudo make install
@endcode

This should install GMP into `/usr/local`.
Once GMP is installed, you can install NTL as follows:
(NOTE: you will needs NTL version 6.1 or higher)
  -# Download NTL from http://www.shoup.net/ntl/
  -# Uncompress and cd into the directory `ntl-XXX/src`
  -# On the command line:
@code
      ./configure NTL_GMP_LIP=on
      make
      sudo make install
@endcode

This should install NTL into `/usr/local`.
Now that you have these libraries in place, you can cd to the HElib
src directory to build HElib.

Right now, the "build system" for HElib is very rudimentary: no
configure script and just a Makefile (with no `make install`).
The Makefile will build the static library fhe.a in the HElib src
directory, and then one can build applications programs based on
fhe.a, also in the HElib src directory (or set the include and library
parameters to include the right things). Hopefully, this build system
will be improved in the future.

Before building HElib, you may want to look at the Makefile, and
consider adjusting some of the defaults for CC and CFLAGS. The
defaults should be OK on most systems, but you can see the suggested
options, which are documented in the Makefile.
On the command line in the HElib src directory:
@code
  make        # this will compile and build the library fhe.a
  make check  # this will compile and runs a series of test programs.
@endcode

If you want to build your own program based on HElib, the easiest way
to do it is to write the program in a file called myprog.cpp and then
run<
@code
   make myprog_x
@endcode
which will compile `myprog.cpp` and link in `fhe.a` and all required
support libraries, and create the executable `myprog_x`.
Take a look at `Test_General.cpp` for an example program using HElib.

\subsection remarks Some comments
HElib uses some features of `C++11` (or the earlier `C++0X`). For gcc, depending on the version that you use, you may need to specify the flags ` '-std=c++11 -lstdc++' ` or ` '-std=c++0x'` to be able to compile.

There are currently four compilation flags that control some aspects of the library, these are:

<dl>
<dt><tt>-DUSE_ALT_CRT</tt></dt>
<dd>Tells HElib to use an alternative to the default DoubleCRT representation
 of polynomials. The DoubleCRT class is described in Section 2.8 in the
 <a href="http://people.csail.mit.edu/shaih/pubs/he-library.pdf">design
 document</a>. Specifying the flag <tt>USE_ALT_CRT</tt> invokes a different
 implementation of the same interfaces. This is an experimental feature, the
 alternative implementation can be either faster or slower, depending on the
 operation mixture in use by the application.
</dd>

<dt><tt>-DNO_HALF_SIZE_PRIME</tt></dt>
<dd>    Tells HElib to not use the half size prime in the prime chain. By
    default, the modulus-chain in HElib consists of many "full-size
    primes" (of size n bits, typically n=50 for 64-bit machines) and
    one "half-size prime" of n/2 bits. A level corresponds to n/2 bits
    in the size of the modulus, and dropping to a lower level is done
    either by dropping the half-size prime (if it is part of the current
    modulus) or by dropping a full-size prime and adding back the
    half-size prime (if it is not part of the current modulus).
    Specifying the flag <tt>NO_HALF_SIZE_PRIME</tt> makes all the primes the
    same size, with each prime corresponding to a level (so dropping to
    a lower level means dropping one of the primes).
</dd>

<dt><tt>-DEVALMAP_CACHED=0</tt></dt>
<dt><tt>-DEVALMAP_CACHED=1</tt></dt>
<dd>     This flag only affect bootstrapping, it tells HElib to cache some
     constants that are used during recryption (rather than having to
     encode then anew with every recryption operation).
<ul>
<li><tt>EVALMAP_CACHED=0</tt> caches these constants as ZZX'es, this takes
     less space but it means that they still need to be converted to
     DoubleCRT's with every recryption operation.</li>
<li><tt>EVALMAP_CACHED=1</tt> caches these constants directly as DoubleCRT's,
     this may take a significant amount of memeory.</li>
</ul>
</dd>

<dt><tt>-DDEBUG_PRINTOUT</tt></dt>
<dd>    Add some debugging printouts
</dd>
</dl>
**/
