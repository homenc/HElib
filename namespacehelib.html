<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.19"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>HElib: helib Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
		<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;1,700&family=Merriweather&family=Merriweather+Sans&family=Open+Sans&family=Poppins:ital@1&family=Roboto:ital,wght@0,400;1,300;1,900&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body style="font-family: 'Merriweather', serif;">
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">HElib Implementing Homomorphic Encryption</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">helib Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehelib_1_1_f_h_eglobals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib_1_1_f_h_eglobals.html">FHEglobals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1add__pa__impl.html">add_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_add_d_a_g.html">AddDAG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing the logic of the order of bit products when adding two integers.  <a href="classhelib_1_1_add_d_a_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_and.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing the logical AND expression which inherits from <code><a class="el" href="structhelib_1_1_expr.html" title="Base structure for logical expressions.">Expr</a></code>.  <a href="classhelib_1_1_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1apply_perm__pa__impl.html">applyPerm_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_arg_map.html">ArgMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic class for arg parsing. Example use:  <a href="classhelib_1_1_arg_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_basic_automorph_precon.html">BasicAutomorphPrecon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-computation to speed many automorphism on the same ciphertext.  <a href="classhelib_1_1_basic_automorph_precon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_b_g_v.html">BGV</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for <a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a> scheme, to be used as template parameter.  <a href="structhelib_1_1_b_g_v.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_bipartitle_graph.html">BipartitleGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bipartite flow graph.  <a href="classhelib_1_1_bipartitle_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_block_mat_mul1_d.html">BlockMatMul1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_block_mat_mul1_d__derived.html">BlockMatMul1D_derived</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_block_mat_mul1_d__derived__impl.html">BlockMatMul1D_derived_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_block_mat_mul1_d__partial.html">BlockMatMul1D_partial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_block_mat_mul1_d_exec.html">BlockMatMul1DExec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_block_mat_mul1_d_exec__construct.html">BlockMatMul1DExec_construct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_block_mat_mul_full.html">BlockMatMulFull</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_block_mat_mul_full__derived.html">BlockMatMulFull_derived</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_block_mat_mul_full_exec.html">BlockMatMulFullExec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_block_mat_mul_full_exec__construct.html">BlockMatMulFullExec_construct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_block_mat_mul_full_helper.html">BlockMatMulFullHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for <a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a> scheme, to be used as template parameter.  <a href="structhelib_1_1_c_k_k_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_cmodulus.html">Cmodulus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides FFT and iFFT routines modulo a single-precision prime.  <a href="classhelib_1_1_cmodulus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_col_number.html">ColNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a column of a database as an expression which inherits from <code><a class="el" href="structhelib_1_1_expr.html" title="Base structure for logical expressions.">Expr</a></code>.  <a href="classhelib_1_1_col_number.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_col_perm.html">ColPerm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permuting a single dimension (column) of a hypercube.  <a href="classhelib_1_1_col_perm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_const_cube_slice.html">ConstCubeSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant lower-dimension slice of a hypercube.  <a href="classhelib_1_1_const_cube_slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_const_multiplier.html">ConstMultiplier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_const_multiplier___double_c_r_t.html">ConstMultiplier_DoubleCRT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_const_multiplier___double_c_r_t___c_k_k_s.html">ConstMultiplier_DoubleCRT_CKKS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_const_multiplier__zz_x.html">ConstMultiplier_zzX</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_const_multiplier__zz_x___c_k_k_s.html">ConstMultiplier_zzX_CKKS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_const_multiplier_cache.html">ConstMultiplierCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintaining the parameters.  <a href="classhelib_1_1_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a> object holds a single ciphertext.  <a href="classhelib_1_1_ctxt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_ctxt_part.html">CtxtPart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One entry in a ciphertext std::vector.  <a href="classhelib_1_1_ctxt_part.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_cube_signature.html">CubeSignature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a vector of dimensions for a hypercube and some additional data.  <a href="classhelib_1_1_cube_signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lower-dimension slice of a hypercube.  <a href="classhelib_1_1_cube_slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_d_a_gnode.html">DAGnode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node in an addition-DAG structure.  <a href="classhelib_1_1_d_a_gnode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_database.html">Database</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a database which is a <code>HElib::Matrix&lt;TXT&gt;</code>.  <a href="classhelib_1_1_database.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1decode__pa__impl.html">decode_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1deep__clone.html">deep_clone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy: initialize with clone.  <a href="classhelib_1_1deep__clone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementing polynomials (elements in the ring R_Q) in double-CRT form.  <a href="classhelib_1_1_double_c_r_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_double_c_r_t_helper.html">DoubleCRTHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to enforce consistency within an <a class="el" href="classhelib_1_1_double_c_r_t_helper.html" title="A helper class to enforce consistency within an DoubleCRTHelper object.">DoubleCRTHelper</a> object.  <a href="classhelib_1_1_double_c_r_t_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_dynamic_ctxt_powers.html">DynamicCtxtPowers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store powers of X, compute them dynamically as needed.  <a href="classhelib_1_1_dynamic_ctxt_powers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1encode__pa__impl.html">encode_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper for a smart pointer to an <a class="el" href="classhelib_1_1_encrypted_array_base.html" title="virtual class for data-movement operations on arrays of slots">EncryptedArrayBase</a>. This is the interface that higher-level code should use.  <a href="classhelib_1_1_encrypted_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_encrypted_array_base.html">EncryptedArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual class for data-movement operations on arrays of slots  <a href="classhelib_1_1_encrypted_array_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_encrypted_array_cx.html">EncryptedArrayCx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A different derived class to be used for the approximate-numbers scheme.  <a href="classhelib_1_1_encrypted_array_cx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_encrypted_array_derived.html">EncryptedArrayDerived</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived concrete implementation of <a class="el" href="classhelib_1_1_encrypted_array_base.html" title="virtual class for data-movement operations on arrays of slots">EncryptedArrayBase</a>.  <a href="classhelib_1_1_encrypted_array_derived.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1equals__pa__impl.html">equals_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_eval_map.html">EvalMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides the functionality for the linear transforms used in boostrapping. The constructor is invoked with three arguments:  <a href="classhelib_1_1_eval_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class that other HElib exception classes inherit from.  <a href="classhelib_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_explicit_replicator.html">ExplicitReplicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classhelib_1_1_replicate_handler.html" title="An abstract class to handle call-backs to get the output of replicate.">ReplicateHandler</a> that explicitly returns all the replicated ciphertexts in one big vector.  <a href="classhelib_1_1_explicit_replicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base structure for logical expressions.  <a href="structhelib_1_1_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1fhe__stats__record.html">fhe_stats_record</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_f_h_etimer.html">FHEtimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class to accumulate time.  <a href="classhelib_1_1_f_h_etimer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_flow_edge.html">FlowEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge in a flow graph.  <a href="classhelib_1_1_flow_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1frobenius_automorph__pa__impl.html">frobeniusAutomorph_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_full_binary_tree.html">FullBinaryTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple implementation of full binary trees (each non-leaf has 2 children)  <a href="classhelib_1_1_full_binary_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_gen_descriptor.html">GenDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minimal description of a generator for the purpose of building tree.  <a href="classhelib_1_1_gen_descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1general__range.html">general_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_general_automorph_precon.html">GeneralAutomorphPrecon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_general_automorph_precon___b_s_g_s.html">GeneralAutomorphPrecon_BSGS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_general_automorph_precon___f_u_l_l.html">GeneralAutomorphPrecon_FULL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_general_automorph_precon___u_n_k_n_o_w_n.html">GeneralAutomorphPrecon_UNKNOWN</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_general_benes_network.html">GeneralBenesNetwork</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of generalized Benes Permutation Network.  <a href="classhelib_1_1_general_benes_network.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_generator_trees.html">GeneratorTrees</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::vector of generator trees, one per generator in Zm*&zwj;/(p)  <a href="classhelib_1_1_generator_trees.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1half___f_f_t.html">half_FFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional cube.  <a href="classhelib_1_1_hyper_cube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_index_map.html">IndexMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IndexMap&lt;T&gt; implements a generic map indexed by a dynamic index set.  <a href="classhelib_1_1_index_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_index_map_init.html">IndexMapInit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializing elements in an <a class="el" href="classhelib_1_1_index_map.html" title="IndexMap&lt;T&gt; implements a generic map indexed by a dynamic index set.">IndexMap</a>.  <a href="classhelib_1_1_index_map_init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic set of non-negative integers.  <a href="classhelib_1_1_index_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_invalid_argument.html">InvalidArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits from <a class="el" href="classhelib_1_1_exception.html" title="Base class that other HElib exception classes inherit from.">Exception</a> and std::invalid_argument.  <a href="classhelib_1_1_invalid_argument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_i_o_error.html">IOError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits from <a class="el" href="classhelib_1_1_exception.html" title="Base class that other HElib exception classes inherit from.">Exception</a> and std::runtime_error.  <a href="classhelib_1_1_i_o_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_key_switch.html">KeySwitch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-switching matrices.  <a href="classhelib_1_1_key_switch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_labeled_edge.html">LabeledEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic directed edge in a graph with some labels.  <a href="classhelib_1_1_labeled_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_labeled_vertex.html">LabeledVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic node in a graph with some labels.  <a href="classhelib_1_1_labeled_vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhelib_1_1_logger.html" title="Logger class that handles warning printouts.">Logger</a> class that handles warning printouts.  <a href="classhelib_1_1_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_logic_error.html">LogicError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits from <a class="el" href="classhelib_1_1_exception.html" title="Base class that other HElib exception classes inherit from.">Exception</a> and std::logic_error.  <a href="classhelib_1_1_logic_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mapping_data.html">MappingData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary structure to support encoding/decoding slots.  <a href="classhelib_1_1_mapping_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul1_d.html">MatMul1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul1_d___c_k_k_s.html">MatMul1D_CKKS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul1_d__derived.html">MatMul1D_derived</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_mat_mul1_d__derived__impl.html">MatMul1D_derived_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul1_d__partial.html">MatMul1D_partial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul1_d_exec.html">MatMul1DExec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_mat_mul1_d_exec__construct.html">MatMul1DExec_construct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul_exec_base.html">MatMulExecBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul_full.html">MatMulFull</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul_full__derived.html">MatMulFull_derived</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul_full_exec.html">MatMulFullExec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_mat_mul_full_exec__construct.html">MatMulFullExec_construct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_mat_mul_full_helper.html">MatMulFullHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_matrix_view.html">MatrixView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_moduli_sizes.html">ModuliSizes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to map required modulo-sizes to primeSets.  <a href="classhelib_1_1_moduli_sizes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1mul___block_mat_mul1_d__impl.html">mul_BlockMatMul1D_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1mul___block_mat_mul_full__impl.html">mul_BlockMatMulFull_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1mul___mat_mul1_d__impl.html">mul_MatMul1D_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1mul___mat_mul_full__impl.html">mul_MatMulFull_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1mul__pa__impl.html">mul_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1negate__pa__impl.html">negate_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing the logical OR expression which inherits from <code><a class="el" href="structhelib_1_1_expr.html" title="Base structure for logical expressions.">Expr</a></code>.  <a href="classhelib_1_1_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_out_of_range_error.html">OutOfRangeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits from <a class="el" href="classhelib_1_1_exception.html" title="Base class that other HElib exception classes inherit from.">Exception</a> and std::out_of_range.  <a href="classhelib_1_1_out_of_range_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure of (Z/mZ)* /(p)  <a href="classhelib_1_1_p_algebra.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_p_algebra_mod.html">PAlgebraMod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure of Z[X]/(Phi_m(X), p)  <a href="classhelib_1_1_p_algebra_mod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_p_algebra_mod_base.html">PAlgebraModBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for <a class="el" href="classhelib_1_1_p_algebra_mod.html" title="The structure of Z[X]/(Phi_m(X), p)">PAlgebraMod</a>.  <a href="classhelib_1_1_p_algebra_mod_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_p_algebra_mod_cx.html">PAlgebraModCx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_p_algebra_mod_derived.html">PAlgebraModDerived</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A concrete instantiation of the virtual class.  <a href="classhelib_1_1_p_algebra_mod_derived.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_perm_net_layer.html">PermNetLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information needed to apply one layer of a permutation network.  <a href="classhelib_1_1_perm_net_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_perm_network.html">PermNetwork</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A full permutation network.  <a href="classhelib_1_1_perm_network.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_p_g_f_f_t.html">PGFFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_plaintext_array_base.html">PlaintextArrayBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_plaintext_array_derived.html">PlaintextArrayDerived</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that contains an <code>NTL::ZZX</code> polynomial along with a coefficient modulus <code>p2r</code> and a polynomial modulus <code>G</code>.  <a href="classhelib_1_1_poly_mod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_poly_mod_ring.html">PolyModRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight type for describing the structure of a single slot of the plaintext space.  <a href="structhelib_1_1_poly_mod_ring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_powerful_conversion.html">PowerfulConversion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion between powerful representation in R_m/(q) and zz_pX.  <a href="classhelib_1_1_powerful_conversion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_powerful_d_c_r_t.html">PowerfulDCRT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion between powerful representation, <a class="el" href="classhelib_1_1_double_c_r_t.html" title="Implementing polynomials (elements in the ring R_Q) in double-CRT form.">DoubleCRT</a>, and ZZX.  <a href="classhelib_1_1_powerful_d_c_r_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_powerful_translation_indexes.html">PowerfulTranslationIndexes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds index tables for translation between powerful and zz_pX.  <a href="classhelib_1_1_powerful_translation_indexes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_prime_generator.html">PrimeGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1print__pa__impl.html">print_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_matrix.html">PtrMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for an array of PtrVectors.  <a href="structhelib_1_1_ptr_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_matrix___pt_ptr_vector.html">PtrMatrix_PtPtrVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_matrix.html" title="An abstract class for an array of PtrVectors.">PtrMatrix</a> using vector&lt; PtrVector&lt;T&gt;* &gt;  <a href="structhelib_1_1_ptr_matrix___pt_ptr_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_matrix__pt_vec.html">PtrMatrix_ptVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_matrix.html" title="An abstract class for an array of PtrVectors.">PtrMatrix</a> using Vec&lt; Vec&lt;T&gt;* &gt;  <a href="structhelib_1_1_ptr_matrix__pt_vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_matrix__ptvector.html">PtrMatrix_ptvector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_matrix.html" title="An abstract class for an array of PtrVectors.">PtrMatrix</a> using vector&lt; vector&lt;T&gt;* &gt;  <a href="structhelib_1_1_ptr_matrix__ptvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_matrix___vec.html">PtrMatrix_Vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_matrix.html" title="An abstract class for an array of PtrVectors.">PtrMatrix</a> using Vec&lt; Vec&lt;T&gt; &gt;  <a href="structhelib_1_1_ptr_matrix___vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_matrix__vector.html">PtrMatrix_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_matrix.html" title="An abstract class for an array of PtrVectors.">PtrMatrix</a> using vector&lt; vector&lt;T&gt; &gt;  <a href="structhelib_1_1_ptr_matrix__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for an array of objects.  <a href="structhelib_1_1_ptr_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_vector___singleton.html">PtrVector_Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_vector.html" title="Abstract class for an array of objects.">PtrVector</a> from a single T object.  <a href="structhelib_1_1_ptr_vector___singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_vector__slice.html">PtrVector_slice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_vector.html" title="Abstract class for an array of objects.">PtrVector</a> as a slice of another <a class="el" href="structhelib_1_1_ptr_vector.html" title="Abstract class for an array of objects.">PtrVector</a>.  <a href="structhelib_1_1_ptr_vector__slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_vector___vec_pt.html">PtrVector_VecPt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_vector.html" title="Abstract class for an array of objects.">PtrVector</a> using Vec&lt;T*&gt;  <a href="structhelib_1_1_ptr_vector___vec_pt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_vector___vec_t.html">PtrVector_VecT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_vector.html" title="Abstract class for an array of objects.">PtrVector</a> using Vec&lt;T&gt;  <a href="structhelib_1_1_ptr_vector___vec_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_vector__vector_pt.html">PtrVector_vectorPt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_vector.html" title="Abstract class for an array of objects.">PtrVector</a> using vector&lt;T*&gt;  <a href="structhelib_1_1_ptr_vector__vector_pt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_ptr_vector__vector_t.html">PtrVector_vectorT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="structhelib_1_1_ptr_vector.html" title="Abstract class for an array of objects.">PtrVector</a> using vector&lt;T&gt;  <a href="structhelib_1_1_ptr_vector__vector_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that mimics the functionality of the <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code> object, and acts as a convenient entry point for inputting/encoding data which is to be encrypted.  <a href="classhelib_1_1_ptxt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_pub_key.html">PubKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The public key.  <a href="classhelib_1_1_pub_key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_pub_key_hack.html">PubKeyHack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1quarter___f_f_t.html">quarter_FFT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_query__t.html">Query_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure containing all information required for an HE query.  <a href="structhelib_1_1_query__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_query_builder.html">QueryBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object used to construct a <code><a class="el" href="structhelib_1_1_query__t.html" title="Structure containing all information required for an HE query.">Query_t</a></code> object from a logical expression.  <a href="classhelib_1_1_query_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1random__pa__impl.html">random_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_random_block_matrix.html">RandomBlockMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_random_full_block_matrix.html">RandomFullBlockMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_random_full_matrix.html">RandomFullMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_random_matrix.html">RandomMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_random_multi_block_matrix.html">RandomMultiBlockMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_random_multi_matrix.html">RandomMultiMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_random_state.html">RandomState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facility for "restoring" the NTL PRG state.  <a href="classhelib_1_1_random_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_recrypt_data.html">RecryptData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to hold recryption-related data inside the <a class="el" href="classhelib_1_1_context.html" title="Maintaining the parameters.">Context</a>.  <a href="classhelib_1_1_recrypt_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1replicate__pa__impl.html">replicate_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_replicate_handler.html">ReplicateHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class to handle call-backs to get the output of replicate.  <a href="classhelib_1_1_replicate_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1rotate__pa__impl.html">rotate_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_runtime_error.html">RuntimeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherits from <a class="el" href="classhelib_1_1_exception.html" title="Base class that other HElib exception classes inherit from.">Exception</a> and std::runtime_error.  <a href="classhelib_1_1_runtime_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_scratch_cell.html">ScratchCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to help manage the allocation of temporary <a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a> objects.  <a href="classhelib_1_1_scratch_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The secret key.  <a href="classhelib_1_1_sec_key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1shallow__clone.html">shallow_clone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shallow copy: initialize with copy constructor.  <a href="classhelib_1_1shallow__clone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1shift__pa__impl.html">shift_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_s_k_handle.html">SKHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle, describing the secret-key element that "matches" a part, of the form s^r(X^t).  <a href="classhelib_1_1_s_k_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1sub__pa__impl.html">sub_pa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_sub_dimension.html">SubDimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node in a tree relative to some generator.  <a href="classhelib_1_1_sub_dimension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_sum_register.html">SumRegister</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to do a binary tree summation as results appear to keep memory usage to a minimum.  <a href="classhelib_1_1_sum_register.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_tensor.html">Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhelib_1_1_tensor_slice.html">TensorSlice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_thin_eval_map.html">ThinEvalMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides the functionality for the linear transforms used in "thin" boostrapping, where slots are assumed to contain constants. The interface is exactly the same as for <a class="el" href="classhelib_1_1_eval_map.html" title="Class that provides the functionality for the linear transforms used in boostrapping....">EvalMap</a>, except that the constructor does not have a normal_basis parameter.  <a href="classhelib_1_1_thin_eval_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_thin_recrypt_data.html">ThinRecryptData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but for "thin" bootstrapping, where the slots are assumed to contain constants.  <a href="classhelib_1_1_thin_recrypt_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_tree_node.html">TreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node in a full binary tree.  <a href="classhelib_1_1_tree_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1zz__p_x_modulus1.html">zz_pXModulus1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary classes to facilitate faster reduction mod Phi_m(X) when the input has degree less than m.  <a href="classhelib_1_1zz__p_x_modulus1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_z_z__p_x_modulus1.html">ZZ_pXModulus1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">placeholder for pXModulus ...no optimizations  <a href="classhelib_1_1_z_z__p_x_modulus1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afac4e5ae4b272f9ffd07daee26285dad"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a></td></tr>
<tr class="separator:afac4e5ae4b272f9ffd07daee26285dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bdc610c69d2325ae28b53783225701"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_vector___vec_t.html">PtrVector_VecT</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a68bdc610c69d2325ae28b53783225701">CtPtrs_VecCt</a></td></tr>
<tr class="separator:a68bdc610c69d2325ae28b53783225701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70957f911bb89f6b84e7838ac4363d07"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_vector__vector_t.html">PtrVector_vectorT</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a70957f911bb89f6b84e7838ac4363d07">CtPtrs_vectorCt</a></td></tr>
<tr class="separator:a70957f911bb89f6b84e7838ac4363d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf611a971d91604083e4a4f4d2745a46"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_vector___vec_pt.html">PtrVector_VecPt</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adf611a971d91604083e4a4f4d2745a46">CtPtrs_VecPt</a></td></tr>
<tr class="separator:adf611a971d91604083e4a4f4d2745a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e2fec60563f1741cf5b38e9c975781"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_vector__vector_pt.html">PtrVector_vectorPt</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac9e2fec60563f1741cf5b38e9c975781">CtPtrs_vectorPt</a></td></tr>
<tr class="separator:ac9e2fec60563f1741cf5b38e9c975781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddae64ffeb6698a0b2a5214ab66273b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_vector__slice.html">PtrVector_slice</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#afddae64ffeb6698a0b2a5214ab66273b">CtPtrs_slice</a></td></tr>
<tr class="separator:afddae64ffeb6698a0b2a5214ab66273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54132076174cf5388da4f1121f4d417"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_matrix.html">PtrMatrix</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac54132076174cf5388da4f1121f4d417">CtPtrMat</a></td></tr>
<tr class="separator:ac54132076174cf5388da4f1121f4d417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536b3dcc07d9bee58c6f52f62118cd53"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_matrix___vec.html">PtrMatrix_Vec</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a536b3dcc07d9bee58c6f52f62118cd53">CtPtrMat_VecCt</a></td></tr>
<tr class="separator:a536b3dcc07d9bee58c6f52f62118cd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f951b4c929a807f0a369b1aed560c6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_matrix__vector.html">PtrMatrix_vector</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2f951b4c929a807f0a369b1aed560c6a">CtPtrMat_vectorCt</a></td></tr>
<tr class="separator:a2f951b4c929a807f0a369b1aed560c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3985a932f1b51600445c078fc5531d19"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_matrix__pt_vec.html">PtrMatrix_ptVec</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3985a932f1b51600445c078fc5531d19">CtPtrMat_ptVecCt</a></td></tr>
<tr class="separator:a3985a932f1b51600445c078fc5531d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2417782a109df301d765fbcdfe6ac1b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structhelib_1_1_ptr_matrix__ptvector.html">PtrMatrix_ptvector</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2417782a109df301d765fbcdfe6ac1b7">CtPtrMat_ptvectorCt</a></td></tr>
<tr class="separator:a2417782a109df301d765fbcdfe6ac1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428c028bc71d7be0bdaa0118f286ee2e"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a428c028bc71d7be0bdaa0118f286ee2e">DCRTptr</a></td></tr>
<tr class="separator:a428c028bc71d7be0bdaa0118f286ee2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3652f33aab9e225a4c136eb14a50bc53"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; NTL::ZZX &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3652f33aab9e225a4c136eb14a50bc53">ZZXptr</a></td></tr>
<tr class="separator:a3652f33aab9e225a4c136eb14a50bc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719cb433e43e9f4a88ada8b72d3b715d"><td class="memItemLeft" align="right" valign="top">typedef std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">cx_double</a></td></tr>
<tr class="separator:a719cb433e43e9f4a88ada8b72d3b715d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22330000dbd6d83a79f312ccb04405fb"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_map&lt; long, <a class="el" href="classhelib_1_1_flow_edge.html">FlowEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a22330000dbd6d83a79f312ccb04405fb">FNeighborList</a></td></tr>
<tr class="separator:a22330000dbd6d83a79f312ccb04405fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af547f7016fc73b7174a2018ea28ef298"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespacehelib.html#a22330000dbd6d83a79f312ccb04405fb">FNeighborList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af547f7016fc73b7174a2018ea28ef298">FlowGraph</a></td></tr>
<tr class="separator:af547f7016fc73b7174a2018ea28ef298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3940838420e66ad737389ec211730b3"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_multimap&lt; long, <a class="el" href="classhelib_1_1_labeled_edge.html">LabeledEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab3940838420e66ad737389ec211730b3">LNeighborList</a></td></tr>
<tr class="separator:ab3940838420e66ad737389ec211730b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a60bb8531261415fb3615bde85ae65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a67a60bb8531261415fb3615bde85ae65"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a67a60bb8531261415fb3615bde85ae65">Vector</a> = <a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt; T, 1 &gt;</td></tr>
<tr class="separator:a67a60bb8531261415fb3615bde85ae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af476860763122a38ad2ae71ad5b9bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9af476860763122a38ad2ae71ad5b9bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a> = <a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt; T, 2 &gt;</td></tr>
<tr class="separator:a9af476860763122a38ad2ae71ad5b9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6eb9f0889a704dbc4684ce445c48456"><td class="memItemLeft" align="right" valign="top">typedef long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad6eb9f0889a704dbc4684ce445c48456">LONG</a></td></tr>
<tr class="separator:ad6eb9f0889a704dbc4684ce445c48456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bfe799ca2748e0f67e80e799bbcebb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">QueryExpr</a> = std::shared_ptr&lt; <a class="el" href="structhelib_1_1_expr.html">Expr</a> &gt;</td></tr>
<tr class="memdesc:a72bfe799ca2748e0f67e80e799bbcebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a shared pointer to an <code><a class="el" href="structhelib_1_1_expr.html" title="Base structure for logical expressions.">Expr</a></code> object.  <a href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">More...</a><br /></td></tr>
<tr class="separator:a72bfe799ca2748e0f67e80e799bbcebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0769a209e14d5e1bfd8579072397867"><td class="memItemLeft" align="right" valign="top">typedef NTL::Vec&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a></td></tr>
<tr class="memdesc:ae0769a209e14d5e1bfd8579072397867"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple permutation is just a vector with p[i]=\pi_i.  <a href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">More...</a><br /></td></tr>
<tr class="separator:ae0769a209e14d5e1bfd8579072397867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b83b7df1af539c07c804d7888448ce"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classhelib_1_1_full_binary_tree.html">FullBinaryTree</a>&lt; <a class="el" href="classhelib_1_1_sub_dimension.html">SubDimension</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a22b83b7df1af539c07c804d7888448ce">OneGeneratorTree</a></td></tr>
<tr class="separator:a22b83b7df1af539c07c804d7888448ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6002f36f1a61982fded09adf1331ca"><td class="memItemLeft" align="right" valign="top">typedef NTL::Vec&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a></td></tr>
<tr class="separator:a4d6002f36f1a61982fded09adf1331ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007ac83d6ec59826a48a73602b739510"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; long, long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a007ac83d6ec59826a48a73602b739510">NodeIdx</a></td></tr>
<tr class="separator:a007ac83d6ec59826a48a73602b739510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd32b2ba6d41fbd5943e40c4371e86a5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abd32b2ba6d41fbd5943e40c4371e86a5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abd32b2ba6d41fbd5943e40c4371e86a5">aligned_vector</a> = <a class="el" href="classhelib_1_1_p_g_f_f_t.html#a618bb04e868985f8159d8063829f1f88">PGFFT::aligned_vector</a>&lt; T &gt;</td></tr>
<tr class="separator:abd32b2ba6d41fbd5943e40c4371e86a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c94755e338132a41051da4c73f35ae4"><td class="memItemLeft" align="right" valign="top">typedef complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3c94755e338132a41051da4c73f35ae4">cmplx_t</a></td></tr>
<tr class="separator:a3c94755e338132a41051da4c73f35ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b643292f10bf869b8650f9392ff2d90"><td class="memItemLeft" align="right" valign="top">typedef long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9b643292f10bf869b8650f9392ff2d90">ldbl</a></td></tr>
<tr class="separator:a9b643292f10bf869b8650f9392ff2d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab0181d82dc81ed4d1f8c1d950b4efd7e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab0181d82dc81ed4d1f8c1d950b4efd7e">PA_tag</a> { <a class="el" href="namespacehelib.html#ab0181d82dc81ed4d1f8c1d950b4efd7eab33244c736f38a4c21e6d86c6a683d58">PA_GF2_tag</a>, 
<a class="el" href="namespacehelib.html#ab0181d82dc81ed4d1f8c1d950b4efd7ea63d35380340004730e7cb505a4da38e2">PA_zz_p_tag</a>, 
<a class="el" href="namespacehelib.html#ab0181d82dc81ed4d1f8c1d950b4efd7ea7d944116ae9eb1abb2d5fa92bb6d21ee">PA_cx_tag</a>
 }</td></tr>
<tr class="separator:ab0181d82dc81ed4d1f8c1d950b4efd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aca37b5e05bffd4550c995e83594d7325"><td class="memTemplParams" colspan="2">template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </td></tr>
<tr class="memitem:aca37b5e05bffd4550c995e83594d7325"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aca37b5e05bffd4550c995e83594d7325">assertTrue</a> (const T &amp;value, const std::string &amp;message)</td></tr>
<tr class="separator:aca37b5e05bffd4550c995e83594d7325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fc5ad34739ea66baa96f988dd07beb"><td class="memTemplParams" colspan="2">template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </td></tr>
<tr class="memitem:ad5fc5ad34739ea66baa96f988dd07beb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad5fc5ad34739ea66baa96f988dd07beb">assertFalse</a> (T value, const std::string &amp;message)</td></tr>
<tr class="separator:ad5fc5ad34739ea66baa96f988dd07beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec77ae5fa0fd11a0a42e07fefe49b99d"><td class="memTemplParams" colspan="2">template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </td></tr>
<tr class="memitem:aec77ae5fa0fd11a0a42e07fefe49b99d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aec77ae5fa0fd11a0a42e07fefe49b99d">assertEq</a> (const T &amp;a, const T &amp;b, const std::string &amp;message)</td></tr>
<tr class="separator:aec77ae5fa0fd11a0a42e07fefe49b99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5b530c0837ef9111dc4a361364d669"><td class="memTemplParams" colspan="2">template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </td></tr>
<tr class="memitem:acd5b530c0837ef9111dc4a361364d669"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acd5b530c0837ef9111dc4a361364d669">assertNeq</a> (const T &amp;a, const T &amp;b, const std::string &amp;message)</td></tr>
<tr class="separator:acd5b530c0837ef9111dc4a361364d669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b1da8169ee8b9a0ab221e4c67961c5"><td class="memTemplParams" colspan="2">template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </td></tr>
<tr class="memitem:aa7b1da8169ee8b9a0ab221e4c67961c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa7b1da8169ee8b9a0ab221e4c67961c5">assertNotNull</a> (const T &amp;p, const std::string &amp;message)</td></tr>
<tr class="separator:aa7b1da8169ee8b9a0ab221e4c67961c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e36344202aac3b245f5ba71f69a3e8b"><td class="memTemplParams" colspan="2">template&lt;typename ExceptionTy  = ::helib::OutOfRangeError, typename T  = void&gt; </td></tr>
<tr class="memitem:a8e36344202aac3b245f5ba71f69a3e8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8e36344202aac3b245f5ba71f69a3e8b">assertInRange</a> (const T &amp;elem, const T &amp;min, const T &amp;max, const std::string &amp;message, bool right_inclusive=false)</td></tr>
<tr class="separator:a8e36344202aac3b245f5ba71f69a3e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f609e8138ce597457cbf6168d27363"><td class="memItemLeft" align="right" valign="top">std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab0f609e8138ce597457cbf6168d27363">longToBitVector</a> (long num, long bitSize)</td></tr>
<tr class="memdesc:ab0f609e8138ce597457cbf6168d27363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a number as a vector of bits with LSB on the left.  <a href="namespacehelib.html#ab0f609e8138ce597457cbf6168d27363">More...</a><br /></td></tr>
<tr class="separator:ab0f609e8138ce597457cbf6168d27363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc8eab5085d47ef2587ff4253ec5d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6cc8eab5085d47ef2587ff4253ec5d77">binaryCond</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;output, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;cond, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;trueValue, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;falseValue)</td></tr>
<tr class="memdesc:a6cc8eab5085d47ef2587ff4253ec5d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <code>output = cond * trueValue + (1 - cond) * falseValue</code>.  <a href="namespacehelib.html#a6cc8eab5085d47ef2587ff4253ec5d77">More...</a><br /></td></tr>
<tr class="separator:a6cc8eab5085d47ef2587ff4253ec5d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08be8ce0b0f4ca1f870c56508889598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa08be8ce0b0f4ca1f870c56508889598">binaryMask</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;binaryNums, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;mask)</td></tr>
<tr class="memdesc:aa08be8ce0b0f4ca1f870c56508889598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeroes the slots of <code>binaryNums</code> where the corresponding slot of <code>mask</code> is 0.  <a href="namespacehelib.html#aa08be8ce0b0f4ca1f870c56508889598">More...</a><br /></td></tr>
<tr class="separator:aa08be8ce0b0f4ca1f870c56508889598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31dff00b9bd2df3454c7dc7a7edf16b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab31dff00b9bd2df3454c7dc7a7edf16b">concatBinaryNums</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;output, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;a, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;b)</td></tr>
<tr class="memdesc:ab31dff00b9bd2df3454c7dc7a7edf16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two binary numbers into a single <code>CtPtrs</code> object. E.g. If <code>a=10111</code>, <code>b=00101</code> then <code>output = 1011100101</code>.  <a href="namespacehelib.html#ab31dff00b9bd2df3454c7dc7a7edf16b">More...</a><br /></td></tr>
<tr class="separator:ab31dff00b9bd2df3454c7dc7a7edf16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5442620f8d9b1e48c79e6d0c30eb9cec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5442620f8d9b1e48c79e6d0c30eb9cec">splitBinaryNums</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;leftSplit, <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;rightSplit, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;input)</td></tr>
<tr class="memdesc:a5442620f8d9b1e48c79e6d0c30eb9cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a single binary number into two binary numbers <code>leftSplit</code> and <code>rightSplit</code>.  <a href="namespacehelib.html#a5442620f8d9b1e48c79e6d0c30eb9cec">More...</a><br /></td></tr>
<tr class="separator:a5442620f8d9b1e48c79e6d0c30eb9cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac577a548455a706fa164247e3801e05a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac577a548455a706fa164247e3801e05a">leftBitwiseShift</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;output, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;input, const long shamt)</td></tr>
<tr class="memdesc:ac577a548455a706fa164247e3801e05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left shift <code>input</code> by <code>shamt</code>.  <a href="namespacehelib.html#ac577a548455a706fa164247e3801e05a">More...</a><br /></td></tr>
<tr class="separator:ac577a548455a706fa164247e3801e05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a59ff05d1c4f1800bb2010e451576ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7a59ff05d1c4f1800bb2010e451576ab">bitwiseRotate</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;output, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;input, long rotamt)</td></tr>
<tr class="memdesc:a7a59ff05d1c4f1800bb2010e451576ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate <code>input</code> by <code>rotamt</code>.  <a href="namespacehelib.html#a7a59ff05d1c4f1800bb2010e451576ab">More...</a><br /></td></tr>
<tr class="separator:a7a59ff05d1c4f1800bb2010e451576ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa682a93edca39cb5ce5524219c486c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abaa682a93edca39cb5ce5524219c486c">bitwiseXOR</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;output, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;lhs, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;rhs)</td></tr>
<tr class="memdesc:abaa682a93edca39cb5ce5524219c486c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bitwise XOR between <code>lhs</code> and <code>rhs</code>.  <a href="namespacehelib.html#abaa682a93edca39cb5ce5524219c486c">More...</a><br /></td></tr>
<tr class="separator:abaa682a93edca39cb5ce5524219c486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2928d18450500f401e36d50a8288bf0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2928d18450500f401e36d50a8288bf0e">bitwiseOr</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;output, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;lhs, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;rhs)</td></tr>
<tr class="memdesc:a2928d18450500f401e36d50a8288bf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bitwise OR between <code>lhs</code> and <code>rhs</code>.  <a href="namespacehelib.html#a2928d18450500f401e36d50a8288bf0e">More...</a><br /></td></tr>
<tr class="separator:a2928d18450500f401e36d50a8288bf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4ba60fb6ef861f9601a3c22c589315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6e4ba60fb6ef861f9601a3c22c589315">bitwiseAnd</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;output, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;lhs, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6e4ba60fb6ef861f9601a3c22c589315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bitwise AND between <code>lhs</code> and <code>rhs</code>.  <a href="namespacehelib.html#a6e4ba60fb6ef861f9601a3c22c589315">More...</a><br /></td></tr>
<tr class="separator:a6e4ba60fb6ef861f9601a3c22c589315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a2868fe4324ee643869930d159f8ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a95a2868fe4324ee643869930d159f8ff">bitwiseAnd</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;output, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;input, const std::vector&lt; long &gt; mask)</td></tr>
<tr class="memdesc:a95a2868fe4324ee643869930d159f8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bitwise AND between <code>input</code> and a <code>std::vector&lt;long&gt;</code>.  <a href="namespacehelib.html#a95a2868fe4324ee643869930d159f8ff">More...</a><br /></td></tr>
<tr class="separator:a95a2868fe4324ee643869930d159f8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc4da63675257eacdf323d32ca23a83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3bc4da63675257eacdf323d32ca23a83">bitwiseNot</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;output, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;input)</td></tr>
<tr class="memdesc:a3bc4da63675257eacdf323d32ca23a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bitwise NOT of <code>input</code>.  <a href="namespacehelib.html#a3bc4da63675257eacdf323d32ca23a83">More...</a><br /></td></tr>
<tr class="separator:a3bc4da63675257eacdf323d32ca23a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277237f0883421a2abee740db9f1b6ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a277237f0883421a2abee740db9f1b6ef">addTwoNumbers</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;sum, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;lhs, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;rhs, long sizeLimit=0, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding=nullptr)</td></tr>
<tr class="memdesc:a277237f0883421a2abee740db9f1b6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two numbers in binary representation where each ciphertext of the input vector contains a bit.  <a href="namespacehelib.html#a277237f0883421a2abee740db9f1b6ef">More...</a><br /></td></tr>
<tr class="separator:a277237f0883421a2abee740db9f1b6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff515cbc7e22db14c0b22c910f4cee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aaff515cbc7e22db14c0b22c910f4cee2">negateBinary</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;negation, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;input)</td></tr>
<tr class="memdesc:aaff515cbc7e22db14c0b22c910f4cee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a number in binary 2's complement representation.  <a href="namespacehelib.html#aaff515cbc7e22db14c0b22c910f4cee2">More...</a><br /></td></tr>
<tr class="separator:aaff515cbc7e22db14c0b22c910f4cee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3828f8e07ee92999ebe6163fb96c5fd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3828f8e07ee92999ebe6163fb96c5fd5">subtractBinary</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;difference, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;lhs, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;rhs, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding=nullptr)</td></tr>
<tr class="memdesc:a3828f8e07ee92999ebe6163fb96c5fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts <code>rhs</code> from <code>lhs</code> where <code>lhs</code>, <code>rhs</code> are in 2's complement.  <a href="namespacehelib.html#a3828f8e07ee92999ebe6163fb96c5fd5">More...</a><br /></td></tr>
<tr class="separator:a3828f8e07ee92999ebe6163fb96c5fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635ecc26ac755424a9f834d4eca7d68e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a635ecc26ac755424a9f834d4eca7d68e">fifteenOrLess4Four</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;out, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;in, long sizeLimit=4)</td></tr>
<tr class="memdesc:a635ecc26ac755424a9f834d4eca7d68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add together up to fifteen {0,1} integers, producing a 4-bit counter.  <a href="namespacehelib.html#a635ecc26ac755424a9f834d4eca7d68e">More...</a><br /></td></tr>
<tr class="separator:a635ecc26ac755424a9f834d4eca7d68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e793367187e97095f9f2590eb4dc5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a34e793367187e97095f9f2590eb4dc5e">addManyNumbers</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;sum, <a class="el" href="namespacehelib.html#ac54132076174cf5388da4f1121f4d417">CtPtrMat</a> &amp;numbers, long sizeLimit=0, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding=nullptr)</td></tr>
<tr class="memdesc:a34e793367187e97095f9f2590eb4dc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum an arbitrary amount of numbers in binary representation.  <a href="namespacehelib.html#a34e793367187e97095f9f2590eb4dc5e">More...</a><br /></td></tr>
<tr class="separator:a34e793367187e97095f9f2590eb4dc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9936528f7b1f6865e4a496047caba21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa9936528f7b1f6865e4a496047caba21">multTwoNumbers</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;product, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;lhs, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;rhs, bool rhsTwosComplement=false, long sizeLimit=0, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding=nullptr)</td></tr>
<tr class="memdesc:aa9936528f7b1f6865e4a496047caba21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two numbers in binary representation where each ciphertext of the input vector contains a bit.  <a href="namespacehelib.html#aa9936528f7b1f6865e4a496047caba21">More...</a><br /></td></tr>
<tr class="separator:aa9936528f7b1f6865e4a496047caba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1285dad7ef04a62fde04003b87ee1110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1285dad7ef04a62fde04003b87ee1110">decryptBinaryNums</a> (std::vector&lt; long &gt; &amp;pNums, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;eNums, const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, bool twosComplement=false, bool allSlots=true)</td></tr>
<tr class="memdesc:a1285dad7ef04a62fde04003b87ee1110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt the binary numbers that are encrypted in eNums.  <a href="namespacehelib.html#a1285dad7ef04a62fde04003b87ee1110">More...</a><br /></td></tr>
<tr class="separator:a1285dad7ef04a62fde04003b87ee1110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4d00f74735017eb674bc25cca0d47d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aea4d00f74735017eb674bc25cca0d47d">packedRecrypt</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;a, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;b, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding)</td></tr>
<tr class="memdesc:aea4d00f74735017eb674bc25cca0d47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for packed recryption to recrypt multiple numbers.  <a href="namespacehelib.html#aea4d00f74735017eb674bc25cca0d47d">More...</a><br /></td></tr>
<tr class="separator:aea4d00f74735017eb674bc25cca0d47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eda8a61661cec76566fb5c6f475eb24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2eda8a61661cec76566fb5c6f475eb24">compareTwoNumbers</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;max, <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;min, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;mu, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ni, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;a, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;b, bool twosComplement=false, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding=nullptr)</td></tr>
<tr class="memdesc:a2eda8a61661cec76566fb5c6f475eb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two integers in binary <code>a</code>, <code>b</code>. Returns <code>max(a, b)</code>, <code>min(a, b)</code> and indicator bits <code>mu</code>=(<code>a</code>&gt;<code>b</code>) and <code>ni</code>=(<code>a</code>&lt;<code>b</code>)  <a href="namespacehelib.html#a2eda8a61661cec76566fb5c6f475eb24">More...</a><br /></td></tr>
<tr class="separator:a2eda8a61661cec76566fb5c6f475eb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d423993b1ba7f3a05bb0184d6e5dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad7d423993b1ba7f3a05bb0184d6e5dd8">compareTwoNumbers</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;mu, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ni, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;a, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;b, bool twosComplement=false, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding=nullptr)</td></tr>
<tr class="memdesc:ad7d423993b1ba7f3a05bb0184d6e5dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two integers in binary <code>a</code>, <code>b</code>. Returns only indicator bits <code>mu</code>=(<code>a</code>&gt;<code>b</code>) and <code>ni</code>=(<code>a</code>&lt;<code>b</code>).  <a href="namespacehelib.html#ad7d423993b1ba7f3a05bb0184d6e5dd8">More...</a><br /></td></tr>
<tr class="separator:ad7d423993b1ba7f3a05bb0184d6e5dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0de63e6a004056417fc6532985ce6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3e0de63e6a004056417fc6532985ce6f">readEyeCatcher</a> (std::istream &amp;str, const char *expect)</td></tr>
<tr class="separator:a3e0de63e6a004056417fc6532985ce6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1ce128c2df30ef155f565c6435bccb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5d1ce128c2df30ef155f565c6435bccb">writeEyeCatcher</a> (std::ostream &amp;str, const char *eye)</td></tr>
<tr class="separator:a5d1ce128c2df30ef155f565c6435bccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e05ac58f674ea9b53de6804949dea21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3e05ac58f674ea9b53de6804949dea21">write_ntl_vec_long</a> (std::ostream &amp;str, const NTL::vec_long &amp;vl, long intSize=BINIO_64BIT)</td></tr>
<tr class="separator:a3e05ac58f674ea9b53de6804949dea21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ff4e18ef29f688fc071601becaafef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af5ff4e18ef29f688fc071601becaafef">read_ntl_vec_long</a> (std::istream &amp;str, NTL::vec_long &amp;vl)</td></tr>
<tr class="separator:af5ff4e18ef29f688fc071601becaafef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66308212a98df1821b9bf48c5713bd2"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab66308212a98df1821b9bf48c5713bd2">read_raw_int</a> (std::istream &amp;str)</td></tr>
<tr class="separator:ab66308212a98df1821b9bf48c5713bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529e6135abd723e5eeb63a156224e39a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a529e6135abd723e5eeb63a156224e39a">read_raw_int32</a> (std::istream &amp;str)</td></tr>
<tr class="separator:a529e6135abd723e5eeb63a156224e39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7bbf963ee93061e4bb1204438721b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aab7bbf963ee93061e4bb1204438721b1">write_raw_int</a> (std::ostream &amp;str, long num)</td></tr>
<tr class="separator:aab7bbf963ee93061e4bb1204438721b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86af3712f18a5b1fca62330b37dbb9de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a86af3712f18a5b1fca62330b37dbb9de">write_raw_int32</a> (std::ostream &amp;str, int num)</td></tr>
<tr class="separator:a86af3712f18a5b1fca62330b37dbb9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafadc64ab3b1c319e37160cd619f3bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aafadc64ab3b1c319e37160cd619f3bf5">write_raw_double</a> (std::ostream &amp;str, const double d)</td></tr>
<tr class="separator:aafadc64ab3b1c319e37160cd619f3bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c396577dc7ac07293effb9e8e20364"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa1c396577dc7ac07293effb9e8e20364">read_raw_double</a> (std::istream &amp;str)</td></tr>
<tr class="separator:aa1c396577dc7ac07293effb9e8e20364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb770c4cb5c37da9184d5820a000758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aedb770c4cb5c37da9184d5820a000758">write_raw_xdouble</a> (std::ostream &amp;str, const NTL::xdouble xd)</td></tr>
<tr class="separator:aedb770c4cb5c37da9184d5820a000758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad981561d84bb94d22a6c5c3e1619806"><td class="memItemLeft" align="right" valign="top">NTL::xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aad981561d84bb94d22a6c5c3e1619806">read_raw_xdouble</a> (std::istream &amp;str)</td></tr>
<tr class="separator:aad981561d84bb94d22a6c5c3e1619806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1521af0f4ab251d30fc4f96531dc1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7f1521af0f4ab251d30fc4f96531dc1d">write_raw_ZZ</a> (std::ostream &amp;str, const NTL::ZZ &amp;zz)</td></tr>
<tr class="separator:a7f1521af0f4ab251d30fc4f96531dc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd83ed995cf19419ab46fa84b2711a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adfd83ed995cf19419ab46fa84b2711a7">read_raw_ZZ</a> (std::istream &amp;str, NTL::ZZ &amp;zz)</td></tr>
<tr class="separator:adfd83ed995cf19419ab46fa84b2711a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeff8e262314e10ad618189976b9ef93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaeff8e262314e10ad618189976b9ef93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aaeff8e262314e10ad618189976b9ef93">write_raw_vector</a> (std::ostream &amp;str, const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:aaeff8e262314e10ad618189976b9ef93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718430742226b3f7c2b81073ea10cc64"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a718430742226b3f7c2b81073ea10cc64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a718430742226b3f7c2b81073ea10cc64">write_raw_vector&lt; long &gt;</a> (std::ostream &amp;str, const std::vector&lt; long &gt; &amp;v)</td></tr>
<tr class="separator:a718430742226b3f7c2b81073ea10cc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374f958d521a444ec5686722c2dfad8b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a374f958d521a444ec5686722c2dfad8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a374f958d521a444ec5686722c2dfad8b">write_raw_vector&lt; double &gt;</a> (std::ostream &amp;str, const std::vector&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:a374f958d521a444ec5686722c2dfad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e907022dc0cd7bdf40f457b786ab924"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e907022dc0cd7bdf40f457b786ab924"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9e907022dc0cd7bdf40f457b786ab924">read_raw_vector</a> (std::istream &amp;str, std::vector&lt; T &gt; &amp;v, T &amp;init)</td></tr>
<tr class="separator:a9e907022dc0cd7bdf40f457b786ab924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0e61f1c81f568bd942e3f50b4c5301"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa0e61f1c81f568bd942e3f50b4c5301"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aaa0e61f1c81f568bd942e3f50b4c5301">read_raw_vector</a> (std::istream &amp;str, std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:aaa0e61f1c81f568bd942e3f50b4c5301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f201a18aa3be048c7935a97c1bd4e82"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6f201a18aa3be048c7935a97c1bd4e82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6f201a18aa3be048c7935a97c1bd4e82">read_raw_vector&lt; long &gt;</a> (std::istream &amp;str, std::vector&lt; long &gt; &amp;v)</td></tr>
<tr class="separator:a6f201a18aa3be048c7935a97c1bd4e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591c5643829af4b3738d1e6cc807518e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a591c5643829af4b3738d1e6cc807518e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a591c5643829af4b3738d1e6cc807518e">read_raw_vector&lt; double &gt;</a> (std::istream &amp;str, std::vector&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:a591c5643829af4b3738d1e6cc807518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a42dc495a369c587d7bfe577a1fc29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03a42dc495a369c587d7bfe577a1fc29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a03a42dc495a369c587d7bfe577a1fc29">read_raw_vector</a> (std::istream &amp;str, std::vector&lt; T &gt; &amp;v, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:a03a42dc495a369c587d7bfe577a1fc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac544d20010a35c78a75ce913a2b15979"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac544d20010a35c78a75ce913a2b15979">BluesteinInit</a> (long n, const NTL::zz_p &amp;root, NTL::zz_pX &amp;powers, NTL::Vec&lt; NTL::mulmod_precon_t &gt; &amp;powers_aux, NTL::fftRep &amp;Rb)</td></tr>
<tr class="memdesc:ac544d20010a35c78a75ce913a2b15979"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize bluestein  <a href="namespacehelib.html#ac544d20010a35c78a75ce913a2b15979">More...</a><br /></td></tr>
<tr class="separator:ac544d20010a35c78a75ce913a2b15979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66ba03453e871a61eda59e0f8e574af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab66ba03453e871a61eda59e0f8e574af">BluesteinFFT</a> (NTL::zz_pX &amp;x, long n, const NTL::zz_p &amp;root, const NTL::zz_pX &amp;powers, const NTL::Vec&lt; NTL::mulmod_precon_t &gt; &amp;powers_aux, const NTL::fftRep &amp;Rb)</td></tr>
<tr class="memdesc:ab66ba03453e871a61eda59e0f8e574af"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply bluestein  <a href="namespacehelib.html#ab66ba03453e871a61eda59e0f8e574af">More...</a><br /></td></tr>
<tr class="separator:ab66ba03453e871a61eda59e0f8e574af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a28125fbbf867ea3394513923a6abb"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Cloner &gt; </td></tr>
<tr class="memitem:a16a28125fbbf867ea3394513923a6abb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a16a28125fbbf867ea3394513923a6abb">swap</a> (cloned_ptr&lt; X, Cloner &gt; &amp;x, cloned_ptr&lt; X, Cloner &gt; &amp;y)</td></tr>
<tr class="separator:a16a28125fbbf867ea3394513923a6abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad420c276576021ed7278823e82771b6b"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Cloner &gt; </td></tr>
<tr class="memitem:ad420c276576021ed7278823e82771b6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad420c276576021ed7278823e82771b6b">swap</a> (copied_ptr&lt; X, Cloner &gt; &amp;x, copied_ptr&lt; X, Cloner &gt; &amp;y)</td></tr>
<tr class="separator:ad420c276576021ed7278823e82771b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf9f5de032fca82af2ce94a97041bc6"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abbf9f5de032fca82af2ce94a97041bc6">FindM</a> (long k, long nBits, long c, long p, long d, long s, long chosen_m, bool verbose=false)</td></tr>
<tr class="memdesc:abbf9f5de032fca82af2ce94a97041bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns smallest parameter m satisfying various constraints:  <a href="namespacehelib.html#abbf9f5de032fca82af2ce94a97041bc6">More...</a><br /></td></tr>
<tr class="separator:abbf9f5de032fca82af2ce94a97041bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8425881cdaaef9fade4dd57cc3cf5e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8425881cdaaef9fade4dd57cc3cf5e8b">writeContextBase</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="memdesc:a8425881cdaaef9fade4dd57cc3cf5e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">write [m p r gens ords] data  <a href="namespacehelib.html#a8425881cdaaef9fade4dd57cc3cf5e8b">More...</a><br /></td></tr>
<tr class="separator:a8425881cdaaef9fade4dd57cc3cf5e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b88eb3fd0aa4821cb6700fa65ecee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab7b88eb3fd0aa4821cb6700fa65ecee2">readContextBase</a> (std::istream &amp;s, unsigned long &amp;m, unsigned long &amp;p, unsigned long &amp;r, std::vector&lt; long &gt; &amp;gens, std::vector&lt; long &gt; &amp;ords)</td></tr>
<tr class="memdesc:ab7b88eb3fd0aa4821cb6700fa65ecee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">read [m p r gens ords] data, needed to construct context  <a href="namespacehelib.html#ab7b88eb3fd0aa4821cb6700fa65ecee2">More...</a><br /></td></tr>
<tr class="separator:ab7b88eb3fd0aa4821cb6700fa65ecee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfd34a416649164e3b01c4af1c8654e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classhelib_1_1_context.html">Context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adcfd34a416649164e3b01c4af1c8654e">buildContextFromAscii</a> (std::istream &amp;str)</td></tr>
<tr class="separator:adcfd34a416649164e3b01c4af1c8654e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3167b996c8b02f9f390d1d9957693b9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3167b996c8b02f9f390d1d9957693b9f">writeContextBaseBinary</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="memdesc:a3167b996c8b02f9f390d1d9957693b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">write [m p r gens ords] data  <a href="namespacehelib.html#a3167b996c8b02f9f390d1d9957693b9f">More...</a><br /></td></tr>
<tr class="separator:a3167b996c8b02f9f390d1d9957693b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9bc09cb4de5422bb79e9c4d67db80a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1f9bc09cb4de5422bb79e9c4d67db80a">writeContextBinary</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:a1f9bc09cb4de5422bb79e9c4d67db80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb88b203e4e9aeaf5fe329e7cc276aad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acb88b203e4e9aeaf5fe329e7cc276aad">readContextBaseBinary</a> (std::istream &amp;s, unsigned long &amp;m, unsigned long &amp;p, unsigned long &amp;r, std::vector&lt; long &gt; &amp;gens, std::vector&lt; long &gt; &amp;ords)</td></tr>
<tr class="memdesc:acb88b203e4e9aeaf5fe329e7cc276aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">read [m p r gens ords] data, needed to construct context  <a href="namespacehelib.html#acb88b203e4e9aeaf5fe329e7cc276aad">More...</a><br /></td></tr>
<tr class="separator:acb88b203e4e9aeaf5fe329e7cc276aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4036006b2d0e378ce2aa90a5332a8d73"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classhelib_1_1_context.html">Context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4036006b2d0e378ce2aa90a5332a8d73">buildContextFromBinary</a> (std::istream &amp;str)</td></tr>
<tr class="separator:a4036006b2d0e378ce2aa90a5332a8d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a07fadbe58c0bf5c4be26d9bb245755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4a07fadbe58c0bf5c4be26d9bb245755">readContextBinary</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:a4a07fadbe58c0bf5c4be26d9bb245755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68cc874f7e017cd4c35d1ea52739c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af68cc874f7e017cd4c35d1ea52739c0f">buildModChain</a> (<a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context, long nBits, long nDgts=3, bool willBeBootstrappable=false, long skHwt=0, long resolution=3, long bitsInSpecialPrimes=0)</td></tr>
<tr class="separator:af68cc874f7e017cd4c35d1ea52739c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdd1f22927d282e9bbce15a18f5f3ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abcdd1f22927d282e9bbce15a18f5f3ad">endBuildModChain</a> (<a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:abcdd1f22927d282e9bbce15a18f5f3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abd6bae5306a86a4f95fb62fad44c14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6abd6bae5306a86a4f95fb62fad44c14">packedRecrypt</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;cPtrs, const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;unpackConsts, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:a6abd6bae5306a86a4f95fb62fad44c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2903cc43702e2dccc9006f6af1da249f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2903cc43702e2dccc9006f6af1da249f">packedRecrypt</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;array, const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;unpackConsts, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, long belowLvl)</td></tr>
<tr class="separator:a2903cc43702e2dccc9006f6af1da249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7653c8cc828041d87ed9805c35bf0b6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7653c8cc828041d87ed9805c35bf0b6f">packedRecrypt</a> (const <a class="el" href="namespacehelib.html#ac54132076174cf5388da4f1121f4d417">CtPtrMat</a> &amp;m, const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;unpackConsts, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, long belowLvl=LONG_MAX)</td></tr>
<tr class="separator:a7653c8cc828041d87ed9805c35bf0b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5129e7d3dfa1e3c31cf5df21ae581d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3f5129e7d3dfa1e3c31cf5df21ae581d">findMinBitCapacity</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;v)</td></tr>
<tr class="separator:a3f5129e7d3dfa1e3c31cf5df21ae581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57538912bfe96e264dab8aac85f0be75"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a57538912bfe96e264dab8aac85f0be75">findMinBitCapacity</a> (const <a class="el" href="namespacehelib.html#ac54132076174cf5388da4f1121f4d417">CtPtrMat</a> &amp;m)</td></tr>
<tr class="separator:a57538912bfe96e264dab8aac85f0be75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544c38d5177ea1f1d47d3e204ac1eb77"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a544c38d5177ea1f1d47d3e204ac1eb77">findMinBitCapacity</a> (std::initializer_list&lt; const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> * &gt; list)</td></tr>
<tr class="separator:a544c38d5177ea1f1d47d3e204ac1eb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391719dad458fcb9560406cb565f8cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a391719dad458fcb9560406cb565f8cbe">innerProduct</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;result, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;v1, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;v2)</td></tr>
<tr class="separator:a391719dad458fcb9560406cb565f8cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e7877c8a04ea75594a2295518c70d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa1e7877c8a04ea75594a2295518c70d8">innerProduct</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;v1, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;v2)</td></tr>
<tr class="separator:aa1e7877c8a04ea75594a2295518c70d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc58993c7093dd07d98335bab200e82"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#addc58993c7093dd07d98335bab200e82">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_s_k_handle.html">SKHandle</a> &amp;handle)</td></tr>
<tr class="separator:addc58993c7093dd07d98335bab200e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b37f68c4bdc42558ad0360b00984fb"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a84b37f68c4bdc42558ad0360b00984fb">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classhelib_1_1_ctxt_part.html">CtxtPart</a> &amp;p)</td></tr>
<tr class="separator:a84b37f68c4bdc42558ad0360b00984fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d941f20d5c3e55e3b36b36dd5164d6b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2d941f20d5c3e55e3b36b36dd5164d6b">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_ctxt_part.html">CtxtPart</a> &amp;p)</td></tr>
<tr class="separator:a2d941f20d5c3e55e3b36b36dd5164d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9530775923f034eadc4f3e80f355ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8d9530775923f034eadc4f3e80f355ff">totalProduct</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;out, const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v)</td></tr>
<tr class="separator:a8d9530775923f034eadc4f3e80f355ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693b16168065219388722259c6a02c5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a693b16168065219388722259c6a02c5d">incrementalProduct</a> (std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v)</td></tr>
<tr class="separator:a693b16168065219388722259c6a02c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f851f7c167ee39bfc4ceb06d754dcf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8f851f7c167ee39bfc4ceb06d754dcf0">innerProduct</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;result, const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v1, const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v2)</td></tr>
<tr class="separator:a8f851f7c167ee39bfc4ceb06d754dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa738424e1ab49c4f39cbcb3e3e920591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa738424e1ab49c4f39cbcb3e3e920591">innerProduct</a> (const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v1, const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v2)</td></tr>
<tr class="separator:aa738424e1ab49c4f39cbcb3e3e920591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb001c145ac75147f598002b33806849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abb001c145ac75147f598002b33806849">innerProduct</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;result, const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v1, const std::vector&lt; <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &gt; &amp;v2)</td></tr>
<tr class="memdesc:abb001c145ac75147f598002b33806849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inner product of a vectors of ciphertexts and a constant vector.  <a href="namespacehelib.html#abb001c145ac75147f598002b33806849">More...</a><br /></td></tr>
<tr class="separator:abb001c145ac75147f598002b33806849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d0484b1e2d0105b7a2b70a3c6dc182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad0d0484b1e2d0105b7a2b70a3c6dc182">innerProduct</a> (const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v1, const std::vector&lt; <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &gt; &amp;v2)</td></tr>
<tr class="separator:ad0d0484b1e2d0105b7a2b70a3c6dc182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a60dc124ede5f7baecc0d6c7ab6df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab7a60dc124ede5f7baecc0d6c7ab6df6">innerProduct</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;result, const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v1, const std::vector&lt; NTL::ZZX &gt; &amp;v2)</td></tr>
<tr class="separator:ab7a60dc124ede5f7baecc0d6c7ab6df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d67040ef7ba12958be263a7a93dac9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6d67040ef7ba12958be263a7a93dac9e">innerProduct</a> (const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v1, const std::vector&lt; NTL::ZZX &gt; &amp;v2)</td></tr>
<tr class="separator:a6d67040ef7ba12958be263a7a93dac9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887b96d1f7918079c15b6fa1d8cbfae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a887b96d1f7918079c15b6fa1d8cbfae4">CheckCtxt</a> (const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;c, const char *label)</td></tr>
<tr class="memdesc:a887b96d1f7918079c15b6fa1d8cbfae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">print to cerr some info about ciphertext  <a href="namespacehelib.html#a887b96d1f7918079c15b6fa1d8cbfae4">More...</a><br /></td></tr>
<tr class="separator:a887b96d1f7918079c15b6fa1d8cbfae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e48196b014916b26112c02883f64e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a90e48196b014916b26112c02883f64e3">extractDigits</a> (std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;digits, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;c, long r=0)</td></tr>
<tr class="memdesc:a90e48196b014916b26112c02883f64e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the mod-p digits of a mod-p^r ciphertext.  <a href="namespacehelib.html#a90e48196b014916b26112c02883f64e3">More...</a><br /></td></tr>
<tr class="separator:a90e48196b014916b26112c02883f64e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab463f07c91389f56b58bb09da140230d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab463f07c91389f56b58bb09da140230d">extractDigits</a> (std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;digits, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;c, long r, bool shortCut)</td></tr>
<tr class="separator:ab463f07c91389f56b58bb09da140230d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9b160771517accfb43d16c5590942c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3f9b160771517accfb43d16c5590942c">extendExtractDigits</a> (std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;digits, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;c, long r, long e)</td></tr>
<tr class="separator:a3f9b160771517accfb43d16c5590942c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad44440822118a09af899ff2798464d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aad44440822118a09af899ff2798464d3">setupDebugGlobals</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> *debug_key, const std::shared_ptr&lt; const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &gt; &amp;debug_ea, NTL::ZZX debug_ptxt=NTL::ZZX{})</td></tr>
<tr class="memdesc:aad44440822118a09af899ff2798464d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup function for setting up the global debug variables.  <a href="namespacehelib.html#aad44440822118a09af899ff2798464d3">More...</a><br /></td></tr>
<tr class="separator:aad44440822118a09af899ff2798464d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa77bdb78bd529a55c239df60039e335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aaa77bdb78bd529a55c239df60039e335">cleanupDebugGlobals</a> ()</td></tr>
<tr class="memdesc:aaa77bdb78bd529a55c239df60039e335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup function for clearing the global debug variables.  <a href="namespacehelib.html#aaa77bdb78bd529a55c239df60039e335">More...</a><br /></td></tr>
<tr class="separator:aaa77bdb78bd529a55c239df60039e335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436a592900880109024757d11bb3949d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a436a592900880109024757d11bb3949d">decryptAndPrint</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, long flags=0)</td></tr>
<tr class="separator:a436a592900880109024757d11bb3949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309c3ca72a6d812a3ea23d62e48e42bf"><td class="memItemLeft" align="right" valign="top">NTL::xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a309c3ca72a6d812a3ea23d62e48e42bf">embeddingLargestCoeff</a> (const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk)</td></tr>
<tr class="separator:a309c3ca72a6d812a3ea23d62e48e42bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2f4d4c24b1b5926fc02206f9b5db6a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aeb2f4d4c24b1b5926fc02206f9b5db6a">realToEstimatedNoise</a> (const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk)</td></tr>
<tr class="separator:aeb2f4d4c24b1b5926fc02206f9b5db6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac845c61472e33fa76df608e536b25b5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac845c61472e33fa76df608e536b25b5a">checkNoise</a> (const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk, const std::string &amp;msg, double thresh=10.0)</td></tr>
<tr class="separator:ac845c61472e33fa76df608e536b25b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a60ea778c6bbcc5d2732ca137c7e15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a19a60ea778c6bbcc5d2732ca137c7e15">decryptAndCompare</a> (const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa)</td></tr>
<tr class="separator:a19a60ea778c6bbcc5d2732ca137c7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b26a9740fbaba1c3b7b5c7e89ee55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a50b26a9740fbaba1c3b7b5c7e89ee55c">rawDecrypt</a> (NTL::ZZX &amp;plaintxt, const std::vector&lt; NTL::ZZX &gt; &amp;zzParts, const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;sKey, long q=0)</td></tr>
<tr class="separator:a50b26a9740fbaba1c3b7b5c7e89ee55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7844ba559695a1952e4d6309d21b354"><td class="memTemplParams" colspan="2">template&lt;typename VEC &gt; </td></tr>
<tr class="memitem:af7844ba559695a1952e4d6309d21b354"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af7844ba559695a1952e4d6309d21b354">printVec</a> (std::ostream &amp;s, const VEC &amp;v, long nCoeffs=40)</td></tr>
<tr class="separator:af7844ba559695a1952e4d6309d21b354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742bf72a76d5b9389251abfee9223303"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a742bf72a76d5b9389251abfee9223303">printZZX</a> (std::ostream &amp;s, const NTL::ZZX &amp;poly, long nCoeffs=40)</td></tr>
<tr class="separator:a742bf72a76d5b9389251abfee9223303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a79c25bb9e1285c93b486ce07c4d52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af5a79c25bb9e1285c93b486ce07c4d52">conv</a> (<a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;d, const NTL::ZZX &amp;p)</td></tr>
<tr class="separator:af5a79c25bb9e1285c93b486ce07c4d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5fe8f0918a6b964a75728b61d15c2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5f5fe8f0918a6b964a75728b61d15c2c">conv</a> (NTL::ZZX &amp;p, const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;d)</td></tr>
<tr class="separator:a5f5fe8f0918a6b964a75728b61d15c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac584b135744603cdff25e2db01b9463a"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac584b135744603cdff25e2db01b9463a">to_ZZX</a> (const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;d)</td></tr>
<tr class="separator:ac584b135744603cdff25e2db01b9463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd5d1a56f7036cae390706fe49e8fcb"><td class="memTemplParams" colspan="2">template&lt;typename RX , typename RXModulus &gt; </td></tr>
<tr class="memitem:aefd5d1a56f7036cae390706fe49e8fcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aefd5d1a56f7036cae390706fe49e8fcb">plaintextAutomorph</a> (RX &amp;bb, const RX &amp;a, long k, long m, const RXModulus &amp;PhimX)</td></tr>
<tr class="separator:aefd5d1a56f7036cae390706fe49e8fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f36286a4ff72a05ddf16c2e5bfaeba5"><td class="memTemplParams" colspan="2">template&lt;typename RX , typename type &gt; </td></tr>
<tr class="memitem:a9f36286a4ff72a05ddf16c2e5bfaeba5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9f36286a4ff72a05ddf16c2e5bfaeba5">plaintextAutomorph</a> (RX &amp;b, const RX &amp;a, long i, long j, const <a class="el" href="classhelib_1_1_encrypted_array_derived.html">EncryptedArrayDerived</a>&lt; type &gt; &amp;ea)</td></tr>
<tr class="separator:a9f36286a4ff72a05ddf16c2e5bfaeba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf194ed39fc9a3694d1a11a0cd4c75d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_encrypted_array_base.html">EncryptedArrayBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acf194ed39fc9a3694d1a11a0cd4c75d4">buildEncryptedArray</a> (const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context, const <a class="el" href="classhelib_1_1_p_algebra_mod.html">PAlgebraMod</a> &amp;alMod, const NTL::ZZX &amp;G=NTL::ZZX::zero())</td></tr>
<tr class="memdesc:acf194ed39fc9a3694d1a11a0cd4c75d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "factory" for building EncryptedArrays.  <a href="namespacehelib.html#acf194ed39fc9a3694d1a11a0cd4c75d4">More...</a><br /></td></tr>
<tr class="separator:acf194ed39fc9a3694d1a11a0cd4c75d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cdfe4d2a5d750a2f2ae0f2d0addabc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae5cdfe4d2a5d750a2f2ae0f2d0addabc">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa)</td></tr>
<tr class="separator:ae5cdfe4d2a5d750a2f2ae0f2d0addabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34783d4707b52b8cb0341187d50f8265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a34783d4707b52b8cb0341187d50f8265">rotate</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, long k)</td></tr>
<tr class="separator:a34783d4707b52b8cb0341187d50f8265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2250fb1a88c915ce004837c63aa5ad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae2250fb1a88c915ce004837c63aa5ad7">shift</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, long k)</td></tr>
<tr class="separator:ae2250fb1a88c915ce004837c63aa5ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf08ccbcd03824fa3825640c1b171481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acf08ccbcd03824fa3825640c1b171481">encode</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const std::vector&lt; long &gt; &amp;array)</td></tr>
<tr class="separator:acf08ccbcd03824fa3825640c1b171481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40cf1967be4e2bf1b9a63564abe3485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac40cf1967be4e2bf1b9a63564abe3485">encode</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const std::vector&lt; NTL::ZZX &gt; &amp;array)</td></tr>
<tr class="separator:ac40cf1967be4e2bf1b9a63564abe3485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517b7c650eafd6c9ac20ef4605a4d4a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a517b7c650eafd6c9ac20ef4605a4d4a1">encode</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, long val)</td></tr>
<tr class="separator:a517b7c650eafd6c9ac20ef4605a4d4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8cf8fcdf629a076db0d0206670a7c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aab8cf8fcdf629a076db0d0206670a7c3">encode</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const NTL::ZZX &amp;val)</td></tr>
<tr class="separator:aab8cf8fcdf629a076db0d0206670a7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c7c1b517a8ec41eacfc5c2dba6e293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a38c7c1b517a8ec41eacfc5c2dba6e293">random</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa)</td></tr>
<tr class="separator:a38c7c1b517a8ec41eacfc5c2dba6e293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7757fc124c051547f6d8d62f57e6ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7d7757fc124c051547f6d8d62f57e6ee">decode</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, std::vector&lt; long &gt; &amp;array, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa)</td></tr>
<tr class="separator:a7d7757fc124c051547f6d8d62f57e6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ce1cf83ebb14807ec5fd0ecebd03be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a37ce1cf83ebb14807ec5fd0ecebd03be">decode</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, std::vector&lt; NTL::ZZX &gt; &amp;array, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa)</td></tr>
<tr class="separator:a37ce1cf83ebb14807ec5fd0ecebd03be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa271293d5f46187af89cc81ecb0235e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa271293d5f46187af89cc81ecb0235e9">equals</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;other)</td></tr>
<tr class="separator:aa271293d5f46187af89cc81ecb0235e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae140aabda8f5c9ace67b657134451df8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae140aabda8f5c9ace67b657134451df8">equals</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const std::vector&lt; long &gt; &amp;other)</td></tr>
<tr class="separator:ae140aabda8f5c9ace67b657134451df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2e1e9931564eca3665358957b06cd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aab2e1e9931564eca3665358957b06cd3">equals</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const std::vector&lt; NTL::ZZX &gt; &amp;other)</td></tr>
<tr class="separator:aab2e1e9931564eca3665358957b06cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42185bbb249368e34f515e09e90bc7b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a42185bbb249368e34f515e09e90bc7b0">add</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;other)</td></tr>
<tr class="separator:a42185bbb249368e34f515e09e90bc7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305064dc4866c160a571bd653556c113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a305064dc4866c160a571bd653556c113">sub</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;other)</td></tr>
<tr class="separator:a305064dc4866c160a571bd653556c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfe07d1b0c2f0e6385f2b6525e0a69b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0cfe07d1b0c2f0e6385f2b6525e0a69b">mul</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;other)</td></tr>
<tr class="separator:a0cfe07d1b0c2f0e6385f2b6525e0a69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6016d5e65b16abb1feba5a82067b14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2f6016d5e65b16abb1feba5a82067b14">negate</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa)</td></tr>
<tr class="separator:a2f6016d5e65b16abb1feba5a82067b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08d6e1c47a1f0b8ed57aff211929548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab08d6e1c47a1f0b8ed57aff211929548">frobeniusAutomorph</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, long j)</td></tr>
<tr class="separator:ab08d6e1c47a1f0b8ed57aff211929548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291c0b1560a80e0cda02f89617fd16d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a291c0b1560a80e0cda02f89617fd16d5">frobeniusAutomorph</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const NTL::Vec&lt; long &gt; &amp;vec)</td></tr>
<tr class="separator:a291c0b1560a80e0cda02f89617fd16d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf575ea763b7454a6e8df566a9e64b3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adf575ea763b7454a6e8df566a9e64b3c">applyPerm</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const NTL::Vec&lt; long &gt; &amp;pi)</td></tr>
<tr class="separator:adf575ea763b7454a6e8df566a9e64b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b1a8080de040baddd971b44488ca51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a83b1a8080de040baddd971b44488ca51">power</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, long e)</td></tr>
<tr class="separator:a83b1a8080de040baddd971b44488ca51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55aba5934157b9d7517101534a0053a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a55aba5934157b9d7517101534a0053a2">runningSums</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt)</td></tr>
<tr class="memdesc:a55aba5934157b9d7517101534a0053a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ctxt that encrypts <img class="formulaInl" alt="$(x_1, ..., x_n)$" src="form_0.png" width="56" height="14"/> is replaced by an encryption of <img class="formulaInl" alt="$(y_1, ..., y_n)$" src="form_1.png" width="55" height="14"/>, where <img class="formulaInl" alt="$y_i = sum_{j\le i} x_j$" src="form_2.png" width="80" height="10"/>.  <a href="namespacehelib.html#a55aba5934157b9d7517101534a0053a2">More...</a><br /></td></tr>
<tr class="separator:a55aba5934157b9d7517101534a0053a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bd686a2e209597f3acecd89f1a3520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a14bd686a2e209597f3acecd89f1a3520">print_stats</a> (std::ostream &amp;s)</td></tr>
<tr class="separator:a14bd686a2e209597f3acecd89f1a3520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35e417bff539eb8c29da182c8365e41"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af35e417bff539eb8c29da182c8365e41">fetch_saved_values</a> (const char *)</td></tr>
<tr class="separator:af35e417bff539eb8c29da182c8365e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a30d40b8861180c13416755e880749"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a55a30d40b8861180c13416755e880749">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_cube_signature.html">CubeSignature</a> &amp;sig)</td></tr>
<tr class="separator:a55a30d40b8861180c13416755e880749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89bc5e58dddac6b2dc64435b98417e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab89bc5e58dddac6b2dc64435b98417e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab89bc5e58dddac6b2dc64435b98417e1">getHyperColumn</a> (NTL::Vec&lt; T &gt; &amp;v, const <a class="el" href="classhelib_1_1_const_cube_slice.html">ConstCubeSlice</a>&lt; T &gt; &amp;s, long pos)</td></tr>
<tr class="separator:ab89bc5e58dddac6b2dc64435b98417e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12cedff32fc67534e469690637bee2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa12cedff32fc67534e469690637bee2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa12cedff32fc67534e469690637bee2d">setHyperColumn</a> (const NTL::Vec&lt; T &gt; &amp;v, const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; T &gt; &amp;s, long pos)</td></tr>
<tr class="separator:aa12cedff32fc67534e469690637bee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbaf86183c619b1eef87517dcaeacd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfbaf86183c619b1eef87517dcaeacd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abfbaf86183c619b1eef87517dcaeacd3">setHyperColumn</a> (const NTL::Vec&lt; T &gt; &amp;v, const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; T &gt; &amp;s, long pos, const T &amp;val)</td></tr>
<tr class="separator:abfbaf86183c619b1eef87517dcaeacd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d24bda05c48a744ffffd08de68736ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d24bda05c48a744ffffd08de68736ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5d24bda05c48a744ffffd08de68736ed">print3D</a> (const <a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="separator:a5d24bda05c48a744ffffd08de68736ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f68b7e6b0ff2bbf68b999655480fac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5f68b7e6b0ff2bbf68b999655480fac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad5f68b7e6b0ff2bbf68b999655480fac">operator==</a> (const <a class="el" href="classhelib_1_1_index_map.html">IndexMap</a>&lt; T &gt; &amp;map1, const <a class="el" href="classhelib_1_1_index_map.html">IndexMap</a>&lt; T &gt; &amp;map2)</td></tr>
<tr class="memdesc:ad5f68b7e6b0ff2bbf68b999655480fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparing maps, by comparing all the elements.  <a href="namespacehelib.html#ad5f68b7e6b0ff2bbf68b999655480fac">More...</a><br /></td></tr>
<tr class="separator:ad5f68b7e6b0ff2bbf68b999655480fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd34bfd104a104754a69b08d12882a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adcd34bfd104a104754a69b08d12882a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adcd34bfd104a104754a69b08d12882a4">operator!=</a> (const <a class="el" href="classhelib_1_1_index_map.html">IndexMap</a>&lt; T &gt; &amp;map1, const <a class="el" href="classhelib_1_1_index_map.html">IndexMap</a>&lt; T &gt; &amp;map2)</td></tr>
<tr class="separator:adcd34bfd104a104754a69b08d12882a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8172413911da7a2c6f38d9eb34899140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8172413911da7a2c6f38d9eb34899140">operator|</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;t)</td></tr>
<tr class="memdesc:a8172413911da7a2c6f38d9eb34899140"><td class="mdescLeft">&#160;</td><td class="mdescRight">union  <a href="namespacehelib.html#a8172413911da7a2c6f38d9eb34899140">More...</a><br /></td></tr>
<tr class="separator:a8172413911da7a2c6f38d9eb34899140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1a512fb48fe7d9cfc27c26a727ed6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acf1a512fb48fe7d9cfc27c26a727ed6f">operator&amp;</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;t)</td></tr>
<tr class="memdesc:acf1a512fb48fe7d9cfc27c26a727ed6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">intersection  <a href="namespacehelib.html#acf1a512fb48fe7d9cfc27c26a727ed6f">More...</a><br /></td></tr>
<tr class="separator:acf1a512fb48fe7d9cfc27c26a727ed6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f7e4e0b2339b3ac2e3b7a761357d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af6f7e4e0b2339b3ac2e3b7a761357d0c">operator^</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;t)</td></tr>
<tr class="memdesc:af6f7e4e0b2339b3ac2e3b7a761357d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">exclusive-or  <a href="namespacehelib.html#af6f7e4e0b2339b3ac2e3b7a761357d0c">More...</a><br /></td></tr>
<tr class="separator:af6f7e4e0b2339b3ac2e3b7a761357d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e627abcebb74bf780514be8d6c744c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a32e627abcebb74bf780514be8d6c744c">operator/</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;t)</td></tr>
<tr class="memdesc:a32e627abcebb74bf780514be8d6c744c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set minus  <a href="namespacehelib.html#a32e627abcebb74bf780514be8d6c744c">More...</a><br /></td></tr>
<tr class="separator:a32e627abcebb74bf780514be8d6c744c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c345e01afae95eff45dd95f58fab624"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5c345e01afae95eff45dd95f58fab624">operator&lt;&lt;</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;set)</td></tr>
<tr class="separator:a5c345e01afae95eff45dd95f58fab624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83df2fff1dfafef1f94191d2eb7d17e4"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a83df2fff1dfafef1f94191d2eb7d17e4">operator&gt;&gt;</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;set)</td></tr>
<tr class="separator:a83df2fff1dfafef1f94191d2eb7d17e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d7f36557c69a4840112f35af186a29"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab2d7f36557c69a4840112f35af186a29">card</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s)</td></tr>
<tr class="memdesc:ab2d7f36557c69a4840112f35af186a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional cardinality.  <a href="namespacehelib.html#ab2d7f36557c69a4840112f35af186a29">More...</a><br /></td></tr>
<tr class="separator:ab2d7f36557c69a4840112f35af186a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94835a294c90ee0ea0336561c8f38ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad94835a294c90ee0ea0336561c8f38ad">empty</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s)</td></tr>
<tr class="separator:ad94835a294c90ee0ea0336561c8f38ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13e586e5a2a1ea2fd8fe9e3c45b4c98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa13e586e5a2a1ea2fd8fe9e3c45b4c98">operator&lt;=</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s1, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s2)</td></tr>
<tr class="memdesc:aa13e586e5a2a1ea2fd8fe9e3c45b4c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is s1 subset or equal to s2.  <a href="namespacehelib.html#aa13e586e5a2a1ea2fd8fe9e3c45b4c98">More...</a><br /></td></tr>
<tr class="separator:aa13e586e5a2a1ea2fd8fe9e3c45b4c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd46fc7a6f4b03ce4a28aea9e7c0a451"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abd46fc7a6f4b03ce4a28aea9e7c0a451">operator&lt;</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s1, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s2)</td></tr>
<tr class="memdesc:abd46fc7a6f4b03ce4a28aea9e7c0a451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is s1 strict subset of s2.  <a href="namespacehelib.html#abd46fc7a6f4b03ce4a28aea9e7c0a451">More...</a><br /></td></tr>
<tr class="separator:abd46fc7a6f4b03ce4a28aea9e7c0a451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4807b29449792c9a8456921063d03c91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4807b29449792c9a8456921063d03c91">operator&gt;=</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s1, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s2)</td></tr>
<tr class="memdesc:a4807b29449792c9a8456921063d03c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is s2 subset or equal to s2.  <a href="namespacehelib.html#a4807b29449792c9a8456921063d03c91">More...</a><br /></td></tr>
<tr class="separator:a4807b29449792c9a8456921063d03c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d409fa53b729e5d370d032f643f321"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab7d409fa53b729e5d370d032f643f321">operator&gt;</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s1, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s2)</td></tr>
<tr class="memdesc:ab7d409fa53b729e5d370d032f643f321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is s2 strict subset of s1.  <a href="namespacehelib.html#ab7d409fa53b729e5d370d032f643f321">More...</a><br /></td></tr>
<tr class="separator:ab7d409fa53b729e5d370d032f643f321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a593337ace30bc0dd968cae8ed4564b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9a593337ace30bc0dd968cae8ed4564b">disjoint</a> (const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s1, const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;s2)</td></tr>
<tr class="memdesc:a9a593337ace30bc0dd968cae8ed4564b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional disjoint.  <a href="namespacehelib.html#a9a593337ace30bc0dd968cae8ed4564b">More...</a><br /></td></tr>
<tr class="separator:a9a593337ace30bc0dd968cae8ed4564b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b9141d04abb14f7f9fe94ee4d5c9ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad1b9141d04abb14f7f9fe94ee4d5c9ed">buildUnpackSlotEncoding</a> (std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;unpackSlotEncoding, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:ad1b9141d04abb14f7f9fe94ee4d5c9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610ab903802e50b91b45788be635dfc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a610ab903802e50b91b45788be635dfc1">unpack</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;unpacked, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;packed, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;unpackSlotEncoding)</td></tr>
<tr class="separator:a610ab903802e50b91b45788be635dfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02352b1415d1c647d5b8468cd479647b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a02352b1415d1c647d5b8468cd479647b">unpack</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;unpacked, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;packed, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;unpackSlotEncoding)</td></tr>
<tr class="separator:a02352b1415d1c647d5b8468cd479647b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52373565df70e730f9b11263a5c4434f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a52373565df70e730f9b11263a5c4434f">repack</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;packed, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;unpacked, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:a52373565df70e730f9b11263a5c4434f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43f61b11865cfa98e7999d1027cdd37"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa43f61b11865cfa98e7999d1027cdd37">repack</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;packed, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;unpacked, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:aa43f61b11865cfa98e7999d1027cdd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa135454e9085fe5e1f4b9f9dbc8eb55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa135454e9085fe5e1f4b9f9dbc8eb55c">unpackSlots</a> (std::vector&lt; std::size_t &gt; &amp;value, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:aa135454e9085fe5e1f4b9f9dbc8eb55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d3a80278b6196f62385f0d4d0efe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a611d3a80278b6196f62385f0d4d0efe9">unpackSlots</a> (std::vector&lt; std::size_t &gt; &amp;value, NTL::ZZX &amp;pa, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:a611d3a80278b6196f62385f0d4d0efe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ce2f6953045411b111ff7ee6f9c2d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a72ce2f6953045411b111ff7ee6f9c2d1">packConstant</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;result, unsigned long data, long nbits, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:a72ce2f6953045411b111ff7ee6f9c2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46ff7d24d107f5d26d907d52aea5264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae46ff7d24d107f5d26d907d52aea5264">packConstants</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;result, const std::vector&lt; std::size_t &gt; &amp;data, long nbits, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:ae46ff7d24d107f5d26d907d52aea5264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe91feb5d65b0afc826f181557a56e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3fe91feb5d65b0afc826f181557a56e4">writePubKeyBinary</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_pub_key.html">PubKey</a> &amp;pk)</td></tr>
<tr class="separator:a3fe91feb5d65b0afc826f181557a56e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9656603a03fba1b8720db0d2e5cee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adc9656603a03fba1b8720db0d2e5cee9">readPubKeyBinary</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_pub_key.html">PubKey</a> &amp;pk)</td></tr>
<tr class="separator:adc9656603a03fba1b8720db0d2e5cee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360f4b2c5989ceac05b2f37fe89239f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a360f4b2c5989ceac05b2f37fe89239f2">writeSecKeyBinary</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk)</td></tr>
<tr class="separator:a360f4b2c5989ceac05b2f37fe89239f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b0297bb0e296d5dc39bb328d735007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a69b0297bb0e296d5dc39bb328d735007">readSecKeyBinary</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk)</td></tr>
<tr class="separator:a69b0297bb0e296d5dc39bb328d735007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f74d875dc046b81eef94c8f091e5c09"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1f74d875dc046b81eef94c8f091e5c09">RLWE</a> (<a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;c0, <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;c1, const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;s, long p, NTL::ZZ *prgSeed=nullptr)</td></tr>
<tr class="separator:a1f74d875dc046b81eef94c8f091e5c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4349e62cf946950025929996328abf7c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4349e62cf946950025929996328abf7c">RLWE1</a> (<a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;c0, const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;c1, const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;s, long p)</td></tr>
<tr class="memdesc:a4349e62cf946950025929996328abf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as RLWE, but assumes that c1 is already chosen by the caller.  <a href="namespacehelib.html#a4349e62cf946950025929996328abf7c">More...</a><br /></td></tr>
<tr class="separator:a4349e62cf946950025929996328abf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b3ba4659fee95212891f530d1a88c1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae5b3ba4659fee95212891f530d1a88c1">operator&lt;&lt;</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_key_switch.html">KeySwitch</a> &amp;matrix)</td></tr>
<tr class="separator:ae5b3ba4659fee95212891f530d1a88c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eafbe78be51b304a8b359f7f6142ef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6eafbe78be51b304a8b359f7f6142ef5">Warning</a> (const char *msg)</td></tr>
<tr class="memdesc:a6eafbe78be51b304a8b359f7f6142ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for logging a warning message.  <a href="namespacehelib.html#a6eafbe78be51b304a8b359f7f6142ef5">More...</a><br /></td></tr>
<tr class="separator:a6eafbe78be51b304a8b359f7f6142ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9582d8b75aec10d74a0a89b48678be1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9582d8b75aec10d74a0a89b48678be1b">Warning</a> (const std::string &amp;msg)</td></tr>
<tr class="memdesc:a9582d8b75aec10d74a0a89b48678be1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for logging a warning message.  <a href="namespacehelib.html#a9582d8b75aec10d74a0a89b48678be1b">More...</a><br /></td></tr>
<tr class="separator:a9582d8b75aec10d74a0a89b48678be1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9f98f558e2fcf0a90b77e74f54958f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5e9f98f558e2fcf0a90b77e74f54958f">maximum_flow</a> (<a class="el" href="namespacehelib.html#af547f7016fc73b7174a2018ea28ef298">FlowGraph</a> &amp;fg, long src, long sink)</td></tr>
<tr class="separator:a5e9f98f558e2fcf0a90b77e74f54958f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc63b124cf6bc1dc82f4b599d373066c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#afc63b124cf6bc1dc82f4b599d373066c">traceMap</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt)</td></tr>
<tr class="separator:afc63b124cf6bc1dc82f4b599d373066c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4bb86fb8d5306854596862d66e440e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3c4bb86fb8d5306854596862d66e440e">mul</a> (<a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const <a class="el" href="classhelib_1_1_mat_mul1_d.html">MatMul1D</a> &amp;mat)</td></tr>
<tr class="separator:a3c4bb86fb8d5306854596862d66e440e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8141de7917e8d05d1a056a45a500615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa8141de7917e8d05d1a056a45a500615">mul</a> (<a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const <a class="el" href="classhelib_1_1_block_mat_mul1_d.html">BlockMatMul1D</a> &amp;mat)</td></tr>
<tr class="separator:aa8141de7917e8d05d1a056a45a500615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22728992014e959480483be6cad9c86f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a22728992014e959480483be6cad9c86f">mul</a> (<a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const <a class="el" href="classhelib_1_1_mat_mul_full.html">MatMulFull</a> &amp;mat)</td></tr>
<tr class="separator:a22728992014e959480483be6cad9c86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82ecaab9292facff3375eaf73ba6196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac82ecaab9292facff3375eaf73ba6196">mul</a> (<a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, const <a class="el" href="classhelib_1_1_block_mat_mul_full.html">BlockMatMulFull</a> &amp;mat)</td></tr>
<tr class="separator:ac82ecaab9292facff3375eaf73ba6196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741ff01e6d83fef924789f35d31af24b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , typename std::enable_if_t&lt; std::is_convertible&lt; T, std::size_t &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a741ff01e6d83fef924789f35d31af24b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a741ff01e6d83fef924789f35d31af24b">operator*</a> (const <a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt; T, 2 &gt; &amp;M1, const <a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt; T2, 2 &gt; &amp;M2)</td></tr>
<tr class="separator:a741ff01e6d83fef924789f35d31af24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffb94ff808c50cb557b7ab67d925453"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ffb94ff808c50cb557b7ab67d925453"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4ffb94ff808c50cb557b7ab67d925453">printMatrix</a> (const <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; T &gt; &amp;M, std::ostream &amp;out=std::cout)</td></tr>
<tr class="separator:a4ffb94ff808c50cb557b7ab67d925453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb375497516b4f80ee52cca6bbdf07fa"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#afb375497516b4f80ee52cca6bbdf07fa">sumOfCoeffs</a> (const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;f)</td></tr>
<tr class="separator:afb375497516b4f80ee52cca6bbdf07fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbfc533a08e770ed13e226150f57298"><td class="memItemLeft" align="right" valign="top">NTL::ZZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adcbfc533a08e770ed13e226150f57298">sumOfCoeffs</a> (const NTL::ZZX &amp;f)</td></tr>
<tr class="separator:adcbfc533a08e770ed13e226150f57298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dcd6fc8861bd6ead98d082fba87214"><td class="memItemLeft" align="right" valign="top">NTL::ZZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a31dcd6fc8861bd6ead98d082fba87214">sumOfCoeffs</a> (const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;f)</td></tr>
<tr class="separator:a31dcd6fc8861bd6ead98d082fba87214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4453a3ae42dffc130876e783bea3fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb4453a3ae42dffc130876e783bea3fe"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adb4453a3ae42dffc130876e783bea3fe">largestCoeff</a> (const NTL::Vec&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:adb4453a3ae42dffc130876e783bea3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The L-infinity norm of an element (in coefficient representation)  <a href="namespacehelib.html#adb4453a3ae42dffc130876e783bea3fe">More...</a><br /></td></tr>
<tr class="separator:adb4453a3ae42dffc130876e783bea3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f80e02dad1c557005618be367c28f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77f80e02dad1c557005618be367c28f8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a77f80e02dad1c557005618be367c28f8">largestCoeff</a> (const std::vector&lt; T &gt; &amp;f)</td></tr>
<tr class="separator:a77f80e02dad1c557005618be367c28f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a20a91635cf835f5d24ba9fc0431002"><td class="memItemLeft" align="right" valign="top">NTL::ZZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1a20a91635cf835f5d24ba9fc0431002">largestCoeff</a> (const NTL::ZZX &amp;f)</td></tr>
<tr class="separator:a1a20a91635cf835f5d24ba9fc0431002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46eaa10d04eed2ee69d9e2c0a52528a7"><td class="memItemLeft" align="right" valign="top">NTL::ZZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a46eaa10d04eed2ee69d9e2c0a52528a7">largestCoeff</a> (const NTL::Vec&lt; NTL::ZZ &gt; &amp;f)</td></tr>
<tr class="separator:a46eaa10d04eed2ee69d9e2c0a52528a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1a3a33c80ba67655fd3cf8e6e66831"><td class="memItemLeft" align="right" valign="top">NTL::ZZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abe1a3a33c80ba67655fd3cf8e6e66831">largestCoeff</a> (const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;f)</td></tr>
<tr class="separator:abe1a3a33c80ba67655fd3cf8e6e66831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eeef94d05d407f020712567c5eef27"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a05eeef94d05d407f020712567c5eef27">coeffsL2NormSquared</a> (const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;f)</td></tr>
<tr class="memdesc:a05eeef94d05d407f020712567c5eef27"><td class="mdescLeft">&#160;</td><td class="mdescRight">The L2-norm of an element (in coefficient representation)  <a href="namespacehelib.html#a05eeef94d05d407f020712567c5eef27">More...</a><br /></td></tr>
<tr class="separator:a05eeef94d05d407f020712567c5eef27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fe1adbf8a3a923231957865d6f7ade"><td class="memItemLeft" align="right" valign="top">NTL::xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a09fe1adbf8a3a923231957865d6f7ade">coeffsL2NormSquared</a> (const NTL::ZZX &amp;f)</td></tr>
<tr class="separator:a09fe1adbf8a3a923231957865d6f7ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39c73d6b51367807eca721bb748aadc"><td class="memItemLeft" align="right" valign="top">NTL::xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac39c73d6b51367807eca721bb748aadc">coeffsL2NormSquared</a> (const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;f)</td></tr>
<tr class="separator:ac39c73d6b51367807eca721bb748aadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c99506d6fcb0a0f0611a555e77fab3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a52c99506d6fcb0a0f0611a555e77fab3">coeffsL2Norm</a> (const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;f)</td></tr>
<tr class="separator:a52c99506d6fcb0a0f0611a555e77fab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae9e83dde78e745c57a36e18fc4372b"><td class="memItemLeft" align="right" valign="top">NTL::xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3ae9e83dde78e745c57a36e18fc4372b">coeffsL2Norm</a> (const NTL::ZZX &amp;f)</td></tr>
<tr class="separator:a3ae9e83dde78e745c57a36e18fc4372b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7865779ff5d7047037583852782963"><td class="memItemLeft" align="right" valign="top">NTL::xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3f7865779ff5d7047037583852782963">coeffsL2Norm</a> (const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;f)</td></tr>
<tr class="separator:a3f7865779ff5d7047037583852782963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1163a93bce42908b4edfa4e2a2989c49"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1163a93bce42908b4edfa4e2a2989c49">embeddingLargestCoeff</a> (const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;f, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:a1163a93bce42908b4edfa4e2a2989c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9543f301395b419a4026ea72424c01"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3a9543f301395b419a4026ea72424c01">embeddingLargestCoeff</a> (const std::vector&lt; double &gt; &amp;f, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:a3a9543f301395b419a4026ea72424c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338704cc219609b1663cc3b5bf1cb631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a338704cc219609b1663cc3b5bf1cb631">embeddingLargestCoeff_x2</a> (double &amp;norm1, double &amp;norm2, const std::vector&lt; double &gt; &amp;f1, const std::vector&lt; double &gt; &amp;f2, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:a338704cc219609b1663cc3b5bf1cb631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1d310e2dc35b38b4f87aeaa0e8c73c"><td class="memItemLeft" align="right" valign="top">NTL::xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aff1d310e2dc35b38b4f87aeaa0e8c73c">embeddingLargestCoeff</a> (const NTL::ZZX &amp;f, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:aff1d310e2dc35b38b4f87aeaa0e8c73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe1779765ee918f4c7e869ed86baf6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#affe1779765ee918f4c7e869ed86baf6a">CKKS_canonicalEmbedding</a> (std::vector&lt; <a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">cx_double</a> &gt; &amp;v, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;f, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:affe1779765ee918f4c7e869ed86baf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec3f9852eabd8796caf38d347501acd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5ec3f9852eabd8796caf38d347501acd">CKKS_canonicalEmbedding</a> (std::vector&lt; <a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">cx_double</a> &gt; &amp;v, const NTL::ZZX &amp;f, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:a5ec3f9852eabd8796caf38d347501acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd57ab6741a87f8b261d0a1417b8c5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7cd57ab6741a87f8b261d0a1417b8c5b">CKKS_canonicalEmbedding</a> (std::vector&lt; <a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">cx_double</a> &gt; &amp;v, const std::vector&lt; double &gt; &amp;f, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:a7cd57ab6741a87f8b261d0a1417b8c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec40f00efeb846267027bd14353fe4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5ec40f00efeb846267027bd14353fe4a">CKKS_embedInSlots</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;f, const std::vector&lt; <a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">cx_double</a> &gt; &amp;v, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg, double scaling)</td></tr>
<tr class="separator:a5ec40f00efeb846267027bd14353fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f51eef1d124d7e046b6a276d857fdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af8f51eef1d124d7e046b6a276d857fdb">setDryRun</a> (bool toWhat=true)</td></tr>
<tr class="separator:af8f51eef1d124d7e046b6a276d857fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79a0a06add60a27a1a2198fcf948e01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa79a0a06add60a27a1a2198fcf948e01">isDryRun</a> ()</td></tr>
<tr class="separator:aa79a0a06add60a27a1a2198fcf948e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce92a7a0f311e90d9022ea931a671ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1ce92a7a0f311e90d9022ea931a671ec">setAutomorphVals</a> (std::set&lt; long &gt; *aVals)</td></tr>
<tr class="separator:a1ce92a7a0f311e90d9022ea931a671ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac639ce6687180f2ac5e50e8706d79488"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac639ce6687180f2ac5e50e8706d79488">isSetAutomorphVals</a> ()</td></tr>
<tr class="separator:ac639ce6687180f2ac5e50e8706d79488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0cf6b325974c5fb87c29686d82e414"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7b0cf6b325974c5fb87c29686d82e414">recordAutomorphVal</a> (long k)</td></tr>
<tr class="separator:a7b0cf6b325974c5fb87c29686d82e414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fab1809e50aa6fc8c0f80e66943f490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8fab1809e50aa6fc8c0f80e66943f490">setAutomorphVals2</a> (std::set&lt; long &gt; *aVals)</td></tr>
<tr class="separator:a8fab1809e50aa6fc8c0f80e66943f490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7fd713547b09f8f18fbf95ccf83f95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aff7fd713547b09f8f18fbf95ccf83f95">isSetAutomorphVals2</a> ()</td></tr>
<tr class="separator:aff7fd713547b09f8f18fbf95ccf83f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479ecb7208f177739fa83913e8515192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a479ecb7208f177739fa83913e8515192">recordAutomorphVal2</a> (long k)</td></tr>
<tr class="separator:a479ecb7208f177739fa83913e8515192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cd0b7c9b7fa0afbb885295f10d9354"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af6cd0b7c9b7fa0afbb885295f10d9354">bitSetToLong</a> (long bits, long bitSize)</td></tr>
<tr class="memdesc:af6cd0b7c9b7fa0afbb885295f10d9354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Considers <code>bits</code> as a vector of bits and returns the value it represents when interpreted as a n-bit 2's complement number, where n is given by <code>bitSize</code>.  <a href="namespacehelib.html#af6cd0b7c9b7fa0afbb885295f10d9354">More...</a><br /></td></tr>
<tr class="separator:af6cd0b7c9b7fa0afbb885295f10d9354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2638750d81a618d59217f3e9b3218a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3f2638750d81a618d59217f3e9b3218a">mcMod</a> (long a, long b)</td></tr>
<tr class="memdesc:a3f2638750d81a618d59217f3e9b3218a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines for computing mathematically correct mod and div.  <a href="namespacehelib.html#a3f2638750d81a618d59217f3e9b3218a">More...</a><br /></td></tr>
<tr class="separator:a3f2638750d81a618d59217f3e9b3218a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f60e27cb24d575d4b10a522dbb4279"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a51f60e27cb24d575d4b10a522dbb4279">mcDiv</a> (long a, long b)</td></tr>
<tr class="separator:a51f60e27cb24d575d4b10a522dbb4279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af183ee91810e5601837e62dfb85df0cd"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af183ee91810e5601837e62dfb85df0cd">balRem</a> (long a, long q)</td></tr>
<tr class="separator:af183ee91810e5601837e62dfb85df0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92538fab792f75e009a2330c365637d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad92538fab792f75e009a2330c365637d">fsquare</a> (double x)</td></tr>
<tr class="memdesc:ad92538fab792f75e009a2330c365637d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of a number as a double.  <a href="namespacehelib.html#ad92538fab792f75e009a2330c365637d">More...</a><br /></td></tr>
<tr class="separator:ad92538fab792f75e009a2330c365637d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc760be384a17313e24f5383ceabd1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a96fc760be384a17313e24f5383ceabd1">multOrd</a> (long p, long m)</td></tr>
<tr class="memdesc:a96fc760be384a17313e24f5383ceabd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return multiplicative order of p modulo m, or 0 if GCD(p, m) != 1.  <a href="namespacehelib.html#a96fc760be384a17313e24f5383ceabd1">More...</a><br /></td></tr>
<tr class="separator:a96fc760be384a17313e24f5383ceabd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb8f2124f5f56970fe7f88802c976b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acdb8f2124f5f56970fe7f88802c976b1">ppsolve</a> (NTL::vec_zz_pE &amp;x, const NTL::mat_zz_pE &amp;A, const NTL::vec_zz_pE &amp;b, long p, long r)</td></tr>
<tr class="memdesc:acdb8f2124f5f56970fe7f88802c976b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prime power solver.  <a href="namespacehelib.html#acdb8f2124f5f56970fe7f88802c976b1">More...</a><br /></td></tr>
<tr class="separator:acdb8f2124f5f56970fe7f88802c976b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faaee69d7f687471cb483dfa78e6701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0faaee69d7f687471cb483dfa78e6701">ppsolve</a> (NTL::vec_GF2E &amp;x, const NTL::mat_GF2E &amp;A, const NTL::vec_GF2E &amp;b, long p, long r)</td></tr>
<tr class="memdesc:a0faaee69d7f687471cb483dfa78e6701"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version for GF2: must have p == 2 and r == 1.  <a href="namespacehelib.html#a0faaee69d7f687471cb483dfa78e6701">More...</a><br /></td></tr>
<tr class="separator:a0faaee69d7f687471cb483dfa78e6701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784e87216f278000cfa935b61657da58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a784e87216f278000cfa935b61657da58">ppInvert</a> (NTL::mat_zz_p &amp;X, const NTL::mat_zz_p &amp;A, long p, long r)</td></tr>
<tr class="memdesc:a784e87216f278000cfa935b61657da58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse mod p^r of an n x n matrix.  <a href="namespacehelib.html#a784e87216f278000cfa935b61657da58">More...</a><br /></td></tr>
<tr class="separator:a784e87216f278000cfa935b61657da58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a34ea89aec17e40d20d534e210a14f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a73a34ea89aec17e40d20d534e210a14f">ppInvert</a> (NTL::mat_zz_pE &amp;X, const NTL::mat_zz_pE &amp;A, long p, long r)</td></tr>
<tr class="separator:a73a34ea89aec17e40d20d534e210a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35b575565f163995c6abd08972bddf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af35b575565f163995c6abd08972bddf2">ppInvert</a> (NTL::mat_GF2 &amp;X, const NTL::mat_GF2 &amp;A, UNUSED long p, UNUSED long r)</td></tr>
<tr class="separator:af35b575565f163995c6abd08972bddf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46606ccee8c1fe481e3b5a1f90291c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac46606ccee8c1fe481e3b5a1f90291c5">ppInvert</a> (NTL::mat_GF2E &amp;X, const NTL::mat_GF2E &amp;A, UNUSED long p, UNUSED long r)</td></tr>
<tr class="separator:ac46606ccee8c1fe481e3b5a1f90291c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db28e5ca105b114e0c89655eee171b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7db28e5ca105b114e0c89655eee171b9">buildLinPolyMatrix</a> (NTL::mat_zz_pE &amp;M, long p)</td></tr>
<tr class="separator:a7db28e5ca105b114e0c89655eee171b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82218a5a8f14a790b60cd7f288863b9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a82218a5a8f14a790b60cd7f288863b9d">buildLinPolyMatrix</a> (NTL::mat_GF2E &amp;M, long p)</td></tr>
<tr class="separator:a82218a5a8f14a790b60cd7f288863b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5711dacd10c102835bd585bff52e32c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5711dacd10c102835bd585bff52e32c5">buildLinPolyCoeffs</a> (NTL::vec_zz_pE &amp;C, const NTL::vec_zz_pE &amp;L, long p, long r)</td></tr>
<tr class="memdesc:a5711dacd10c102835bd585bff52e32c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combination of buildLinPolyMatrix and ppsolve.  <a href="namespacehelib.html#a5711dacd10c102835bd585bff52e32c5">More...</a><br /></td></tr>
<tr class="separator:a5711dacd10c102835bd585bff52e32c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78f42668b74b50bfeec97988619350c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae78f42668b74b50bfeec97988619350c">buildLinPolyCoeffs</a> (NTL::vec_GF2E &amp;C, const NTL::vec_GF2E &amp;L, long p, long r)</td></tr>
<tr class="memdesc:ae78f42668b74b50bfeec97988619350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version for GF2: must be called with p == 2 and r == 1.  <a href="namespacehelib.html#ae78f42668b74b50bfeec97988619350c">More...</a><br /></td></tr>
<tr class="separator:ae78f42668b74b50bfeec97988619350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dda3f81ff66fb0e9a92bc39ecad0a92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0dda3f81ff66fb0e9a92bc39ecad0a92">applyLinPoly</a> (NTL::zz_pE &amp;beta, const NTL::vec_zz_pE &amp;C, const NTL::zz_pE &amp;alpha, long p)</td></tr>
<tr class="memdesc:a0dda3f81ff66fb0e9a92bc39ecad0a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a linearized polynomial with coefficient vector C.  <a href="namespacehelib.html#a0dda3f81ff66fb0e9a92bc39ecad0a92">More...</a><br /></td></tr>
<tr class="separator:a0dda3f81ff66fb0e9a92bc39ecad0a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379dfd6585b3c7aab695a9ca33a7ad89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a379dfd6585b3c7aab695a9ca33a7ad89">applyLinPoly</a> (NTL::GF2E &amp;beta, const NTL::vec_GF2E &amp;C, const NTL::GF2E &amp;alpha, long p)</td></tr>
<tr class="memdesc:a379dfd6585b3c7aab695a9ca33a7ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version for GF2: must be called with p == 2 and r == 1.  <a href="namespacehelib.html#a379dfd6585b3c7aab695a9ca33a7ad89">More...</a><br /></td></tr>
<tr class="separator:a379dfd6585b3c7aab695a9ca33a7ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1630d15e5b8352685afcf561db40323"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac1630d15e5b8352685afcf561db40323">log2</a> (const NTL::xdouble &amp;x)</td></tr>
<tr class="memdesc:ac1630d15e5b8352685afcf561db40323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base-2 logarithm.  <a href="namespacehelib.html#ac1630d15e5b8352685afcf561db40323">More...</a><br /></td></tr>
<tr class="separator:ac1630d15e5b8352685afcf561db40323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d163aa9f73ad476ebd97d7778d79258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8d163aa9f73ad476ebd97d7778d79258">factorize</a> (std::vector&lt; long &gt; &amp;factors, long N)</td></tr>
<tr class="memdesc:a8d163aa9f73ad476ebd97d7778d79258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factoring by trial division, only works for N&lt;2^{60}, only the primes are recorded, not their multiplicity.  <a href="namespacehelib.html#a8d163aa9f73ad476ebd97d7778d79258">More...</a><br /></td></tr>
<tr class="separator:a8d163aa9f73ad476ebd97d7778d79258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a26515bfdcb0f7e654cefa0d955d4be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0a26515bfdcb0f7e654cefa0d955d4be">factorize</a> (std::vector&lt; NTL::ZZ &gt; &amp;factors, const NTL::ZZ &amp;N)</td></tr>
<tr class="separator:a0a26515bfdcb0f7e654cefa0d955d4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dc52f12b0306195238f56bcf4a112b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a75dc52f12b0306195238f56bcf4a112b">factorize</a> (NTL::Vec&lt; NTL::Pair&lt; long, long &gt;&gt; &amp;factors, long N)</td></tr>
<tr class="memdesc:a75dc52f12b0306195238f56bcf4a112b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factoring by trial division, only works for N&lt;2^{60} primes and multiplicities are recorded.  <a href="namespacehelib.html#a75dc52f12b0306195238f56bcf4a112b">More...</a><br /></td></tr>
<tr class="separator:a75dc52f12b0306195238f56bcf4a112b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407ad6533d4dd3820cc35b07ad41988b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a407ad6533d4dd3820cc35b07ad41988b">pp_factorize</a> (std::vector&lt; long &gt; &amp;factors, long N)</td></tr>
<tr class="memdesc:a407ad6533d4dd3820cc35b07ad41988b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prime-power factorization.  <a href="namespacehelib.html#a407ad6533d4dd3820cc35b07ad41988b">More...</a><br /></td></tr>
<tr class="separator:a407ad6533d4dd3820cc35b07ad41988b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add32ec15c61473a42b7136dee8360b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#add32ec15c61473a42b7136dee8360b8b">phiN</a> (long &amp;phiN, std::vector&lt; long &gt; &amp;facts, long N)</td></tr>
<tr class="memdesc:add32ec15c61473a42b7136dee8360b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Phi(N) and also factorize N.  <a href="namespacehelib.html#add32ec15c61473a42b7136dee8360b8b">More...</a><br /></td></tr>
<tr class="separator:add32ec15c61473a42b7136dee8360b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dc0ba06446370515708c0229fa046e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a62dc0ba06446370515708c0229fa046e">phiN</a> (NTL::ZZ &amp;phiN, std::vector&lt; NTL::ZZ &gt; &amp;facts, const NTL::ZZ &amp;N)</td></tr>
<tr class="separator:a62dc0ba06446370515708c0229fa046e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e575c4502d7606d86b46af66600ce0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a93e575c4502d7606d86b46af66600ce0">phi_N</a> (long N)</td></tr>
<tr class="memdesc:a93e575c4502d7606d86b46af66600ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Phi(N).  <a href="namespacehelib.html#a93e575c4502d7606d86b46af66600ce0">More...</a><br /></td></tr>
<tr class="separator:a93e575c4502d7606d86b46af66600ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f0037687252f6999a8526165cd8e41"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a67f0037687252f6999a8526165cd8e41">findGenerators</a> (std::vector&lt; long &gt; &amp;gens, std::vector&lt; long &gt; &amp;ords, long m, long p, const std::vector&lt; long &gt; &amp;candidates=std::vector&lt; long &gt;())</td></tr>
<tr class="separator:a67f0037687252f6999a8526165cd8e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1f9936cf8c582202702cbb65eaf2ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9e1f9936cf8c582202702cbb65eaf2ce">FindPrimitiveRoot</a> (NTL::zz_p &amp;r, unsigned long e)</td></tr>
<tr class="memdesc:a9e1f9936cf8c582202702cbb65eaf2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find e-th root of unity modulo the current modulus.  <a href="namespacehelib.html#a9e1f9936cf8c582202702cbb65eaf2ce">More...</a><br /></td></tr>
<tr class="separator:a9e1f9936cf8c582202702cbb65eaf2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ed622332f1680e6384644d3c347e19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae3ed622332f1680e6384644d3c347e19">FindPrimitiveRoot</a> (NTL::ZZ_p &amp;r, unsigned long e)</td></tr>
<tr class="separator:ae3ed622332f1680e6384644d3c347e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d98c1a6634ea3827fafd456ea56a5e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad4d98c1a6634ea3827fafd456ea56a5e">mobius</a> (long n)</td></tr>
<tr class="memdesc:ad4d98c1a6634ea3827fafd456ea56a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mobius function (naive method as n is small).  <a href="namespacehelib.html#ad4d98c1a6634ea3827fafd456ea56a5e">More...</a><br /></td></tr>
<tr class="separator:ad4d98c1a6634ea3827fafd456ea56a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181a74dc451ffc410450d6c238f2a68c"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a181a74dc451ffc410450d6c238f2a68c">Cyclotomic</a> (long N)</td></tr>
<tr class="memdesc:a181a74dc451ffc410450d6c238f2a68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cyclotomic polynomial.  <a href="namespacehelib.html#a181a74dc451ffc410450d6c238f2a68c">More...</a><br /></td></tr>
<tr class="separator:a181a74dc451ffc410450d6c238f2a68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad7e0c1723b324e29278f21aa889143"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adad7e0c1723b324e29278f21aa889143">makeIrredPoly</a> (long p, long d)</td></tr>
<tr class="memdesc:adad7e0c1723b324e29278f21aa889143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a degree-d irreducible polynomial mod p.  <a href="namespacehelib.html#adad7e0c1723b324e29278f21aa889143">More...</a><br /></td></tr>
<tr class="separator:adad7e0c1723b324e29278f21aa889143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5c3e6a25c84bcec39b646e10598378"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9b5c3e6a25c84bcec39b646e10598378">primroot</a> (long N, long <a class="el" href="namespacehelib.html#add32ec15c61473a42b7136dee8360b8b">phiN</a>)</td></tr>
<tr class="memdesc:a9b5c3e6a25c84bcec39b646e10598378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a primitive root modulo N.  <a href="namespacehelib.html#a9b5c3e6a25c84bcec39b646e10598378">More...</a><br /></td></tr>
<tr class="separator:a9b5c3e6a25c84bcec39b646e10598378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8693a4a2d91babebc9b8887bbcd1f0ea"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8693a4a2d91babebc9b8887bbcd1f0ea">ord</a> (long N, long p)</td></tr>
<tr class="memdesc:a8693a4a2d91babebc9b8887bbcd1f0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the highest power of p that divides N.  <a href="namespacehelib.html#a8693a4a2d91babebc9b8887bbcd1f0ea">More...</a><br /></td></tr>
<tr class="separator:a8693a4a2d91babebc9b8887bbcd1f0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dbaa8bc9cf194a1e08fd5af3497a5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a57dbaa8bc9cf194a1e08fd5af3497a5e">is2power</a> (long m)</td></tr>
<tr class="separator:a57dbaa8bc9cf194a1e08fd5af3497a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bcd83ef1650a094f9ba12551a2e9e4"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad0bcd83ef1650a094f9ba12551a2e9e4">RandPoly</a> (long n, const NTL::ZZ &amp;p)</td></tr>
<tr class="separator:ad0bcd83ef1650a094f9ba12551a2e9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc507c5ea1850c348a7c2d743b59a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8fc507c5ea1850c348a7c2d743b59a57">MulMod</a> (NTL::ZZX &amp;out, const NTL::ZZX &amp;f, long a, long q, bool abs)</td></tr>
<tr class="separator:a8fc507c5ea1850c348a7c2d743b59a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73b2f08337ba65b54609e7bfca96cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af73b2f08337ba65b54609e7bfca96cda">MulMod</a> (NTL::ZZX &amp;out, const NTL::ZZX &amp;f, long a, long q)</td></tr>
<tr class="separator:af73b2f08337ba65b54609e7bfca96cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a8cf8d3d1da74a8060a177e3e49028"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a44a8cf8d3d1da74a8060a177e3e49028">MulMod</a> (const NTL::ZZX &amp;f, long a, long q, bool abs)</td></tr>
<tr class="separator:a44a8cf8d3d1da74a8060a177e3e49028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16376b83d0b9ac08d1cc631756741220"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a16376b83d0b9ac08d1cc631756741220">MulMod</a> (const NTL::ZZX &amp;f, long a, long q)</td></tr>
<tr class="separator:a16376b83d0b9ac08d1cc631756741220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e504f2374c5e7357c7608a94527887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a00e504f2374c5e7357c7608a94527887">balanced_MulMod</a> (NTL::ZZX &amp;out, const NTL::ZZX &amp;f, long a, long q)</td></tr>
<tr class="separator:a00e504f2374c5e7357c7608a94527887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e47ad408b14cf352174243c3c8adf6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab2e47ad408b14cf352174243c3c8adf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab2e47ad408b14cf352174243c3c8adf6">convert</a> (T1 &amp;x1, const T2 &amp;x2)</td></tr>
<tr class="memdesc:ab2e47ad408b14cf352174243c3c8adf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic template that resolves to NTL's conv routine.  <a href="namespacehelib.html#ab2e47ad408b14cf352174243c3c8adf6">More...</a><br /></td></tr>
<tr class="separator:ab2e47ad408b14cf352174243c3c8adf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e1e9edc58b546c8d12a4cb56812f81"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a59e1e9edc58b546c8d12a4cb56812f81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a59e1e9edc58b546c8d12a4cb56812f81">convert</a> (std::vector&lt; T1 &gt; &amp;v1, const std::vector&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a59e1e9edc58b546c8d12a4cb56812f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic vector conversion routines  <a href="namespacehelib.html#a59e1e9edc58b546c8d12a4cb56812f81">More...</a><br /></td></tr>
<tr class="separator:a59e1e9edc58b546c8d12a4cb56812f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d8cacfd0370294ae07fb571ee2caee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab5d8cacfd0370294ae07fb571ee2caee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab5d8cacfd0370294ae07fb571ee2caee">convert</a> (std::vector&lt; T1 &gt; &amp;v1, const NTL::Vec&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="separator:ab5d8cacfd0370294ae07fb571ee2caee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33593bb6e050f5639138bf3f76a28d8c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a33593bb6e050f5639138bf3f76a28d8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a33593bb6e050f5639138bf3f76a28d8c">convert</a> (NTL::Vec&lt; T1 &gt; &amp;v1, const std::vector&lt; T2 &gt; &amp;v2)</td></tr>
<tr class="separator:a33593bb6e050f5639138bf3f76a28d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59b9ea3393970dcb1c4a9ef6ef310ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa59b9ea3393970dcb1c4a9ef6ef310ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa59b9ea3393970dcb1c4a9ef6ef310ef">convert</a> (std::vector&lt; T &gt; &amp;v1, const std::vector&lt; T &gt; &amp;v2)</td></tr>
<tr class="memdesc:aa59b9ea3393970dcb1c4a9ef6ef310ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial type conversion, useful for generic code.  <a href="namespacehelib.html#aa59b9ea3393970dcb1c4a9ef6ef310ef">More...</a><br /></td></tr>
<tr class="separator:aa59b9ea3393970dcb1c4a9ef6ef310ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194a7e93c41b4da649614c39e9a77c8f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a194a7e93c41b4da649614c39e9a77c8f"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a194a7e93c41b4da649614c39e9a77c8f">convert</a> (const T2 &amp;v2)</td></tr>
<tr class="separator:a194a7e93c41b4da649614c39e9a77c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f11bbe3deab00c9a1dc525d23958a6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f11bbe3deab00c9a1dc525d23958a6c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3f11bbe3deab00c9a1dc525d23958a6c">vector_replicate</a> (const T &amp;a, long n)</td></tr>
<tr class="separator:a3f11bbe3deab00c9a1dc525d23958a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ccc2648ee5736fe519c1c884bf1b68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29ccc2648ee5736fe519c1c884bf1b68"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a29ccc2648ee5736fe519c1c884bf1b68">Vec_replicate</a> (const T &amp;a, long n)</td></tr>
<tr class="separator:a29ccc2648ee5736fe519c1c884bf1b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9837bdade0e2dabb7bbf0d03a5e2e93b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9837bdade0e2dabb7bbf0d03a5e2e93b">computeProd</a> (const NTL::Vec&lt; long &gt; &amp;vec)</td></tr>
<tr class="memdesc:a9837bdade0e2dabb7bbf0d03a5e2e93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns \prod_d vec[d]  <a href="namespacehelib.html#a9837bdade0e2dabb7bbf0d03a5e2e93b">More...</a><br /></td></tr>
<tr class="separator:a9837bdade0e2dabb7bbf0d03a5e2e93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aababf76c7325db9e7409cf950a581993"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aababf76c7325db9e7409cf950a581993">computeProd</a> (const std::vector&lt; long &gt; &amp;vec)</td></tr>
<tr class="separator:aababf76c7325db9e7409cf950a581993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c25069289464e0a2fb8398199fd5ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a50c25069289464e0a2fb8398199fd5ef">mul</a> (std::vector&lt; NTL::ZZX &gt; &amp;x, const std::vector&lt; NTL::ZZX &gt; &amp;a, long b)</td></tr>
<tr class="separator:a50c25069289464e0a2fb8398199fd5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9965244b44a7884f3e08999f6adec16f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9965244b44a7884f3e08999f6adec16f">div</a> (std::vector&lt; NTL::ZZX &gt; &amp;x, const std::vector&lt; NTL::ZZX &gt; &amp;a, long b)</td></tr>
<tr class="separator:a9965244b44a7884f3e08999f6adec16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33424cc1805af9dc818e142033c9d9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a33424cc1805af9dc818e142033c9d9be">add</a> (std::vector&lt; NTL::ZZX &gt; &amp;x, const std::vector&lt; NTL::ZZX &gt; &amp;a, const std::vector&lt; NTL::ZZX &gt; &amp;b)</td></tr>
<tr class="separator:a33424cc1805af9dc818e142033c9d9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1249c9ddf12d285f6c06985342e52562"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1249c9ddf12d285f6c06985342e52562">is_in</a> (long x, int *X, long sz)</td></tr>
<tr class="memdesc:a1249c9ddf12d285f6c06985342e52562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds whether x is an element of the set X of size sz, Returns -1 it not and the location if true.  <a href="namespacehelib.html#a1249c9ddf12d285f6c06985342e52562">More...</a><br /></td></tr>
<tr class="separator:a1249c9ddf12d285f6c06985342e52562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcde52d4dcf5f9f26931c54efa401258"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#afcde52d4dcf5f9f26931c54efa401258">CRTcoeff</a> (long p, long q, bool symmetric=false)</td></tr>
<tr class="memdesc:afcde52d4dcf5f9f26931c54efa401258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a CRT coefficient: x = (0 mod p, 1 mod q). If symmetric is set then x \in [-pq/2, pq/2), else x \in [0,pq)  <a href="namespacehelib.html#afcde52d4dcf5f9f26931c54efa401258">More...</a><br /></td></tr>
<tr class="separator:afcde52d4dcf5f9f26931c54efa401258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5165f6a4ea9a752c8c40d5790acfb4e0"><td class="memTemplParams" colspan="2">template&lt;class zzvec &gt; </td></tr>
<tr class="memitem:a5165f6a4ea9a752c8c40d5790acfb4e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5165f6a4ea9a752c8c40d5790acfb4e0">intVecCRT</a> (NTL::vec_ZZ &amp;vp, const NTL::ZZ &amp;p, const zzvec &amp;vq, long q)</td></tr>
<tr class="memdesc:a5165f6a4ea9a752c8c40d5790acfb4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incremental integer CRT for vectors.  <a href="namespacehelib.html#a5165f6a4ea9a752c8c40d5790acfb4e0">More...</a><br /></td></tr>
<tr class="separator:a5165f6a4ea9a752c8c40d5790acfb4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa88363f3a91a37ba8e213b0cb764ea5"><td class="memTemplParams" colspan="2">template&lt;typename T , bool maxFlag&gt; </td></tr>
<tr class="memitem:aaa88363f3a91a37ba8e213b0cb764ea5"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aaa88363f3a91a37ba8e213b0cb764ea5">argminmax</a> (std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aaa88363f3a91a37ba8e213b0cb764ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the (first) largest/smallest element.  <a href="namespacehelib.html#aaa88363f3a91a37ba8e213b0cb764ea5">More...</a><br /></td></tr>
<tr class="separator:aaa88363f3a91a37ba8e213b0cb764ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84a9818e92cbee595e4895ad9dee849"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae84a9818e92cbee595e4895ad9dee849"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae84a9818e92cbee595e4895ad9dee849">argmax</a> (std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:ae84a9818e92cbee595e4895ad9dee849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4218a947a483c68d1727c537c216c347"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4218a947a483c68d1727c537c216c347"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4218a947a483c68d1727c537c216c347">argmin</a> (std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a4218a947a483c68d1727c537c216c347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acced988b8c7248219e7c13e20d1d0e6c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acced988b8c7248219e7c13e20d1d0e6c">argmax</a> (std::vector&lt; long &gt; &amp;v, bool(*moreThan)(long, long))</td></tr>
<tr class="memdesc:acced988b8c7248219e7c13e20d1d0e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant with a specialized comparison function (*moreThan)(a,b) returns the comparison a&gt;b.  <a href="namespacehelib.html#acced988b8c7248219e7c13e20d1d0e6c">More...</a><br /></td></tr>
<tr class="separator:acced988b8c7248219e7c13e20d1d0e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b607a9ca070971badf105209dc47583"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3b607a9ca070971badf105209dc47583">closeToOne</a> (const NTL::xdouble &amp;x, long p)</td></tr>
<tr class="separator:a3b607a9ca070971badf105209dc47583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f697f7ff3bbb3d9d17f75d35946991"><td class="memItemLeft" align="right" valign="top">std::pair&lt; long, long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a03f697f7ff3bbb3d9d17f75d35946991">rationalApprox</a> (double x, long denomBound=0)</td></tr>
<tr class="separator:a03f697f7ff3bbb3d9d17f75d35946991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564d4348157a8775888f09a680313ba6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; NTL::ZZ, NTL::ZZ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a564d4348157a8775888f09a680313ba6">rationalApprox</a> (NTL::xdouble x, NTL::xdouble denomBound=NTL::xdouble(0.0))</td></tr>
<tr class="separator:a564d4348157a8775888f09a680313ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df3789de0744e7c90d5a5d6cf54a5ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0df3789de0744e7c90d5a5d6cf54a5ed">seekPastChar</a> (std::istream &amp;str, int cc)</td></tr>
<tr class="memdesc:a0df3789de0744e7c90d5a5d6cf54a5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the input stream beyond white spaces and a single instance of the char cc.  <a href="namespacehelib.html#a0df3789de0744e7c90d5a5d6cf54a5ed">More...</a><br /></td></tr>
<tr class="separator:a0df3789de0744e7c90d5a5d6cf54a5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c386c997a1dfb9113bb7a7070d95e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a002c386c997a1dfb9113bb7a7070d95e">iterateInterestRegion</a> (std::istream &amp;str, int begin_char, int separator, int end_char)</td></tr>
<tr class="memdesc:a002c386c997a1dfb9113bb7a7070d95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the input stream <code>str</code> beyond white spaces and a single <code>separator</code> in the region-of-interest delimited by <code>begin_char</code> and <code>end_char</code>.  <a href="namespacehelib.html#a002c386c997a1dfb9113bb7a7070d95e">More...</a><br /></td></tr>
<tr class="separator:a002c386c997a1dfb9113bb7a7070d95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b904688ca513ad603df4d470c5ae21"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::stringstream &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad5b904688ca513ad603df4d470c5ae21">extractTokenizeRegion</a> (std::istream &amp;istr, char begin_char, char end_char, char separator, bool skip_space=true)</td></tr>
<tr class="memdesc:ad5b904688ca513ad603df4d470c5ae21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the input stream <code>istr</code> beyond white spaces. Then split the region delimited by <code>begin_char</code> and <code>end_char</code> at each occurrence of <code>separator</code> that is not contained in an inner <code>begin_char</code> - <code>end_char</code> section. The function returns a <code>std::vector&lt;std::stringstream&gt;</code> with the stream of every section of the input region.  <a href="namespacehelib.html#ad5b904688ca513ad603df4d470c5ae21">More...</a><br /></td></tr>
<tr class="separator:ad5b904688ca513ad603df4d470c5ae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfd59b19280a7a98989bbc0dd6a8c2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dfd59b19280a7a98989bbc0dd6a8c2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8dfd59b19280a7a98989bbc0dd6a8c2c">reverse</a> (NTL::Vec&lt; T &gt; &amp;v, long lo, long hi)</td></tr>
<tr class="memdesc:a8dfd59b19280a7a98989bbc0dd6a8c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a vector in place.  <a href="namespacehelib.html#a8dfd59b19280a7a98989bbc0dd6a8c2c">More...</a><br /></td></tr>
<tr class="separator:a8dfd59b19280a7a98989bbc0dd6a8c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1688528ff1a377be38502ae7c048336c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1688528ff1a377be38502ae7c048336c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1688528ff1a377be38502ae7c048336c">rotate</a> (NTL::Vec&lt; T &gt; &amp;v, long k)</td></tr>
<tr class="memdesc:a1688528ff1a377be38502ae7c048336c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a vector in place using swaps.  <a href="namespacehelib.html#a1688528ff1a377be38502ae7c048336c">More...</a><br /></td></tr>
<tr class="separator:a1688528ff1a377be38502ae7c048336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f65ef133cee27ad846423d012d5487"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8f65ef133cee27ad846423d012d5487"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae8f65ef133cee27ad846423d012d5487">lsize</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ae8f65ef133cee27ad846423d012d5487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of STL vector as a long (rather than unsigned long)  <a href="namespacehelib.html#ae8f65ef133cee27ad846423d012d5487">More...</a><br /></td></tr>
<tr class="separator:ae8f65ef133cee27ad846423d012d5487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca37f043534295ce82c13c09b48325f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ca37f043534295ce82c13c09b48325f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3ca37f043534295ce82c13c09b48325f">killVec</a> (std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a3ca37f043534295ce82c13c09b48325f"><td class="mdescLeft">&#160;</td><td class="mdescRight">NTL/std compatibility.  <a href="namespacehelib.html#a3ca37f043534295ce82c13c09b48325f">More...</a><br /></td></tr>
<tr class="separator:a3ca37f043534295ce82c13c09b48325f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d98d78d4a4dddc7c6859af409b17e07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d98d78d4a4dddc7c6859af409b17e07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5d98d78d4a4dddc7c6859af409b17e07">killVec</a> (NTL::Vec&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a5d98d78d4a4dddc7c6859af409b17e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2de6d470f49ed882f0bde7b67f5c456"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2de6d470f49ed882f0bde7b67f5c456"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae2de6d470f49ed882f0bde7b67f5c456">setLengthZero</a> (std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:ae2de6d470f49ed882f0bde7b67f5c456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b53294ce70bc1a04b741ef3ac4512d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07b53294ce70bc1a04b741ef3ac4512d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a07b53294ce70bc1a04b741ef3ac4512d">setLengthZero</a> (NTL::Vec&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a07b53294ce70bc1a04b741ef3ac4512d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cb104179094690467c87a1c09c8a05"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50cb104179094690467c87a1c09c8a05"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a50cb104179094690467c87a1c09c8a05">lsize</a> (const NTL::Vec&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a50cb104179094690467c87a1c09c8a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61eac49543dd3559b386f94ca7112c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad61eac49543dd3559b386f94ca7112c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad61eac49543dd3559b386f94ca7112c9">resize</a> (NTL::Vec&lt; T &gt; &amp;v, long sz, const T &amp;val)</td></tr>
<tr class="separator:ad61eac49543dd3559b386f94ca7112c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8aea4186c17622aa24763219ba2e39c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8aea4186c17622aa24763219ba2e39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae8aea4186c17622aa24763219ba2e39c">resize</a> (std::vector&lt; T &gt; &amp;v, long sz, const T &amp;val)</td></tr>
<tr class="separator:ae8aea4186c17622aa24763219ba2e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b481e5ebaa9bc469124e7c2d5eae38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49b481e5ebaa9bc469124e7c2d5eae38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a49b481e5ebaa9bc469124e7c2d5eae38">resize</a> (NTL::Vec&lt; T &gt; &amp;v, long sz)</td></tr>
<tr class="separator:a49b481e5ebaa9bc469124e7c2d5eae38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e17a6dd739205036bdc410372608cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91e17a6dd739205036bdc410372608cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a91e17a6dd739205036bdc410372608cc">resize</a> (std::vector&lt; T &gt; &amp;v, long sz)</td></tr>
<tr class="separator:a91e17a6dd739205036bdc410372608cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dac9d465c144cdd7f736730704c38e6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a1dac9d465c144cdd7f736730704c38e6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1dac9d465c144cdd7f736730704c38e6">sameObject</a> (const T1 *p1, const T2 *p2)</td></tr>
<tr class="memdesc:a1dac9d465c144cdd7f736730704c38e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Testing if two vectors point to the same object.  <a href="namespacehelib.html#a1dac9d465c144cdd7f736730704c38e6">More...</a><br /></td></tr>
<tr class="separator:a1dac9d465c144cdd7f736730704c38e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d7a435e482d03e39e3b592765adc85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad7d7a435e482d03e39e3b592765adc85">ModComp</a> (NTL::ZZX &amp;res, const NTL::ZZX &amp;g, const NTL::ZZX &amp;h, const NTL::ZZX &amp;f)</td></tr>
<tr class="memdesc:ad7d7a435e482d03e39e3b592765adc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modular composition of polynomials: res = g(h) mod f.  <a href="namespacehelib.html#ad7d7a435e482d03e39e3b592765adc85">More...</a><br /></td></tr>
<tr class="separator:ad7d7a435e482d03e39e3b592765adc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11db92e970f97ed66aebb1702dc5a0df"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a11db92e970f97ed66aebb1702dc5a0df">polyEvalMod</a> (const NTL::ZZX &amp;poly, long x, long p)</td></tr>
<tr class="memdesc:a11db92e970f97ed66aebb1702dc5a0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a modular integer polynomial, returns poly(x) mod p.  <a href="namespacehelib.html#a11db92e970f97ed66aebb1702dc5a0df">More...</a><br /></td></tr>
<tr class="separator:a11db92e970f97ed66aebb1702dc5a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7d6d68a0351702ae31c17eb4e72307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9e7d6d68a0351702ae31c17eb4e72307">interpolateMod</a> (NTL::ZZX &amp;poly, const NTL::vec_long &amp;x, const NTL::vec_long &amp;y, long p, long e=1)</td></tr>
<tr class="memdesc:a9e7d6d68a0351702ae31c17eb4e72307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate polynomial such that poly(x[i] mod p)=y[i] (mod p^e) It is assumed that the points x[i] are all distinct modulo p.  <a href="namespacehelib.html#a9e7d6d68a0351702ae31c17eb4e72307">More...</a><br /></td></tr>
<tr class="separator:a9e7d6d68a0351702ae31c17eb4e72307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ff9e17791a3dd96ca79b2dd4d0654d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad8ff9e17791a3dd96ca79b2dd4d0654d">divc</a> (long a, long b)</td></tr>
<tr class="memdesc:ad8ff9e17791a3dd96ca79b2dd4d0654d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns ceiling(a/b); assumes a &gt;=0, b&gt;0, a+b &lt;= MAX_LONG  <a href="namespacehelib.html#ad8ff9e17791a3dd96ca79b2dd4d0654d">More...</a><br /></td></tr>
<tr class="separator:ad8ff9e17791a3dd96ca79b2dd4d0654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b15d5fbf553550437df6ca02d5a282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af7b15d5fbf553550437df6ca02d5a282">rem</a> (NTL::zz_pX &amp;r, const NTL::zz_pX &amp;a, const <a class="el" href="classhelib_1_1zz__p_x_modulus1.html">zz_pXModulus1</a> &amp;ff)</td></tr>
<tr class="separator:af7b15d5fbf553550437df6ca02d5a282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd0e83a2e59c7de3a489b5d3fb3aa8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91bd0e83a2e59c7de3a489b5d3fb3aa8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a91bd0e83a2e59c7de3a489b5d3fb3aa8">operator&lt;&lt;</a> (std::ostream &amp;s, std::vector&lt; T &gt; v)</td></tr>
<tr class="separator:a91bd0e83a2e59c7de3a489b5d3fb3aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b06418a6494e921dec0c5d086cf46ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b06418a6494e921dec0c5d086cf46ce"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2b06418a6494e921dec0c5d086cf46ce">operator&gt;&gt;</a> (std::istream &amp;s, std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a2b06418a6494e921dec0c5d086cf46ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa86d423a862384884b7bed74e573e8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa86d423a862384884b7bed74e573e8f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aaa86d423a862384884b7bed74e573e8f">vecToStr</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:aaa86d423a862384884b7bed74e573e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1040284398724d43661ac3eff7a7400e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1040284398724d43661ac3eff7a7400e"><td class="memTemplItemLeft" align="right" valign="top">NTL::Vec&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1040284398724d43661ac3eff7a7400e">atoVec</a> (const char *a)</td></tr>
<tr class="separator:a1040284398724d43661ac3eff7a7400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd11aa1bf58d7ac5843fe3ee5fb244c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdd11aa1bf58d7ac5843fe3ee5fb244c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acdd11aa1bf58d7ac5843fe3ee5fb244c">atovector</a> (const char *a)</td></tr>
<tr class="separator:acdd11aa1bf58d7ac5843fe3ee5fb244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19a0354bdc3a0ef4ba47d01c8a4aaaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab19a0354bdc3a0ef4ba47d01c8a4aaaf">TofftRep_trunc</a> (NTL::fftRep &amp;y, const NTL::zz_pX &amp;x, long k, UNUSED long len, long lo, long hi)</td></tr>
<tr class="separator:ab19a0354bdc3a0ef4ba47d01c8a4aaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3259e4f89f7c305b12bd13bab812ef72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3259e4f89f7c305b12bd13bab812ef72">TofftRep_trunc</a> (NTL::fftRep &amp;y, const NTL::zz_pX &amp;x, long k, long len)</td></tr>
<tr class="separator:a3259e4f89f7c305b12bd13bab812ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113e6cbc8db288631df5f13330027dc3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a113e6cbc8db288631df5f13330027dc3">max_abs</a> (const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;vec)</td></tr>
<tr class="separator:a113e6cbc8db288631df5f13330027dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a15540439b4c2c57e1e5eb129cd54a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a21a15540439b4c2c57e1e5eb129cd54a">max_abs</a> (const std::vector&lt; double &gt; &amp;vec)</td></tr>
<tr class="separator:a21a15540439b4c2c57e1e5eb129cd54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454437c5c0e3415fe2a360fa48a3eb5f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename... Args&gt; </td></tr>
<tr class="memitem:a454437c5c0e3415fe2a360fa48a3eb5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a454437c5c0e3415fe2a360fa48a3eb5f">make_lazy</a> (const NTL::Lazy&lt; T, P &gt; &amp;obj, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a454437c5c0e3415fe2a360fa48a3eb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c7ab380349944791e571afd60e7a06"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename F , typename... Args&gt; </td></tr>
<tr class="memitem:a05c7ab380349944791e571afd60e7a06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a05c7ab380349944791e571afd60e7a06">make_lazy_with_fun</a> (const NTL::Lazy&lt; T, P &gt; &amp;obj, F f, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a05c7ab380349944791e571afd60e7a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad5bd5c310b0ad7f96d6e2065e5b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_p_algebra_mod_base.html">PAlgebraModBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af7ad5bd5c310b0ad7f96d6e2065e5b2b">buildPAlgebraMod</a> (const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;zMStar, long r)</td></tr>
<tr class="memdesc:af7ad5bd5c310b0ad7f96d6e2065e5b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a table, of type PA_GF2 if p == 2 and r == 1, and PA_zz_p otherwise.  <a href="namespacehelib.html#af7ad5bd5c310b0ad7f96d6e2065e5b2b">More...</a><br /></td></tr>
<tr class="separator:af7ad5bd5c310b0ad7f96d6e2065e5b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4e8a7e6a0c99087b87431d7478e4d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aed4e8a7e6a0c99087b87431d7478e4d6">comparePAlgebra</a> (const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg, unsigned long m, unsigned long p, unsigned long r, const std::vector&lt; long &gt; &amp;gens, const std::vector&lt; long &gt; &amp;ords)</td></tr>
<tr class="memdesc:aed4e8a7e6a0c99087b87431d7478e4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the palg parameters match the rest, false otherwise  <a href="namespacehelib.html#aed4e8a7e6a0c99087b87431d7478e4d6">More...</a><br /></td></tr>
<tr class="separator:aed4e8a7e6a0c99087b87431d7478e4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742ec1357ca244079dacd7c1cb2fcb90"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a742ec1357ca244079dacd7c1cb2fcb90">calcPolyNormBnd</a> (long m)</td></tr>
<tr class="separator:a742ec1357ca244079dacd7c1cb2fcb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65801611ad6b47e4cb4c37bf86e5be5"><td class="memTemplParams" colspan="2">template&lt;typename TXT &gt; </td></tr>
<tr class="memitem:ac65801611ad6b47e4cb4c37bf86e5be5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; TXT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac65801611ad6b47e4cb4c37bf86e5be5">calculateMasks</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; TXT &gt; query, const <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt;&gt; &amp;database)</td></tr>
<tr class="memdesc:ac65801611ad6b47e4cb4c37bf86e5be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a query set and a database, calculates a mask of {0,1} where 1 signifies a matching element and 0 otherwise.  <a href="namespacehelib.html#ac65801611ad6b47e4cb4c37bf86e5be5">More...</a><br /></td></tr>
<tr class="separator:ac65801611ad6b47e4cb4c37bf86e5be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afe505ae7315e1226c3fd95f8ea3487"><td class="memTemplParams" colspan="2">template&lt;typename TXT &gt; </td></tr>
<tr class="memitem:a3afe505ae7315e1226c3fd95f8ea3487"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3afe505ae7315e1226c3fd95f8ea3487">calculateMasks</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; TXT &gt; query, const <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;database)</td></tr>
<tr class="memdesc:a3afe505ae7315e1226c3fd95f8ea3487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a query set and a database, calculates a mask of {0,1} where 1 signifies a matching element and 0 otherwise.  <a href="namespacehelib.html#a3afe505ae7315e1226c3fd95f8ea3487">More...</a><br /></td></tr>
<tr class="separator:a3afe505ae7315e1226c3fd95f8ea3487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b9e18a6520b9b54c6adc3096bdaf87"><td class="memTemplParams" colspan="2">template&lt;typename TXT &gt; </td></tr>
<tr class="memitem:a78b9e18a6520b9b54c6adc3096bdaf87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; TXT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a78b9e18a6520b9b54c6adc3096bdaf87">calculateScores</a> (const std::vector&lt; std::vector&lt; long &gt;&gt; index_sets, const std::vector&lt; long &gt; &amp;offsets, const std::vector&lt; <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; long &gt;&gt; &amp;weights, const <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; TXT &gt; &amp;mask)</td></tr>
<tr class="memdesc:a78b9e18a6520b9b54c6adc3096bdaf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mask and information about the query to be performed, calculates a score for each matching element signified by the mask.  <a href="namespacehelib.html#a78b9e18a6520b9b54c6adc3096bdaf87">More...</a><br /></td></tr>
<tr class="separator:a78b9e18a6520b9b54c6adc3096bdaf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527dbcddde6c00dcf8ba8117b9290043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a527dbcddde6c00dcf8ba8117b9290043">partialMatchEncode</a> (uint32_t input, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="memdesc:a527dbcddde6c00dcf8ba8117b9290043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a value, encode the value across the coefficients of a polynomial.  <a href="namespacehelib.html#a527dbcddde6c00dcf8ba8117b9290043">More...</a><br /></td></tr>
<tr class="separator:a527dbcddde6c00dcf8ba8117b9290043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2e968f2faca98f693ac809962242ba"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhelib_1_1_col_number.html">ColNumber</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5b2e968f2faca98f693ac809962242ba">makeQueryExpr</a> (int cl)</td></tr>
<tr class="memdesc:a5b2e968f2faca98f693ac809962242ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating a shared pointer to a specified column in a query.  <a href="namespacehelib.html#a5b2e968f2faca98f693ac809962242ba">More...</a><br /></td></tr>
<tr class="separator:a5b2e968f2faca98f693ac809962242ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e3d7533fd36aed14028db8a0aec5c2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhelib_1_1_and.html">And</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad1e3d7533fd36aed14028db8a0aec5c2">operator&amp;&amp;</a> (const <a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">QueryExpr</a> &amp;lhs, const <a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">QueryExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad1e3d7533fd36aed14028db8a0aec5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded operator for creating a shared pointer to an AND expression.  <a href="namespacehelib.html#ad1e3d7533fd36aed14028db8a0aec5c2">More...</a><br /></td></tr>
<tr class="separator:ad1e3d7533fd36aed14028db8a0aec5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52eacb5c692c3fbf563e88a7ee693fcf"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhelib_1_1_or.html">Or</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a52eacb5c692c3fbf563e88a7ee693fcf">operator||</a> (const <a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">QueryExpr</a> &amp;lhs, const <a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">QueryExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:a52eacb5c692c3fbf563e88a7ee693fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded operator for creating a shared pointer to an OR expression.  <a href="namespacehelib.html#a52eacb5c692c3fbf563e88a7ee693fcf">More...</a><br /></td></tr>
<tr class="separator:a52eacb5c692c3fbf563e88a7ee693fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf8627539f6c1c46e6ae9287058f7cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0cf8627539f6c1c46e6ae9287058f7cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0cf8627539f6c1c46e6ae9287058f7cc">applyPermToVec</a> (NTL::Vec&lt; T &gt; &amp;out, const NTL::Vec&lt; T &gt; &amp;in, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p1)</td></tr>
<tr class="memdesc:a0cf8627539f6c1c46e6ae9287058f7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a permutation to a std::vector, out[i]=in[p1[i]] (NOT in-place)  <a href="namespacehelib.html#a0cf8627539f6c1c46e6ae9287058f7cc">More...</a><br /></td></tr>
<tr class="separator:a0cf8627539f6c1c46e6ae9287058f7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae99af99454c783bed9cbde7cd72058"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abae99af99454c783bed9cbde7cd72058"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abae99af99454c783bed9cbde7cd72058">applyPermToVec</a> (std::vector&lt; T &gt; &amp;out, const std::vector&lt; T &gt; &amp;in, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p1)</td></tr>
<tr class="separator:abae99af99454c783bed9cbde7cd72058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae17bbc28a578112d0fe28b99f5e204"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ae17bbc28a578112d0fe28b99f5e204"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0ae17bbc28a578112d0fe28b99f5e204">applyPermsToVec</a> (NTL::Vec&lt; T &gt; &amp;out, const NTL::Vec&lt; T &gt; &amp;in, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p2, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p1)</td></tr>
<tr class="memdesc:a0ae17bbc28a578112d0fe28b99f5e204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply two permutations to a std::vector out[i]=in[p2[p1[i]]] (NOT in-place)  <a href="namespacehelib.html#a0ae17bbc28a578112d0fe28b99f5e204">More...</a><br /></td></tr>
<tr class="separator:a0ae17bbc28a578112d0fe28b99f5e204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6d61d4ac69597feb9beedc26bf93cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c6d61d4ac69597feb9beedc26bf93cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6c6d61d4ac69597feb9beedc26bf93cc">applyPermsToVec</a> (std::vector&lt; T &gt; &amp;out, const std::vector&lt; T &gt; &amp;in, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p2, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p1)</td></tr>
<tr class="separator:a6c6d61d4ac69597feb9beedc26bf93cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74c29f86e466570325f829fe4ea74b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa74c29f86e466570325f829fe4ea74b0">randomPerm</a> (<a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;perm, long n)</td></tr>
<tr class="memdesc:aa74c29f86e466570325f829fe4ea74b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random size-n permutation.  <a href="namespacehelib.html#aa74c29f86e466570325f829fe4ea74b0">More...</a><br /></td></tr>
<tr class="separator:aa74c29f86e466570325f829fe4ea74b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b38e2bdf2734a792b5f11fe5f293be"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac6b38e2bdf2734a792b5f11fe5f293be">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_col_perm.html">ColPerm</a> &amp;p)</td></tr>
<tr class="separator:ac6b38e2bdf2734a792b5f11fe5f293be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11554e25622d14682edfa2be22ed6df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a11554e25622d14682edfa2be22ed6df6">breakPermByDim</a> (std::vector&lt; <a class="el" href="classhelib_1_1_col_perm.html">ColPerm</a> &gt; &amp;out, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;pi, const <a class="el" href="classhelib_1_1_cube_signature.html">CubeSignature</a> &amp;sig)</td></tr>
<tr class="memdesc:a11554e25622d14682edfa2be22ed6df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a permutation pi over m-dimensional cube C=Z_{n1} x...x Z_{nm} and expresses pi as a product pi = rho_{2m-1} o ... o rho_2 o rho_1 where each rho_i is a column permutation along one dimension. Specifically for i&lt;m, the permutations rho_i and rho_{2(m-1)-i} permute the i'th dimension.  <a href="namespacehelib.html#a11554e25622d14682edfa2be22ed6df6">More...</a><br /></td></tr>
<tr class="separator:a11554e25622d14682edfa2be22ed6df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342c01cce2724537976f9ce808e6b8ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a342c01cce2724537976f9ce808e6b8ec">polyEval</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ret, NTL::ZZX poly, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;x, long k=0)</td></tr>
<tr class="memdesc:a342c01cce2724537976f9ce808e6b8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a cleartext polynomial on an encrypted input.  <a href="namespacehelib.html#a342c01cce2724537976f9ce808e6b8ec">More...</a><br /></td></tr>
<tr class="separator:a342c01cce2724537976f9ce808e6b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15c89ffe2770b53c9484aa56555bc3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad15c89ffe2770b53c9484aa56555bc3f">polyEval</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ret, const NTL::Vec&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;poly, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;x)</td></tr>
<tr class="memdesc:ad15c89ffe2770b53c9484aa56555bc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an encrypted polynomial on an encrypted input.  <a href="namespacehelib.html#ad15c89ffe2770b53c9484aa56555bc3f">More...</a><br /></td></tr>
<tr class="separator:ad15c89ffe2770b53c9484aa56555bc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546b744efbb3ba1575148bcb9e2ba724"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a546b744efbb3ba1575148bcb9e2ba724">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;e)</td></tr>
<tr class="separator:a546b744efbb3ba1575148bcb9e2ba724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bfd95691bb88ca7ee135b5ad074f4d"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa6bfd95691bb88ca7ee135b5ad074f4d">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;e)</td></tr>
<tr class="separator:aa6bfd95691bb88ca7ee135b5ad074f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d92caff425c0086a87a667c88003d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a39d92caff425c0086a87a667c88003d4">write</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;e)</td></tr>
<tr class="separator:a39d92caff425c0086a87a667c88003d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5197bb5b6cad37f9d4a4a7c7e7bf8d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac5197bb5b6cad37f9d4a4a7c7e7bf8d0">read</a> (std::istream &amp;s, <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;e)</td></tr>
<tr class="separator:ac5197bb5b6cad37f9d4a4a7c7e7bf8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7c647ab302e0d9844b52884e086071"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d7c647ab302e0d9844b52884e086071"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1d7c647ab302e0d9844b52884e086071">lsize</a> (const <a class="el" href="structhelib_1_1_ptr_matrix.html">PtrMatrix</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a1d7c647ab302e0d9844b52884e086071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65519409bc5c0f7c328147d8664ce5fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65519409bc5c0f7c328147d8664ce5fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a65519409bc5c0f7c328147d8664ce5fb">resize</a> (<a class="el" href="structhelib_1_1_ptr_matrix.html">PtrMatrix</a>&lt; T &gt; &amp;v, long newSize)</td></tr>
<tr class="separator:a65519409bc5c0f7c328147d8664ce5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0a4656214afc3e52fa83408be3ff6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c0a4656214afc3e52fa83408be3ff6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5c0a4656214afc3e52fa83408be3ff6a">setLengthZero</a> (<a class="el" href="structhelib_1_1_ptr_matrix.html">PtrMatrix</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a5c0a4656214afc3e52fa83408be3ff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33a07f0cc97da66e279f71195515763"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab33a07f0cc97da66e279f71195515763"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab33a07f0cc97da66e279f71195515763">ptr2nonNull</a> (std::initializer_list&lt; const <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; * &gt; list)</td></tr>
<tr class="separator:ab33a07f0cc97da66e279f71195515763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368a1406fcc81e32dce3caebda60477b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a368a1406fcc81e32dce3caebda60477b"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a368a1406fcc81e32dce3caebda60477b">lsize</a> (const <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a368a1406fcc81e32dce3caebda60477b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030064c52dceba94106ffbd8afb564ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a030064c52dceba94106ffbd8afb564ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a030064c52dceba94106ffbd8afb564ef">setLengthZero</a> (<a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a030064c52dceba94106ffbd8afb564ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810f01874466a0f57b41f96b8cb7a96c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a810f01874466a0f57b41f96b8cb7a96c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a810f01874466a0f57b41f96b8cb7a96c">resize</a> (<a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;v, long newSize, const T &amp;val)</td></tr>
<tr class="separator:a810f01874466a0f57b41f96b8cb7a96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1574e2c95b30b1eb204d669f029368"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a1574e2c95b30b1eb204d669f029368"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6a1574e2c95b30b1eb204d669f029368">resize</a> (<a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;v, long newSize, const T *val)</td></tr>
<tr class="separator:a6a1574e2c95b30b1eb204d669f029368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ca08051d06a786cf812e238a0cad15"><td class="memTemplParams" colspan="2">template&lt;typename V1 , typename V2 &gt; </td></tr>
<tr class="memitem:a03ca08051d06a786cf812e238a0cad15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a03ca08051d06a786cf812e238a0cad15">vecCopy</a> (V1 &amp;v1, const V2 &amp;v2, long sizeLimit=0)</td></tr>
<tr class="separator:a03ca08051d06a786cf812e238a0cad15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d8218e2c0fee25ebec6d40d2a6036d"><td class="memTemplParams" colspan="2">template&lt;typename V , typename T &gt; </td></tr>
<tr class="memitem:aa4d8218e2c0fee25ebec6d40d2a6036d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa4d8218e2c0fee25ebec6d40d2a6036d">vecCopy</a> (V &amp;v1, const <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;v2, long sizeLimit=0)</td></tr>
<tr class="separator:aa4d8218e2c0fee25ebec6d40d2a6036d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd2ecf9ca1ddd7c2e7372fb8999030d"><td class="memTemplParams" colspan="2">template&lt;typename V , typename T &gt; </td></tr>
<tr class="memitem:a7dd2ecf9ca1ddd7c2e7372fb8999030d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7dd2ecf9ca1ddd7c2e7372fb8999030d">vecCopy</a> (<a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;v1, const V &amp;v2, long sizeLimit=0)</td></tr>
<tr class="separator:a7dd2ecf9ca1ddd7c2e7372fb8999030d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1de5f6a3cb9f9da27cd496659cc899"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b1de5f6a3cb9f9da27cd496659cc899"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2b1de5f6a3cb9f9da27cd496659cc899">vecCopy</a> (<a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;v1, const <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;v2, long sizeLimit=0)</td></tr>
<tr class="separator:a2b1de5f6a3cb9f9da27cd496659cc899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05ae4d1e5789165fa5fe70824e87077"><td class="memTemplParams" colspan="2">template&lt;typename From , typename Scheme &gt; </td></tr>
<tr class="memitem:ae05ae4d1e5789165fa5fe70824e87077"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Scheme::SlotType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae05ae4d1e5789165fa5fe70824e87077">convertDataToSlotVector</a> (const std::vector&lt; From &gt; &amp;data, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="memdesc:ae05ae4d1e5789165fa5fe70824e87077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>std::vector&lt;From&gt;</code> to <code>std::vector&lt;Scheme::SlotType&gt;</code>.  <a href="namespacehelib.html#ae05ae4d1e5789165fa5fe70824e87077">More...</a><br /></td></tr>
<tr class="separator:ae05ae4d1e5789165fa5fe70824e87077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d0e8b458fb8f75fa79ff7c7effe58e"><td class="memTemplParams" colspan="2">template&lt;typename Scheme &gt; </td></tr>
<tr class="memitem:a98d0e8b458fb8f75fa79ff7c7effe58e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a98d0e8b458fb8f75fa79ff7c7effe58e">innerProduct</a> (<a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;result, const std::vector&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt;&gt; &amp;first_vec, const std::vector&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt;&gt; &amp;second_vec)</td></tr>
<tr class="memdesc:a98d0e8b458fb8f75fa79ff7c7effe58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free function that computes the inner product of two vectors of <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code>.  <a href="namespacehelib.html#a98d0e8b458fb8f75fa79ff7c7effe58e">More...</a><br /></td></tr>
<tr class="separator:a98d0e8b458fb8f75fa79ff7c7effe58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69f30064b062723cecac335a73fdcdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa69f30064b062723cecac335a73fdcdd">deserialize</a> (std::istream &amp;is, std::complex&lt; double &gt; &amp;num)</td></tr>
<tr class="memdesc:aa69f30064b062723cecac335a73fdcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a <code>std::complex&lt;double&gt;</code> from the input stream <code>is</code> delimited by '[' and ']' (instead of the default '(', ')').  <a href="namespacehelib.html#aa69f30064b062723cecac335a73fdcdd">More...</a><br /></td></tr>
<tr class="separator:aa69f30064b062723cecac335a73fdcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb4ae8ef54886b93b4639999a620630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adcb4ae8ef54886b93b4639999a620630">serialize</a> (std::ostream &amp;os, const std::complex&lt; double &gt; &amp;num)</td></tr>
<tr class="memdesc:adcb4ae8ef54886b93b4639999a620630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code>std::complex&lt;double&gt;</code> to the output stream <code>os</code> delimited by '[' and ']' (instead of the default '(', ')').  <a href="namespacehelib.html#adcb4ae8ef54886b93b4639999a620630">More...</a><br /></td></tr>
<tr class="separator:adcb4ae8ef54886b93b4639999a620630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b41101191111377485d5adf5c4693c1"><td class="memTemplParams" colspan="2">template&lt;typename Scheme &gt; </td></tr>
<tr class="memitem:a9b41101191111377485d5adf5c4693c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9b41101191111377485d5adf5c4693c1">deserialize</a> (std::istream &amp;is, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;ptxt)</td></tr>
<tr class="memdesc:a9b41101191111377485d5adf5c4693c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to deserialize a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;Scheme&gt;</code>.  <a href="namespacehelib.html#a9b41101191111377485d5adf5c4693c1">More...</a><br /></td></tr>
<tr class="separator:a9b41101191111377485d5adf5c4693c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41ed1eb42cb018a129e7cb2fbbb29ff"><td class="memTemplParams" colspan="2">template&lt;typename Scheme &gt; </td></tr>
<tr class="memitem:ab41ed1eb42cb018a129e7cb2fbbb29ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab41ed1eb42cb018a129e7cb2fbbb29ff">serialize</a> (std::ostream &amp;os, const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;ptxt)</td></tr>
<tr class="memdesc:ab41ed1eb42cb018a129e7cb2fbbb29ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to serialize a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;Scheme&gt;</code>.  <a href="namespacehelib.html#ab41ed1eb42cb018a129e7cb2fbbb29ff">More...</a><br /></td></tr>
<tr class="separator:ab41ed1eb42cb018a129e7cb2fbbb29ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2e5c3ec63886e4fbb71a7ed16f4a9b"><td class="memTemplParams" colspan="2">template&lt;typename Scheme &gt; </td></tr>
<tr class="memitem:abc2e5c3ec63886e4fbb71a7ed16f4a9b"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abc2e5c3ec63886e4fbb71a7ed16f4a9b">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;ptxt)</td></tr>
<tr class="memdesc:abc2e5c3ec63886e4fbb71a7ed16f4a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input shift operator. Uses the <code>deserialize</code> function internally.  <a href="namespacehelib.html#abc2e5c3ec63886e4fbb71a7ed16f4a9b">More...</a><br /></td></tr>
<tr class="separator:abc2e5c3ec63886e4fbb71a7ed16f4a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8df733be35482f6834a083a9de5e4a6"><td class="memTemplParams" colspan="2">template&lt;typename Scheme &gt; </td></tr>
<tr class="memitem:af8df733be35482f6834a083a9de5e4a6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af8df733be35482f6834a083a9de5e4a6">operator&lt;&lt;</a> (std::ostream &amp;is, const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;ptxt)</td></tr>
<tr class="memdesc:af8df733be35482f6834a083a9de5e4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output shift operator. Uses the <code>serialize</code> function internally.  <a href="namespacehelib.html#af8df733be35482f6834a083a9de5e4a6">More...</a><br /></td></tr>
<tr class="separator:af8df733be35482f6834a083a9de5e4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dcd30d8cce97ee562725b5c096b464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_mat_mul1_d.html">MatMul1D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac6dcd30d8cce97ee562725b5c096b464">buildRandomMatrix</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, long dim)</td></tr>
<tr class="separator:ac6dcd30d8cce97ee562725b5c096b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3080cc6971659bc69c9c758f42300cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_mat_mul1_d.html">MatMul1D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3080cc6971659bc69c9c758f42300cb9">buildRandomMultiMatrix</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, long dim)</td></tr>
<tr class="separator:a3080cc6971659bc69c9c758f42300cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa512e08a2be7acf51509eb138d53f819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_block_mat_mul1_d.html">BlockMatMul1D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa512e08a2be7acf51509eb138d53f819">buildRandomBlockMatrix</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, long dim)</td></tr>
<tr class="separator:aa512e08a2be7acf51509eb138d53f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f720bf0e8e389648203490dd91630ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_block_mat_mul1_d.html">BlockMatMul1D</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3f720bf0e8e389648203490dd91630ec">buildRandomMultiBlockMatrix</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, long dim)</td></tr>
<tr class="separator:a3f720bf0e8e389648203490dd91630ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1a434a5001c49cfce898915c2faa51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_mat_mul_full.html">MatMulFull</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#afb1a434a5001c49cfce898915c2faa51">buildRandomFullMatrix</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:afb1a434a5001c49cfce898915c2faa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40abf9db3a61a5c21c6f836acbeb8c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_block_mat_mul_full.html">BlockMatMulFull</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a40abf9db3a61a5c21c6f836acbeb8c80">buildRandomFullBlockMatrix</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:a40abf9db3a61a5c21c6f836acbeb8c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcff6470686ad80a2319fa1652ac1e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1general__range.html">general_range</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5dcff6470686ad80a2319fa1652ac1e3">range</a> (long n)</td></tr>
<tr class="separator:a5dcff6470686ad80a2319fa1652ac1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c6fd54cca700ce3a8beca19bf0ceaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1general__range.html">general_range</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae4c6fd54cca700ce3a8beca19bf0ceaa">range</a> (long m, long n)</td></tr>
<tr class="separator:ae4c6fd54cca700ce3a8beca19bf0ceaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bebe2d214c86938103f34adecb7ff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a28bebe2d214c86938103f34adecb7ff3">replicate</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctx, long pos)</td></tr>
<tr class="memdesc:a28bebe2d214c86938103f34adecb7ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value in slot #pos is replicated in all other slots. On an n-slot ciphertext, this algorithm performs O(log n) 1D rotations.  <a href="namespacehelib.html#a28bebe2d214c86938103f34adecb7ff3">More...</a><br /></td></tr>
<tr class="separator:a28bebe2d214c86938103f34adecb7ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb07910b30bab32f4ebf91af705e3c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adb07910b30bab32f4ebf91af705e3c6d">replicate0</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, long pos)</td></tr>
<tr class="memdesc:adb07910b30bab32f4ebf91af705e3c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lower-level routine. Same as replicate, but assumes all slots are zero except slot #pos.  <a href="namespacehelib.html#adb07910b30bab32f4ebf91af705e3c6d">More...</a><br /></td></tr>
<tr class="separator:adb07910b30bab32f4ebf91af705e3c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f84fcea62365a27445739f444d81db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a55f84fcea62365a27445739f444d81db">replicateAll</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, <a class="el" href="classhelib_1_1_replicate_handler.html">ReplicateHandler</a> *handler, long recBound=64, RepAuxDim *repAuxPtr=nullptr)</td></tr>
<tr class="separator:a55f84fcea62365a27445739f444d81db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a2f3a3e50d07abc0a16161003fc0b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab0a2f3a3e50d07abc0a16161003fc0b5">replicateAll</a> (std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;v, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, long recBound=64, RepAuxDim *repAuxPtr=nullptr)</td></tr>
<tr class="separator:ab0a2f3a3e50d07abc0a16161003fc0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80787c8857d1d8b8b4fad63f11201626"><td class="memTemplParams" colspan="2">template&lt;typename Scheme &gt; </td></tr>
<tr class="memitem:a80787c8857d1d8b8b4fad63f11201626"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a80787c8857d1d8b8b4fad63f11201626">replicateAll</a> (std::vector&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt;&gt; &amp;v, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;, const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;ptxt)</td></tr>
<tr class="memdesc:a80787c8857d1d8b8b4fad63f11201626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector of plaintexts with each slot replicated in each plaintext.  <a href="namespacehelib.html#a80787c8857d1d8b8b4fad63f11201626">More...</a><br /></td></tr>
<tr class="separator:a80787c8857d1d8b8b4fad63f11201626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12fb4b6143d8e2cb6a5dbf36922fbe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae12fb4b6143d8e2cb6a5dbf36922fbe7">replicateAllOrig</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, <a class="el" href="classhelib_1_1_replicate_handler.html">ReplicateHandler</a> *handler, RepAux *repAuxPtr=nullptr)</td></tr>
<tr class="separator:ae12fb4b6143d8e2cb6a5dbf36922fbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6d6a64a8c538bb0189ac908896ac6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2c6d6a64a8c538bb0189ac908896ac6c">replicate</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa, long i)</td></tr>
<tr class="separator:a2c6d6a64a8c538bb0189ac908896ac6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14f023af8c881464a3dbaf01b18d7da"><td class="memTemplParams" colspan="2">template&lt;typename Scheme &gt; </td></tr>
<tr class="memitem:ae14f023af8c881464a3dbaf01b18d7da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae14f023af8c881464a3dbaf01b18d7da">replicate</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;ptxt, long i)</td></tr>
<tr class="memdesc:ae14f023af8c881464a3dbaf01b18d7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate single slot of a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> object across all of its slots.  <a href="namespacehelib.html#ae14f023af8c881464a3dbaf01b18d7da">More...</a><br /></td></tr>
<tr class="separator:ae14f023af8c881464a3dbaf01b18d7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5ec6f6ac945f2c5bcdf04fb7bcf0a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abc5ec6f6ac945f2c5bcdf04fb7bcf0a9">sampleSmall</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, long n, double prob=0.5)</td></tr>
<tr class="separator:abc5ec6f6ac945f2c5bcdf04fb7bcf0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aab1a9871644fc36223b8009290ef66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7aab1a9871644fc36223b8009290ef66">sampleSmall</a> (NTL::ZZX &amp;poly, long n, double prob=0.5)</td></tr>
<tr class="separator:a7aab1a9871644fc36223b8009290ef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cebf12977a97396ba96bdc5fe8162e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3cebf12977a97396ba96bdc5fe8162e7">sampleHWt</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, long n, long Hwt=100)</td></tr>
<tr class="memdesc:a3cebf12977a97396ba96bdc5fe8162e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a degree-(n-1) poly as above, with only Hwt nonzero coefficients.  <a href="namespacehelib.html#a3cebf12977a97396ba96bdc5fe8162e7">More...</a><br /></td></tr>
<tr class="separator:a3cebf12977a97396ba96bdc5fe8162e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa510a5dd7033e859ab4e6759a1b1b207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa510a5dd7033e859ab4e6759a1b1b207">sampleHWt</a> (NTL::ZZX &amp;poly, long n, long Hwt=100)</td></tr>
<tr class="separator:aa510a5dd7033e859ab4e6759a1b1b207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca8304d01fccbbac9264eee5d5a24cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9ca8304d01fccbbac9264eee5d5a24cb">sampleGaussian</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, long n, double stdev)</td></tr>
<tr class="memdesc:a9ca8304d01fccbbac9264eee5d5a24cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample polynomials with Gaussian coefficients.  <a href="namespacehelib.html#a9ca8304d01fccbbac9264eee5d5a24cb">More...</a><br /></td></tr>
<tr class="separator:a9ca8304d01fccbbac9264eee5d5a24cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1e9c8e38d8a8f73b315b2cf874cebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6d1e9c8e38d8a8f73b315b2cf874cebe">sampleGaussian</a> (NTL::ZZX &amp;poly, long n, double stdev)</td></tr>
<tr class="separator:a6d1e9c8e38d8a8f73b315b2cf874cebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b922617fd57c98218c1eada9ffb9cb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7b922617fd57c98218c1eada9ffb9cb5">sampleUniform</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, long n, long B=100)</td></tr>
<tr class="memdesc:a7b922617fd57c98218c1eada9ffb9cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a degree-(n-1) ZZX, with coefficients uniform in [-B,B].  <a href="namespacehelib.html#a7b922617fd57c98218c1eada9ffb9cb5">More...</a><br /></td></tr>
<tr class="separator:a7b922617fd57c98218c1eada9ffb9cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2882109801afa606ee6ec39f6fd48348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2882109801afa606ee6ec39f6fd48348">sampleUniform</a> (NTL::ZZX &amp;poly, long n, const NTL::ZZ &amp;B=NTL::ZZ(100L))</td></tr>
<tr class="separator:a2882109801afa606ee6ec39f6fd48348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccfccbd4c008360cc40afa2fa8bc3ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adccfccbd4c008360cc40afa2fa8bc3ad">sampleGaussian</a> (std::vector&lt; double &gt; &amp;dvec, long n, double stdev)</td></tr>
<tr class="memdesc:adccfccbd4c008360cc40afa2fa8bc3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose a vector of continuous Gaussians.  <a href="namespacehelib.html#adccfccbd4c008360cc40afa2fa8bc3ad">More...</a><br /></td></tr>
<tr class="separator:adccfccbd4c008360cc40afa2fa8bc3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97518f36b0358f1f178ce85e51c5d82"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af97518f36b0358f1f178ce85e51c5d82">sampleHWt</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context, long Hwt=100)</td></tr>
<tr class="separator:af97518f36b0358f1f178ce85e51c5d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae703021ed961c9a45e32d09c4b965781"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae703021ed961c9a45e32d09c4b965781">sampleHWtBounded</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context, long Hwt=100)</td></tr>
<tr class="separator:ae703021ed961c9a45e32d09c4b965781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e75ae20952ceae0b4e92034d7128457"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8e75ae20952ceae0b4e92034d7128457">sampleHWtBoundedEffectiveBound</a> (const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context, long Hwt=100)</td></tr>
<tr class="separator:a8e75ae20952ceae0b4e92034d7128457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20a241c380919c47e8375ac01d61187"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa20a241c380919c47e8375ac01d61187">sampleSmall</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:aa20a241c380919c47e8375ac01d61187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50866077cb1daad6200cd8b374613539"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a50866077cb1daad6200cd8b374613539">sampleSmallBounded</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:a50866077cb1daad6200cd8b374613539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8ea79ceef3847786a1f9422fc011e7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1d8ea79ceef3847786a1f9422fc011e7">sampleGaussian</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context, double stdev)</td></tr>
<tr class="separator:a1d8ea79ceef3847786a1f9422fc011e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2cb417d4cb136fe2f25fea08aaff16"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abc2cb417d4cb136fe2f25fea08aaff16">sampleGaussianBounded</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context, double stdev)</td></tr>
<tr class="separator:abc2cb417d4cb136fe2f25fea08aaff16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21875fc9b1d3c8dad59e1c3f66f0718"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa21875fc9b1d3c8dad59e1c3f66f0718">sampleUniform</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context, long B=100)</td></tr>
<tr class="separator:aa21875fc9b1d3c8dad59e1c3f66f0718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c90da3ab82439eb3574afc268f88050"><td class="memItemLeft" align="right" valign="top">NTL::xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5c90da3ab82439eb3574afc268f88050">sampleUniform</a> (NTL::ZZX &amp;poly, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context, const NTL::ZZ &amp;B=NTL::ZZ(100L))</td></tr>
<tr class="separator:a5c90da3ab82439eb3574afc268f88050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afc81441c478d7cd4749a69cbccc984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7afc81441c478d7cd4749a69cbccc984">reduceModPhimX</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;poly, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:a7afc81441c478d7cd4749a69cbccc984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fdf54d28eb816a5a395b7e1e1efe51"><td class="memItemLeft" align="right" valign="top">const NTL::zz_pXModulus &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab0fdf54d28eb816a5a395b7e1e1efe51">getPhimXMod</a> (const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:ab0fdf54d28eb816a5a395b7e1e1efe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c5cbd9691dfde759a98c2d7b48542"><td class="memTemplParams" colspan="2">template&lt;typename TXT &gt; </td></tr>
<tr class="memitem:aa51c5cbd9691dfde759a98c2d7b48542"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa51c5cbd9691dfde759a98c2d7b48542">binSumReduction</a> (std::vector&lt; TXT &gt; &amp;ctxtArray)</td></tr>
<tr class="memdesc:aa51c5cbd9691dfde759a98c2d7b48542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary summation of a vector of elements.  <a href="namespacehelib.html#aa51c5cbd9691dfde759a98c2d7b48542">More...</a><br /></td></tr>
<tr class="separator:aa51c5cbd9691dfde759a98c2d7b48542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11746f6a5bcf33d5667cfaae083f3e35"><td class="memTemplParams" colspan="2">template&lt;typename TXT &gt; </td></tr>
<tr class="memitem:a11746f6a5bcf33d5667cfaae083f3e35"><td class="memTemplItemLeft" align="right" valign="top">TXT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a11746f6a5bcf33d5667cfaae083f3e35">calculateSetIntersection</a> (const TXT &amp;query, const std::vector&lt; NTL::ZZX &gt; &amp;server_set)</td></tr>
<tr class="memdesc:a11746f6a5bcf33d5667cfaae083f3e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two sets, calculates and returns the set intersection.  <a href="namespacehelib.html#a11746f6a5bcf33d5667cfaae083f3e35">More...</a><br /></td></tr>
<tr class="separator:a11746f6a5bcf33d5667cfaae083f3e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13b0418c17fe6b26a2006507d2b57ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa13b0418c17fe6b26a2006507d2b57ac">computeAllProducts</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;products, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;array, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding=nullptr)</td></tr>
<tr class="separator:aa13b0418c17fe6b26a2006507d2b57ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a5ec00207d3ca4206aaa810e04dc5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a57a5ec00207d3ca4206aaa810e04dc5f">tableLookup</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;out, const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;table, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;idx, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding=nullptr)</td></tr>
<tr class="separator:a57a5ec00207d3ca4206aaa810e04dc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c931bc04df2c12ffb4e48ae6eb7b404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5c931bc04df2c12ffb4e48ae6eb7b404">tableWriteIn</a> (const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;table, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;idx, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding=nullptr)</td></tr>
<tr class="separator:a5c931bc04df2c12ffb4e48ae6eb7b404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add048fff3de003ad2b670a9ae3ed6f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#add048fff3de003ad2b670a9ae3ed6f2b">buildLookupTable</a> (std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;T, std::function&lt; double(double)&gt; f, long nbits_in, long scale_in, long sign_in, long nbits_out, long scale_out, long sign_out, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="memdesc:add048fff3de003ad2b670a9ae3ed6f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Built a table-lookup for a function in fixed-point representation.  <a href="namespacehelib.html#add048fff3de003ad2b670a9ae3ed6f2b">More...</a><br /></td></tr>
<tr class="separator:add048fff3de003ad2b670a9ae3ed6f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7957fca02eb250ab71f07ae1e03f4f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7957fca02eb250ab71f07ae1e03f4f5c">registerTimer</a> (<a class="el" href="classhelib_1_1_f_h_etimer.html">FHEtimer</a> *timer)</td></tr>
<tr class="separator:a7957fca02eb250ab71f07ae1e03f4f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d5dae8af9bd253bc591ea37db51a58"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a73d5dae8af9bd253bc591ea37db51a58">GetTimerClock</a> ()</td></tr>
<tr class="separator:a73d5dae8af9bd253bc591ea37db51a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fe94a9675113ebaf52d87806572cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a84fe94a9675113ebaf52d87806572cf8">setTimersOn</a> ()</td></tr>
<tr class="separator:a84fe94a9675113ebaf52d87806572cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4672b8f7cb141fc61055c0ccf5f09e56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4672b8f7cb141fc61055c0ccf5f09e56">setTimersOff</a> ()</td></tr>
<tr class="separator:a4672b8f7cb141fc61055c0ccf5f09e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94c1a39dcabf4a83066a2908a02e274"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad94c1a39dcabf4a83066a2908a02e274">areTimersOn</a> ()</td></tr>
<tr class="separator:ad94c1a39dcabf4a83066a2908a02e274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19aadcc92555c2f4dbb3b3b34ae6633"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhelib_1_1_f_h_etimer.html">FHEtimer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad19aadcc92555c2f4dbb3b3b34ae6633">getTimerByName</a> (const char *name)</td></tr>
<tr class="separator:ad19aadcc92555c2f4dbb3b3b34ae6633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3203575203906fc8b66bef7fe7a577cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3203575203906fc8b66bef7fe7a577cd">resetAllTimers</a> ()</td></tr>
<tr class="separator:a3203575203906fc8b66bef7fe7a577cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a544a973c30afed0df368cda6e0ad9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2a544a973c30afed0df368cda6e0ad9e">printAllTimers</a> (std::ostream &amp;str=std::cerr)</td></tr>
<tr class="memdesc:a2a544a973c30afed0df368cda6e0ad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the value of all timers to stream.  <a href="namespacehelib.html#a2a544a973c30afed0df368cda6e0ad9e">More...</a><br /></td></tr>
<tr class="separator:a2a544a973c30afed0df368cda6e0ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0def7d8004a69413ec72c12f1b2bdfe2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0def7d8004a69413ec72c12f1b2bdfe2">printNamedTimer</a> (std::ostream &amp;str, const char *name)</td></tr>
<tr class="separator:a0def7d8004a69413ec72c12f1b2bdfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85715fb3484281444706eba875bfbe72"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85715fb3484281444706eba875bfbe72"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a85715fb3484281444706eba875bfbe72">zeroValue</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a85715fb3484281444706eba875bfbe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an object <code>x</code> return a zero object of the same type.  <a href="namespacehelib.html#a85715fb3484281444706eba875bfbe72">More...</a><br /></td></tr>
<tr class="separator:a85715fb3484281444706eba875bfbe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a05627840d03ffb2f39269ad6323c7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a25a05627840d03ffb2f39269ad6323c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a25a05627840d03ffb2f39269ad6323c7">zeroValue&lt; Ctxt &gt;</a> (const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;x)</td></tr>
<tr class="memdesc:a25a05627840d03ffb2f39269ad6323c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code> return a zero object of the same type.  <a href="namespacehelib.html#a25a05627840d03ffb2f39269ad6323c7">More...</a><br /></td></tr>
<tr class="separator:a25a05627840d03ffb2f39269ad6323c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fa7c571ab911c358c2a01fcbcf3f11"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af1fa7c571ab911c358c2a01fcbcf3f11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af1fa7c571ab911c358c2a01fcbcf3f11">zeroValue&lt; Ptxt&lt; BGV &gt; &gt;</a> (const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:af1fa7c571ab911c358c2a01fcbcf3f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a>&gt;</code> return a zero object of the same type.  <a href="namespacehelib.html#af1fa7c571ab911c358c2a01fcbcf3f11">More...</a><br /></td></tr>
<tr class="separator:af1fa7c571ab911c358c2a01fcbcf3f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa549403e89c301d7e2e4fa39a07dda0b"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa549403e89c301d7e2e4fa39a07dda0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa549403e89c301d7e2e4fa39a07dda0b">zeroValue&lt; Ptxt&lt; CKKS &gt; &gt;</a> (const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:aa549403e89c301d7e2e4fa39a07dda0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a>&gt;</code> return a zero object of the same type.  <a href="namespacehelib.html#aa549403e89c301d7e2e4fa39a07dda0b">More...</a><br /></td></tr>
<tr class="separator:aa549403e89c301d7e2e4fa39a07dda0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf92545afe42e1f4810b40c9e455af2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adaf92545afe42e1f4810b40c9e455af2">IsZero</a> (const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a)</td></tr>
<tr class="separator:adaf92545afe42e1f4810b40c9e455af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada22455ae91e6bacc49e719536a8c5da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ada22455ae91e6bacc49e719536a8c5da">clear</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a)</td></tr>
<tr class="separator:ada22455ae91e6bacc49e719536a8c5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6406c9fda9c55cde649bc033ad7317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4d6406c9fda9c55cde649bc033ad7317">convert</a> (NTL::zz_pX &amp;x, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a)</td></tr>
<tr class="separator:a4d6406c9fda9c55cde649bc033ad7317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa160e775ba4dcac09cec20c2febb5de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa160e775ba4dcac09cec20c2febb5de2">add</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;res, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;b)</td></tr>
<tr class="separator:aa160e775ba4dcac09cec20c2febb5de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efa98b2b2f5303eee2c106240c17b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0efa98b2b2f5303eee2c106240c17b11">operator+</a> (const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;b)</td></tr>
<tr class="separator:a0efa98b2b2f5303eee2c106240c17b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a8de3a0f340ce6a600fa1da2233191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac1a8de3a0f340ce6a600fa1da2233191">operator+=</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;b)</td></tr>
<tr class="separator:ac1a8de3a0f340ce6a600fa1da2233191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe210bf717f8ba00aca5995fb479593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acbe210bf717f8ba00aca5995fb479593">div</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;res, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, long b)</td></tr>
<tr class="separator:acbe210bf717f8ba00aca5995fb479593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e5cb71e5ab89ad99c81b175ed126cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a70e5cb71e5ab89ad99c81b175ed126cd">operator/</a> (const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, long b)</td></tr>
<tr class="separator:a70e5cb71e5ab89ad99c81b175ed126cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbb01a7d1b26b95c0abff58d28bdb0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7dbb01a7d1b26b95c0abff58d28bdb0e">operator/=</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, long b)</td></tr>
<tr class="separator:a7dbb01a7d1b26b95c0abff58d28bdb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f88c1ce38bfe194b79c6fff9842e3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac8f88c1ce38bfe194b79c6fff9842e3a">mul</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;res, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, long b)</td></tr>
<tr class="separator:ac8f88c1ce38bfe194b79c6fff9842e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426440bf36745c2e46ae9826ca70724c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a426440bf36745c2e46ae9826ca70724c">operator*</a> (const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, long b)</td></tr>
<tr class="separator:a426440bf36745c2e46ae9826ca70724c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2526335487a72bde255cc7a916f9736f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2526335487a72bde255cc7a916f9736f">operator*=</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, long b)</td></tr>
<tr class="separator:a2526335487a72bde255cc7a916f9736f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac285b2405b33a6bf1d27953c5bb89e61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac285b2405b33a6bf1d27953c5bb89e61">normalize</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;f)</td></tr>
<tr class="separator:ac285b2405b33a6bf1d27953c5bb89e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65e2fcd58de0be9a17f875701fec9e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af65e2fcd58de0be9a17f875701fec9e3">MulMod</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;res, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;b, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:af65e2fcd58de0be9a17f875701fec9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f0968146827a1378c640d201604a02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab7f0968146827a1378c640d201604a02">MulMod</a> (const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;b, const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg)</td></tr>
<tr class="separator:ab7f0968146827a1378c640d201604a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1aa9d391c181e780742a2117e9af78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7b1aa9d391c181e780742a2117e9af78">balanced_zzX</a> (const NTL::zz_pX &amp;f)</td></tr>
<tr class="separator:a7b1aa9d391c181e780742a2117e9af78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508dcf9321109128c609e466a3e33181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a508dcf9321109128c609e466a3e33181">balanced_zzX</a> (const NTL::GF2X &amp;f)</td></tr>
<tr class="separator:a508dcf9321109128c609e466a3e33181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19a69725c1500ca956f0a89dd7226e8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa19a69725c1500ca956f0a89dd7226e8">defaultPmiddle</a> (long delta)</td></tr>
<tr class="separator:aa19a69725c1500ca956f0a89dd7226e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae485ed628fe5d0b73b7fc80efcfb36"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7ae485ed628fe5d0b73b7fc80efcfb36">defaultQmiddle</a> (long delta)</td></tr>
<tr class="separator:a7ae485ed628fe5d0b73b7fc80efcfb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec4c5776cc1a48bb6d6a3ae4e64a4b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3ec4c5776cc1a48bb6d6a3ae4e64a4b7">runningSums</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;v)</td></tr>
<tr class="separator:a3ec4c5776cc1a48bb6d6a3ae4e64a4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a682bb0c0c84f0d6eaddde8fd2f8b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa6a682bb0c0c84f0d6eaddde8fd2f8b9">compareTwoNumbersImplementation</a> (<a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;max, <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;min, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;mu, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ni, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;aa, const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;bb, bool twosComplement, std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *unpackSlotEncoding, bool cmp_only)</td></tr>
<tr class="separator:aa6a682bb0c0c84f0d6eaddde8fd2f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f968f2ead15d0f33947d7f1bc165f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a76f968f2ead15d0f33947d7f1bc165f5">BluesteinFFT</a> (NTL::zz_pX &amp;x, long n, UNUSED const NTL::zz_p &amp;root, const NTL::zz_pX &amp;powers, const NTL::Vec&lt; NTL::mulmod_precon_t &gt; &amp;powers_aux, const NTL::fftRep &amp;Rb)</td></tr>
<tr class="separator:a76f968f2ead15d0f33947d7f1bc165f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02b70fdba8bb78c1f19964759f497b5"><td class="memItemLeft" align="right" valign="top">NTL::zz_pContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af02b70fdba8bb78c1f19964759f497b5">BuildContext</a> (long p, long maxroot)</td></tr>
<tr class="separator:af02b70fdba8bb78c1f19964759f497b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8dd31cc08df15a8e5925a06eae00de"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6c8dd31cc08df15a8e5925a06eae00de">operator&lt;&lt;</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:a6c8dd31cc08df15a8e5925a06eae00de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2051c31f2618de7d4cd905020cba5ad4"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2051c31f2618de7d4cd905020cba5ad4">operator&gt;&gt;</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:a2051c31f2618de7d4cd905020cba5ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5711697a702a0f5c4351b3be5644591f"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5711697a702a0f5c4351b3be5644591f">getG</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:a5711697a702a0f5c4351b3be5644591f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac13602434c22102de26465c49856eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aac13602434c22102de26465c49856eeb">addSomePrimes</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;c)</td></tr>
<tr class="separator:aac13602434c22102de26465c49856eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8bfb70b1212c781ee1c510a2f456cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abf8bfb70b1212c781ee1c510a2f456cf">computeIntervalForMul</a> (double &amp;lo, double &amp;hi, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt1, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt2)</td></tr>
<tr class="separator:abf8bfb70b1212c781ee1c510a2f456cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5b39e20fa9f25946cbd4f0064c32a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9e5b39e20fa9f25946cbd4f0064c32a1">computeIntervalForSqr</a> (double &amp;lo, double &amp;hi, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt)</td></tr>
<tr class="separator:a9e5b39e20fa9f25946cbd4f0064c32a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22055624d2a4b9a21d1ff101f7eac03"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae22055624d2a4b9a21d1ff101f7eac03">operator&gt;&gt;</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_s_k_handle.html">SKHandle</a> &amp;handle)</td></tr>
<tr class="separator:ae22055624d2a4b9a21d1ff101f7eac03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e1a9de8dac4a717ec046b76d4d9381"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac6e1a9de8dac4a717ec046b76d4d9381">operator&lt;&lt;</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt)</td></tr>
<tr class="separator:ac6e1a9de8dac4a717ec046b76d4d9381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade316a04cccc9355774eff8e6c013278"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ade316a04cccc9355774eff8e6c013278">operator&gt;&gt;</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt)</td></tr>
<tr class="separator:ade316a04cccc9355774eff8e6c013278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a78ea9ad3d9a0793325a14262965f5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a07a78ea9ad3d9a0793325a14262965f5">log2_realToEstimatedNoise</a> (const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk)</td></tr>
<tr class="separator:a07a78ea9ad3d9a0793325a14262965f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae695d0fc0099e58790b874885c563efd"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae695d0fc0099e58790b874885c563efd">DoubleCRT::Op&lt; DoubleCRT::AddFun &gt;</a> (const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;other, AddFun fun, bool matchIndexSets)</td></tr>
<tr class="separator:ae695d0fc0099e58790b874885c563efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3db7c0c4fd741adba512c54bc7c3ee4"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae3db7c0c4fd741adba512c54bc7c3ee4">DoubleCRT::Op&lt; DoubleCRT::SubFun &gt;</a> (const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;other, SubFun fun, bool matchIndexSets)</td></tr>
<tr class="separator:ae3db7c0c4fd741adba512c54bc7c3ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75ba76e26d04df9d1a9fca73d3a718b"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae75ba76e26d04df9d1a9fca73d3a718b">DoubleCRT::Op&lt; DoubleCRT::MulFun &gt;</a> (const NTL::ZZ &amp;num, MulFun fun)</td></tr>
<tr class="separator:ae75ba76e26d04df9d1a9fca73d3a718b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab878e7e7e17b6d6caf65e7f289965e28"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab878e7e7e17b6d6caf65e7f289965e28">DoubleCRT::Op&lt; DoubleCRT::AddFun &gt;</a> (const NTL::ZZ &amp;num, AddFun fun)</td></tr>
<tr class="separator:ab878e7e7e17b6d6caf65e7f289965e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3891679919f78713c9067c3ae9f9ad0c"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3891679919f78713c9067c3ae9f9ad0c">DoubleCRT::Op&lt; DoubleCRT::SubFun &gt;</a> (const NTL::ZZ &amp;num, SubFun fun)</td></tr>
<tr class="separator:a3891679919f78713c9067c3ae9f9ad0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6290cf4257cb23cf95aa5c354c46e6"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6a6290cf4257cb23cf95aa5c354c46e6">DoubleCRT::Op&lt; DoubleCRT::MulFun &gt;</a> (const NTL::ZZX &amp;poly, MulFun fun)</td></tr>
<tr class="separator:a6a6290cf4257cb23cf95aa5c354c46e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad523a1ce005b9562e1574d19f8ce7936"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad523a1ce005b9562e1574d19f8ce7936">DoubleCRT::Op&lt; DoubleCRT::AddFun &gt;</a> (const NTL::ZZX &amp;poly, AddFun fun)</td></tr>
<tr class="separator:ad523a1ce005b9562e1574d19f8ce7936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcba19e19a8aae778a080d8a4833f2d1"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adcba19e19a8aae778a080d8a4833f2d1">DoubleCRT::Op&lt; DoubleCRT::SubFun &gt;</a> (const NTL::ZZX &amp;poly, SubFun fun)</td></tr>
<tr class="separator:adcba19e19a8aae778a080d8a4833f2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05fd6e657aa88416b97a48fb5112d8a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad05fd6e657aa88416b97a48fb5112d8a">operator&lt;&lt;</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;d)</td></tr>
<tr class="separator:ad05fd6e657aa88416b97a48fb5112d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ebb5536c5ee682d8490d2eac03f6ef"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab5ebb5536c5ee682d8490d2eac03f6ef">operator&gt;&gt;</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;d)</td></tr>
<tr class="separator:ab5ebb5536c5ee682d8490d2eac03f6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72790276847439369c96063c3cdc803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af72790276847439369c96063c3cdc803">totalSums</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt)</td></tr>
<tr class="separator:af72790276847439369c96063c3cdc803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583abeb8ab8021559fb519621b42c3d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a583abeb8ab8021559fb519621b42c3d7">applyLinPoly1</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const std::vector&lt; NTL::ZZX &gt; &amp;C)</td></tr>
<tr class="separator:a583abeb8ab8021559fb519621b42c3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e520a1528ee0d150a9818c7ddc4850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa8e520a1528ee0d150a9818c7ddc4850">applyLinPolyMany</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const std::vector&lt; std::vector&lt; NTL::ZZX &gt;&gt; &amp;Cvec)</td></tr>
<tr class="separator:aa8e520a1528ee0d150a9818c7ddc4850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21457a6ed2a6de2701b394bfcc90be1e"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a21457a6ed2a6de2701b394bfcc90be1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a21457a6ed2a6de2701b394bfcc90be1e">applyLinPolyLL</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const std::vector&lt; P &gt; &amp;encodedC, long d)</td></tr>
<tr class="separator:a21457a6ed2a6de2701b394bfcc90be1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc9fd386812fdc5f5067522dc4ceced"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0bc9fd386812fdc5f5067522dc4ceced">applyLinPolyLL</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;encodedC, long d)</td></tr>
<tr class="separator:a0bc9fd386812fdc5f5067522dc4ceced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896039fe9d2b2bda45cf62d278e52a5f"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a896039fe9d2b2bda45cf62d278e52a5f">applyLinPolyLL</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const std::vector&lt; NTL::ZZX &gt; &amp;encodedC, long d)</td></tr>
<tr class="separator:a896039fe9d2b2bda45cf62d278e52a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6f5e7fb2a932db709cbb632e644a81"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9f6f5e7fb2a932db709cbb632e644a81">applyLinPolyLL</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, const std::vector&lt; <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &gt; &amp;encodedC, long d)</td></tr>
<tr class="separator:a9f6f5e7fb2a932db709cbb632e644a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdc2438d837bb24ddb0dc0ba0a859cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8bdc2438d837bb24ddb0dc0ba0a859cc">print</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, std::ostream &amp;s, const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;pa)</td></tr>
<tr class="separator:a8bdc2438d837bb24ddb0dc0ba0a859cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0fb010c5631535fe448caabc974860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4d0fb010c5631535fe448caabc974860">mapTo01</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt)</td></tr>
<tr class="separator:a4d0fb010c5631535fe448caabc974860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f9aef0e58c5e559789b25355c64717"><td class="memTemplParams" colspan="2">template&lt;typename Scheme &gt; </td></tr>
<tr class="memitem:a80f9aef0e58c5e559789b25355c64717"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a80f9aef0e58c5e559789b25355c64717">mapTo01</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;ptxt)</td></tr>
<tr class="separator:a80f9aef0e58c5e559789b25355c64717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec750de20965b96fdc12370f8222f15"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6ec750de20965b96fdc12370f8222f15">mapTo01</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:a6ec750de20965b96fdc12370f8222f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e150be3c72dc211544b82bd1250376"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab7e150be3c72dc211544b82bd1250376">mapTo01</a> (const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:ab7e150be3c72dc211544b82bd1250376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028abbe1151a190d5f4ff23bd3a29c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a028abbe1151a190d5f4ff23bd3a29c3a">fastPower</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, long d)</td></tr>
<tr class="separator:a028abbe1151a190d5f4ff23bd3a29c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42c58780be6927575c8548d842f47b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab42c58780be6927575c8548d842f47b9">incrementalZeroTest</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> *res[], const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, long n)</td></tr>
<tr class="separator:ab42c58780be6927575c8548d842f47b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5bff694c1cfdb4a55a02f01aa27ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9d5bff694c1cfdb4a55a02f01aa27ce7">RelaxedInv</a> (NTL::Mat&lt; NTL::zz_p &gt; &amp;x, const NTL::Mat&lt; NTL::zz_p &gt; &amp;a)</td></tr>
<tr class="separator:a9d5bff694c1cfdb4a55a02f01aa27ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99839e8493aba44c6de4085217a4edc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a99839e8493aba44c6de4085217a4edc6">RelaxedInv</a> (NTL::Mat&lt; NTL::GF2 &gt; &amp;x, const NTL::Mat&lt; NTL::GF2 &gt; &amp;a)</td></tr>
<tr class="separator:a99839e8493aba44c6de4085217a4edc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445beffa0d612929f2237315b80d494b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a445beffa0d612929f2237315b80d494b">TraceMap</a> (NTL::GF2X &amp;w, const NTL::GF2X &amp;a, long d, const NTL::GF2XModulus &amp;F, const NTL::GF2X &amp;b)</td></tr>
<tr class="separator:a445beffa0d612929f2237315b80d494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24ba24d435ed51afa0737dddfc01bb2"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad24ba24d435ed51afa0737dddfc01bb2">getHyperColumn</a> (NTL::Vec&lt; long &gt; &amp;v, const <a class="el" href="classhelib_1_1_const_cube_slice.html">ConstCubeSlice</a>&lt; long &gt; &amp;s, long pos)</td></tr>
<tr class="separator:ad24ba24d435ed51afa0737dddfc01bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd8aedd768d6294cf41cd0c32b48b7d"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adcd8aedd768d6294cf41cd0c32b48b7d">setHyperColumn</a> (const NTL::Vec&lt; long &gt; &amp;v, const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; long &gt; &amp;s, long pos)</td></tr>
<tr class="separator:adcd8aedd768d6294cf41cd0c32b48b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5926b1368764799c58fbbedb10704593"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5926b1368764799c58fbbedb10704593">setHyperColumn</a> (const NTL::Vec&lt; long &gt; &amp;v, const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; long &gt; &amp;s, long pos, const long &amp;val)</td></tr>
<tr class="separator:a5926b1368764799c58fbbedb10704593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f4cdaad8d1b3eba56f013ad96e0d49"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a90f4cdaad8d1b3eba56f013ad96e0d49">print3D</a> (const <a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; long &gt; &amp;c)</td></tr>
<tr class="separator:a90f4cdaad8d1b3eba56f013ad96e0d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb40b60558125630cb15e09a63906c2e"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adb40b60558125630cb15e09a63906c2e">getHyperColumn</a> (NTL::Vec&lt; NTL::zz_p &gt; &amp;v, const <a class="el" href="classhelib_1_1_const_cube_slice.html">ConstCubeSlice</a>&lt; NTL::zz_p &gt; &amp;s, long pos)</td></tr>
<tr class="separator:adb40b60558125630cb15e09a63906c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3f2a2d4e46f0069338139732ca4113"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ada3f2a2d4e46f0069338139732ca4113">setHyperColumn</a> (const NTL::Vec&lt; NTL::zz_p &gt; &amp;v, const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; NTL::zz_p &gt; &amp;s, long pos)</td></tr>
<tr class="separator:ada3f2a2d4e46f0069338139732ca4113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90fa0fa3007a94813b26131c7ae3a1d"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab90fa0fa3007a94813b26131c7ae3a1d">setHyperColumn</a> (const NTL::Vec&lt; NTL::zz_p &gt; &amp;v, const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; NTL::zz_p &gt; &amp;s, long pos, const NTL::zz_p &amp;val)</td></tr>
<tr class="separator:ab90fa0fa3007a94813b26131c7ae3a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518fab30f484391dbbc23fa0ddfdc2bf"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a518fab30f484391dbbc23fa0ddfdc2bf">print3D</a> (const <a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; NTL::zz_p &gt; &amp;c)</td></tr>
<tr class="separator:a518fab30f484391dbbc23fa0ddfdc2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794976b9b52689a77c7895c58ffd65da"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a794976b9b52689a77c7895c58ffd65da">operator&lt;&lt;</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_pub_key.html">PubKey</a> &amp;pk)</td></tr>
<tr class="separator:a794976b9b52689a77c7895c58ffd65da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c53db90234d3f191cf4887f2bb8c2c"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a97c53db90234d3f191cf4887f2bb8c2c">operator&gt;&gt;</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_pub_key.html">PubKey</a> &amp;pk)</td></tr>
<tr class="separator:a97c53db90234d3f191cf4887f2bb8c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1777b65a3298c49a20e8554bc70a2cd1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1777b65a3298c49a20e8554bc70a2cd1">operator&lt;&lt;</a> (std::ostream &amp;str, const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk)</td></tr>
<tr class="separator:a1777b65a3298c49a20e8554bc70a2cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658c0331d08e78e757984e06107f75f0"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a658c0331d08e78e757984e06107f75f0">operator&gt;&gt;</a> (std::istream &amp;str, <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sk)</td></tr>
<tr class="separator:a658c0331d08e78e757984e06107f75f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da295dc142953405e0a3e30509df973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8da295dc142953405e0a3e30509df973">printFlow</a> (<a class="el" href="namespacehelib.html#af547f7016fc73b7174a2018ea28ef298">FlowGraph</a> &amp;fg)</td></tr>
<tr class="separator:a8da295dc142953405e0a3e30509df973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acbf567c5271c1d20df20c6f4fa1714"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhelib_1_1_general_automorph_precon.html">GeneralAutomorphPrecon</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7acbf567c5271c1d20df20c6f4fa1714">buildGeneralAutomorphPrecon</a> (const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, long dim, const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;ea)</td></tr>
<tr class="separator:a7acbf567c5271c1d20df20c6f4fa1714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5435c81f125b4a3b2fddf126601aed2"><td class="memTemplParams" colspan="2">template&lt;typename RX &gt; </td></tr>
<tr class="memitem:ae5435c81f125b4a3b2fddf126601aed2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structhelib_1_1_const_multiplier.html">ConstMultiplier</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae5435c81f125b4a3b2fddf126601aed2">build_ConstMultiplier</a> (const RX &amp;poly)</td></tr>
<tr class="separator:ae5435c81f125b4a3b2fddf126601aed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b18eda7cc825761797b906e47f9074"><td class="memTemplParams" colspan="2">template&lt;typename RX , typename type &gt; </td></tr>
<tr class="memitem:a34b18eda7cc825761797b906e47f9074"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structhelib_1_1_const_multiplier.html">ConstMultiplier</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a34b18eda7cc825761797b906e47f9074">build_ConstMultiplier</a> (const RX &amp;poly, long dim, long amt, const <a class="el" href="classhelib_1_1_encrypted_array_derived.html">EncryptedArrayDerived</a>&lt; type &gt; &amp;ea)</td></tr>
<tr class="separator:a34b18eda7cc825761797b906e47f9074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408eff115fb052630554303601257388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a408eff115fb052630554303601257388">MulAdd</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;x, const std::shared_ptr&lt; <a class="el" href="structhelib_1_1_const_multiplier.html">ConstMultiplier</a> &gt; &amp;a, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;b)</td></tr>
<tr class="separator:a408eff115fb052630554303601257388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b78436c866a0477b9b2957a50bb119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a90b78436c866a0477b9b2957a50bb119">DestMulAdd</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;x, const std::shared_ptr&lt; <a class="el" href="structhelib_1_1_const_multiplier.html">ConstMultiplier</a> &gt; &amp;a, <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;b)</td></tr>
<tr class="separator:a90b78436c866a0477b9b2957a50bb119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac405b201e920430c5995a7408e08e99d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac405b201e920430c5995a7408e08e99d">plaintextAutomorph_CKKS</a> (<a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;b, const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;a, long j, const <a class="el" href="classhelib_1_1_encrypted_array_cx.html">EncryptedArrayCx</a> &amp;ea)</td></tr>
<tr class="separator:ac405b201e920430c5995a7408e08e99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78c4e23cc87c6109c26c3cf86fd1dd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac78c4e23cc87c6109c26c3cf86fd1dd0">GenBabySteps</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&gt; &amp;v, const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, long dim, bool clean)</td></tr>
<tr class="separator:ac78c4e23cc87c6109c26c3cf86fd1dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf094f13d09fba535a0ac173449843f"><td class="memTemplParams" colspan="2">template&lt;typename zp , typename zz &gt; </td></tr>
<tr class="memitem:adcf094f13d09fba535a0ac173449843f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adcf094f13d09fba535a0ac173449843f">FindPrimRootT</a> (zp &amp;root, unsigned long e)</td></tr>
<tr class="separator:adcf094f13d09fba535a0ac173449843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dae2334b1ae6358865ee8fd0c6a8fc6"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0dae2334b1ae6358865ee8fd0c6a8fc6">intVecCRT</a> (NTL::vec_ZZ &amp;, const NTL::ZZ &amp;, const NTL::vec_ZZ &amp;, long)</td></tr>
<tr class="separator:a0dae2334b1ae6358865ee8fd0c6a8fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3781935233076f4d0110d4c7a358ccf"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae3781935233076f4d0110d4c7a358ccf">intVecCRT</a> (NTL::vec_ZZ &amp;, const NTL::ZZ &amp;, const NTL::vec_long &amp;, long)</td></tr>
<tr class="separator:ae3781935233076f4d0110d4c7a358ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c41ad906b8626fb07781c8927102b4f"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2c41ad906b8626fb07781c8927102b4f">intVecCRT</a> (NTL::vec_ZZ &amp;, const NTL::ZZ &amp;, const NTL::Vec&lt; NTL::zz_p &gt; &amp;, long)</td></tr>
<tr class="separator:a2c41ad906b8626fb07781c8927102b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048eb699c3e26a99ac2198bcc984ac75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a048eb699c3e26a99ac2198bcc984ac75">removeDups</a> (std::list&lt; long &gt; &amp;x, bool *aux)</td></tr>
<tr class="separator:a048eb699c3e26a99ac2198bcc984ac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcb58c007d8e3cb2a1b4c7d0c162895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6bcb58c007d8e3cb2a1b4c7d0c162895">addOffset</a> (std::list&lt; long &gt; &amp;x, long offset, long n, bool *aux, UNUSED bool good=false)</td></tr>
<tr class="separator:a6bcb58c007d8e3cb2a1b4c7d0c162895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4662264ee1fcd34eb7ff13d6bbf008"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8e4662264ee1fcd34eb7ff13d6bbf008">reducedCount</a> (const std::list&lt; long &gt; &amp;x, long n, bool *aux)</td></tr>
<tr class="separator:a8e4662264ee1fcd34eb7ff13d6bbf008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7534536bd1101ec60aa4c8fe1ccdf30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa7534536bd1101ec60aa4c8fe1ccdf30">buildBenesCostTable</a> (long n, long k, bool good, NTL::Vec&lt; NTL::Vec&lt; long &gt;&gt; &amp;tab)</td></tr>
<tr class="separator:aa7534536bd1101ec60aa4c8fe1ccdf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1924de36f81ef4338bb2526dd03bfe97"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1924de36f81ef4338bb2526dd03bfe97">operator&lt;&lt;</a> (std::ostream &amp;s, LongNodePtr p)</td></tr>
<tr class="separator:a1924de36f81ef4338bb2526dd03bfe97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188c595f95739f28a8eaffd5fcc55ffd"><td class="memItemLeft" align="right" valign="top">BenesMemoEntry&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a188c595f95739f28a8eaffd5fcc55ffd">optimalBenesAux</a> (long i, long budget, long nlev, const NTL::Vec&lt; NTL::Vec&lt; long &gt;&gt; &amp;costTab, BenesMemoTable &amp;memoTab)</td></tr>
<tr class="separator:a188c595f95739f28a8eaffd5fcc55ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80751b68918a0cba13cb9bab3da12ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab80751b68918a0cba13cb9bab3da12ed">optimalBenes</a> (long n, long budget, bool good, long &amp;cost, LongNodePtr &amp;solution)</td></tr>
<tr class="separator:ab80751b68918a0cba13cb9bab3da12ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b924cfad7a9d34755b6175d88a6a207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7b924cfad7a9d34755b6175d88a6a207">print</a> (std::ostream &amp;s, SplitNodePtr p, bool first)</td></tr>
<tr class="separator:a7b924cfad7a9d34755b6175d88a6a207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8407900faf89358e471aef0bdb902da8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8407900faf89358e471aef0bdb902da8">operator&lt;&lt;</a> (std::ostream &amp;s, SplitNodePtr p)</td></tr>
<tr class="separator:a8407900faf89358e471aef0bdb902da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bd3c856c7b75630a3fee625848debf"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac5bd3c856c7b75630a3fee625848debf">length</a> (GenNodePtr ptr)</td></tr>
<tr class="separator:ac5bd3c856c7b75630a3fee625848debf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd38c901ef879aa74f5070cdd2b38790"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acd38c901ef879aa74f5070cdd2b38790">operator&lt;&lt;</a> (std::ostream &amp;s, GenNodePtr p)</td></tr>
<tr class="separator:acd38c901ef879aa74f5070cdd2b38790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a4b7e9cb04f6760740db3d4dc3186d"><td class="memItemLeft" align="right" valign="top">LowerMemoEntry&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a05a4b7e9cb04f6760740db3d4dc3186d">optimalLower</a> (long order, bool good, long budget, long mid, LowerMemoTable &amp;lowerMemoTable)</td></tr>
<tr class="separator:a05a4b7e9cb04f6760740db3d4dc3186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9b2fbc501abb90f6400679ee15f9aa"><td class="memItemLeft" align="right" valign="top">UpperMemoEntry&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6b9b2fbc501abb90f6400679ee15f9aa">optimalUpperAux</a> (const NTL::Vec&lt; <a class="el" href="classhelib_1_1_gen_descriptor.html">GenDescriptor</a> &gt; &amp;vec, long i, long budget, long mid, UpperMemoTable &amp;upperMemoTable, LowerMemoTable &amp;lowerMemoTable)</td></tr>
<tr class="separator:a6b9b2fbc501abb90f6400679ee15f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77a93b123ead6eef9e6c899afab897c"><td class="memTemplParams" colspan="2">template&lt;typename RX &gt; </td></tr>
<tr class="memitem:ab77a93b123ead6eef9e6c899afab897c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ab77a93b123ead6eef9e6c899afab897c">poly_comp</a> (const RX &amp;a, const RX &amp;b)</td></tr>
<tr class="separator:ab77a93b123ead6eef9e6c899afab897c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0780cab8a4fd2f230bfcc1822814cf06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0780cab8a4fd2f230bfcc1822814cf06">less_than</a> (NTL::GF2 a, NTL::GF2 b)</td></tr>
<tr class="separator:a0780cab8a4fd2f230bfcc1822814cf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507149d174b7d75b1db57d876791fa93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a507149d174b7d75b1db57d876791fa93">less_than</a> (NTL::zz_p a, NTL::zz_p b)</td></tr>
<tr class="separator:a507149d174b7d75b1db57d876791fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba849e54a054c14527a708b0738735d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acba849e54a054c14527a708b0738735d">less_than</a> (const NTL::GF2X &amp;a, const NTL::GF2X &amp;b)</td></tr>
<tr class="separator:acba849e54a054c14527a708b0738735d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da437fc5e5b62183567bd8885b5b086"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6da437fc5e5b62183567bd8885b5b086">less_than</a> (const NTL::zz_pX &amp;a, const NTL::zz_pX &amp;b)</td></tr>
<tr class="separator:a6da437fc5e5b62183567bd8885b5b086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592d23357f47db9beb431daa00b1837b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a592d23357f47db9beb431daa00b1837b">less_than</a> (const NTL::GF2E &amp;a, const NTL::GF2E &amp;b)</td></tr>
<tr class="separator:a592d23357f47db9beb431daa00b1837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade745be425656ca6550b68e91647df4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ade745be425656ca6550b68e91647df4d">less_than</a> (const NTL::zz_pE &amp;a, const NTL::zz_pE &amp;b)</td></tr>
<tr class="separator:ade745be425656ca6550b68e91647df4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a95ea63e91091bd7cae299abf5b60e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3a95ea63e91091bd7cae299abf5b60e9">less_than</a> (const NTL::GF2EX &amp;a, const NTL::GF2EX &amp;b)</td></tr>
<tr class="separator:a3a95ea63e91091bd7cae299abf5b60e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58072d3099fe887b7de62dba4b16a337"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a58072d3099fe887b7de62dba4b16a337">less_than</a> (const NTL::zz_pEX &amp;a, const NTL::zz_pEX &amp;b)</td></tr>
<tr class="separator:a58072d3099fe887b7de62dba4b16a337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad733002556086f79ab0153f09916d2be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad733002556086f79ab0153f09916d2be">comparePAlgebra</a> (const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;palg, unsigned long m, unsigned long p, UNUSED unsigned long r, const std::vector&lt; long &gt; &amp;gens, const std::vector&lt; long &gt; &amp;ords)</td></tr>
<tr class="separator:ad733002556086f79ab0153f09916d2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac531d997cd86bd46ac62c3f7cd5665de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac531d997cd86bd46ac62c3f7cd5665de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac531d997cd86bd46ac62c3f7cd5665de">PAlgebraLift</a> (const NTL::ZZX &amp;phimx, const T &amp;lfactors, T &amp;factors, T &amp;crtc, long r)</td></tr>
<tr class="separator:ac531d997cd86bd46ac62c3f7cd5665de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc33dc76f8abeaf3557b98dd5a400922"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abc33dc76f8abeaf3557b98dd5a400922">EDF</a> (NTL::vec_zz_pX &amp;v, const NTL::zz_pX &amp;f, long d)</td></tr>
<tr class="separator:abc33dc76f8abeaf3557b98dd5a400922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0741932e68cabac1a19a68d0a4810bf"><td class="memItemLeft" align="right" valign="top">NTL::zz_pEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad0741932e68cabac1a19a68d0a4810bf">FrobeniusMap</a> (const NTL::zz_pEXModulus &amp;F)</td></tr>
<tr class="separator:ad0741932e68cabac1a19a68d0a4810bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cac9469e49eec3d2bcd9db31e0122f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7cac9469e49eec3d2bcd9db31e0122f1">InvModpr</a> (NTL::zz_pX &amp;S, const NTL::zz_pX &amp;F, const NTL::zz_pX &amp;G, long p, long r)</td></tr>
<tr class="separator:a7cac9469e49eec3d2bcd9db31e0122f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c4516b395810588dc11afabdd11b62"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa4c4516b395810588dc11afabdd11b62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa4c4516b395810588dc11afabdd11b62">PAlgebraLift</a> (const NTL::ZZX &amp;phimx, const NTL::vec_zz_pX &amp;lfactors, NTL::vec_zz_pX &amp;factors, NTL::vec_zz_pX &amp;crtc, long r)</td></tr>
<tr class="separator:aa4c4516b395810588dc11afabdd11b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16380874c94bf4781b228d986d9882ca"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a16380874c94bf4781b228d986d9882ca">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_perm_network.html">PermNetwork</a> &amp;net)</td></tr>
<tr class="separator:a16380874c94bf4781b228d986d9882ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a1417dec7a02c2dc600a3802cb3102"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a81a1417dec7a02c2dc600a3802cb3102">applyPermToVec&lt; long &gt;</a> (NTL::Vec&lt; long &gt; &amp;out, const NTL::Vec&lt; long &gt; &amp;in, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p1)</td></tr>
<tr class="separator:a81a1417dec7a02c2dc600a3802cb3102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331891be147b33a730e697f3d9e9bc92"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a331891be147b33a730e697f3d9e9bc92">applyPermToVec&lt; long &gt;</a> (std::vector&lt; long &gt; &amp;out, const std::vector&lt; long &gt; &amp;in, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p1)</td></tr>
<tr class="separator:a331891be147b33a730e697f3d9e9bc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1608eb4840762727e4733e2c63b8bb"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aff1608eb4840762727e4733e2c63b8bb">applyPermToVec&lt; NTL::ZZX &gt;</a> (std::vector&lt; NTL::ZZX &gt; &amp;out, const std::vector&lt; NTL::ZZX &gt; &amp;in, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p1)</td></tr>
<tr class="separator:aff1608eb4840762727e4733e2c63b8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7675aa123a573bc6d687c1421f2308"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abe7675aa123a573bc6d687c1421f2308">applyPermsToVec&lt; long &gt;</a> (NTL::Vec&lt; long &gt; &amp;out, const NTL::Vec&lt; long &gt; &amp;in, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p2, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p1)</td></tr>
<tr class="separator:abe7675aa123a573bc6d687c1421f2308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4a600c33f24c48a5074b19d9db9d24"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acc4a600c33f24c48a5074b19d9db9d24">applyPermsToVec&lt; long &gt;</a> (std::vector&lt; long &gt; &amp;out, const std::vector&lt; long &gt; &amp;in, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p2, const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;p1)</td></tr>
<tr class="separator:acc4a600c33f24c48a5074b19d9db9d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060e401ccfa17753d928fb1812fa020f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a060e401ccfa17753d928fb1812fa020f">breakPermTo3</a> (const <a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; long &gt; &amp;pi, long dim, <a class="el" href="classhelib_1_1_col_perm.html">ColPerm</a> &amp;rho1, <a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; long &gt; &amp;rho2, <a class="el" href="classhelib_1_1_col_perm.html">ColPerm</a> &amp;rho3)</td></tr>
<tr class="separator:a060e401ccfa17753d928fb1812fa020f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c49d134949a4cf5cc7ef6c0ffa1206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af1c49d134949a4cf5cc7ef6c0ffa1206">ComputeOneGenMapping</a> (<a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;genMap, const <a class="el" href="namespacehelib.html#a22b83b7df1af539c07c804d7888448ce">OneGeneratorTree</a> &amp;T)</td></tr>
<tr class="memdesc:af1c49d134949a4cf5cc7ef6c0ffa1206"><td class="mdescLeft">&#160;</td><td class="mdescRight">to a single generator tree  <a href="namespacehelib.html#af1c49d134949a4cf5cc7ef6c0ffa1206">More...</a><br /></td></tr>
<tr class="separator:af1c49d134949a4cf5cc7ef6c0ffa1206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8794be0244c26078eabc3c5343c86897"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8794be0244c26078eabc3c5343c86897">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_sub_dimension.html">SubDimension</a> &amp;sd)</td></tr>
<tr class="separator:a8794be0244c26078eabc3c5343c86897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548b26739f763a0bb78c6ca1eec1a3d4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a548b26739f763a0bb78c6ca1eec1a3d4">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_generator_trees.html">GeneratorTrees</a> &amp;trees)</td></tr>
<tr class="separator:a548b26739f763a0bb78c6ca1eec1a3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511bb2a1c3583d18b858d5362489139c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a511bb2a1c3583d18b858d5362489139c">deserialize</a> (std::istream &amp;is, <a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a> &amp;poly)</td></tr>
<tr class="separator:a511bb2a1c3583d18b858d5362489139c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1784c6548249c484976efcf52a0416d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1784c6548249c484976efcf52a0416d7">serialize</a> (std::ostream &amp;os, const <a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a> &amp;poly)</td></tr>
<tr class="separator:a1784c6548249c484976efcf52a0416d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5af20ad95e41b4f1d072aef127abe8"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3a5af20ad95e41b4f1d072aef127abe8">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a> &amp;poly)</td></tr>
<tr class="separator:a3a5af20ad95e41b4f1d072aef127abe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e75bdb938a5f96094db55ea323250d2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8e75bdb938a5f96094db55ea323250d2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a> &amp;poly)</td></tr>
<tr class="separator:a8e75bdb938a5f96094db55ea323250d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cf6e939823e9a136817850ea93c1cb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a56cf6e939823e9a136817850ea93c1cb">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structhelib_1_1_poly_mod_ring.html">PolyModRing</a> &amp;ring)</td></tr>
<tr class="separator:a56cf6e939823e9a136817850ea93c1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db58bd9f9ec928c07dc95b2bd2aa26b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5db58bd9f9ec928c07dc95b2bd2aa26b">computeDivVec</a> (NTL::Vec&lt; long &gt; &amp;divVec, long m, const NTL::Vec&lt; long &gt; &amp;powVec)</td></tr>
<tr class="separator:a5db58bd9f9ec928c07dc95b2bd2aa26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdc9f121e0356fcc0c2d469126da20c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aacdc9f121e0356fcc0c2d469126da20c">computeInvVec</a> (NTL::Vec&lt; long &gt; &amp;invVec, const NTL::Vec&lt; long &gt; &amp;divVec, const NTL::Vec&lt; long &gt; &amp;powVec)</td></tr>
<tr class="separator:aacdc9f121e0356fcc0c2d469126da20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf366cbdad4242e525976c1f8664a3fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#abf366cbdad4242e525976c1f8664a3fc">operator&gt;</a> (const <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;a, const <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;b)</td></tr>
<tr class="separator:abf366cbdad4242e525976c1f8664a3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba72e7396d96094a33df27ad8d11d5d0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aba72e7396d96094a33df27ad8d11d5d0">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classhelib_1_1_moduli_sizes.html">ModuliSizes</a> &amp;szs)</td></tr>
<tr class="separator:aba72e7396d96094a33df27ad8d11d5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6655763e3378a03fc07dca9178ec44"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2d6655763e3378a03fc07dca9178ec44">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classhelib_1_1_moduli_sizes.html">ModuliSizes</a> &amp;szs)</td></tr>
<tr class="separator:a2d6655763e3378a03fc07dca9178ec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcac17a647635226217c42d858bc155d"><td class="memTemplParams" colspan="2">template&lt;typename Scheme &gt; </td></tr>
<tr class="memitem:afcac17a647635226217c42d858bc155d"><td class="memTemplItemLeft" align="right" valign="top">Scheme::SlotType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#afcac17a647635226217c42d858bc155d">randomSlot</a> (const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:afcac17a647635226217c42d858bc155d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcaec251bd8b00a025d3868342fbe85"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aebcaec251bd8b00a025d3868342fbe85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhelib_1_1_b_g_v.html#a09c79ac9a958d2d2b93c34d89c3ca65b">BGV::SlotType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aebcaec251bd8b00a025d3868342fbe85">randomSlot&lt; BGV &gt;</a> (const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:aebcaec251bd8b00a025d3868342fbe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48baf3cc1410cb87bf86a9065dee38a9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a48baf3cc1410cb87bf86a9065dee38a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhelib_1_1_c_k_k_s.html#a7c8b6e96117c89f9395b2f1ccdc1e0a0">CKKS::SlotType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a48baf3cc1410cb87bf86a9065dee38a9">randomSlot&lt; CKKS &gt;</a> (UNUSED const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;context)</td></tr>
<tr class="separator:a48baf3cc1410cb87bf86a9065dee38a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7935d14fb3f04f52a685e6655d12e613"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7935d14fb3f04f52a685e6655d12e613">deserialize&lt; BGV &gt;</a> (std::istream &amp;is, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:a7935d14fb3f04f52a685e6655d12e613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0989e95794866905149bd8defaa3f8"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0f0989e95794866905149bd8defaa3f8">deserialize&lt; CKKS &gt;</a> (std::istream &amp;is, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:a0f0989e95794866905149bd8defaa3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f0ba91399ca673009e2d72a2c5db8f"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad6f0ba91399ca673009e2d72a2c5db8f">serialize&lt; BGV &gt;</a> (std::ostream &amp;os, const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:ad6f0ba91399ca673009e2d72a2c5db8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acb5806f04e3ec63ebef2f1b64fac03"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3acb5806f04e3ec63ebef2f1b64fac03">serialize&lt; CKKS &gt;</a> (std::ostream &amp;os, const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:a3acb5806f04e3ec63ebef2f1b64fac03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12538d07e5bfd87d5705821d3a6fd72d"><td class="memItemLeft" align="right" valign="top">template std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a12538d07e5bfd87d5705821d3a6fd72d">operator&gt;&gt;&lt;BGV &gt;</a> (std::istream &amp;is, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:a12538d07e5bfd87d5705821d3a6fd72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26590bae1e4d74412c28dd3abbb24b72"><td class="memItemLeft" align="right" valign="top">template std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a26590bae1e4d74412c28dd3abbb24b72">operator&gt;&gt;&lt;CKKS &gt;</a> (std::istream &amp;is, <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:a26590bae1e4d74412c28dd3abbb24b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb431149ad4752359e90a9559196b71b"><td class="memItemLeft" align="right" valign="top">template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aeb431149ad4752359e90a9559196b71b">operator&lt;&lt;&lt;BGV &gt;</a> (std::ostream &amp;os, const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:aeb431149ad4752359e90a9559196b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69b9423e994641a90a8401f74631180"><td class="memItemLeft" align="right" valign="top">template std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af69b9423e994641a90a8401f74631180">operator&lt;&lt;&lt;CKKS &gt;</a> (std::ostream &amp;os, const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;ptxt)</td></tr>
<tr class="separator:af69b9423e994641a90a8401f74631180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a30217f5c0a87bea091193f7dddddc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4a30217f5c0a87bea091193f7dddddc4">extractDigitsPacked</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, long botHigh, long r, long ePrime, const std::vector&lt; NTL::ZZX &gt; &amp;unpackSlotEncoding)</td></tr>
<tr class="separator:a4a30217f5c0a87bea091193f7dddddc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b1296539466b880a55d12ea9ac6864"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac2b1296539466b880a55d12ea9ac6864">extractDigitsThin</a> (<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;ctxt, long botHigh, long r, long ePrime)</td></tr>
<tr class="separator:ac2b1296539466b880a55d12ea9ac6864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4cfecd6dc28011302b7b86d15dbaa9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5c4cfecd6dc28011302b7b86d15dbaa9">boundRoundingNoise</a> (UNUSED long m, long phim, long p2r, double epsilon)</td></tr>
<tr class="separator:a5c4cfecd6dc28011302b7b86d15dbaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50b24ebf9fb1d59089cf974eee2ac90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa50b24ebf9fb1d59089cf974eee2ac90">timer_compare</a> (const <a class="el" href="classhelib_1_1_f_h_etimer.html">FHEtimer</a> *a, const <a class="el" href="classhelib_1_1_f_h_etimer.html">FHEtimer</a> *b)</td></tr>
<tr class="separator:aa50b24ebf9fb1d59089cf974eee2ac90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3ba322251033959f95b296f34745836e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_context.html">Context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3ba322251033959f95b296f34745836e">activeContext</a> = nullptr</td></tr>
<tr class="separator:a3ba322251033959f95b296f34745836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7d15973181b665a33077ca529f9d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0d7d15973181b665a33077ca529f9d47">dbgKey</a> = nullptr</td></tr>
<tr class="separator:a0d7d15973181b665a33077ca529f9d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2eab09fe947de2ae6eb8328937f0bb"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1f2eab09fe947de2ae6eb8328937f0bb">dbgEa</a> = nullptr</td></tr>
<tr class="separator:a1f2eab09fe947de2ae6eb8328937f0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11275c94e69653c6ca1c5b3ea8f85dba"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a11275c94e69653c6ca1c5b3ea8f85dba">dbg_ptxt</a></td></tr>
<tr class="separator:a11275c94e69653c6ca1c5b3ea8f85dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b6a65490d657b3d2b631fb1fe423e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a43b6a65490d657b3d2b631fb1fe423e8">fhe_stats</a> = false</td></tr>
<tr class="separator:a43b6a65490d657b3d2b631fb1fe423e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d675d13f2fdad48c20753cbf9a611d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhelib_1_1_logger.html">Logger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a43d675d13f2fdad48c20753cbf9a611d">helog</a></td></tr>
<tr class="memdesc:a43d675d13f2fdad48c20753cbf9a611d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal global logger.  <a href="namespacehelib.html#a43d675d13f2fdad48c20753cbf9a611d">More...</a><br /></td></tr>
<tr class="separator:a43d675d13f2fdad48c20753cbf9a611d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443844fce5e8d1b68b5bbc11d7827836"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a443844fce5e8d1b68b5bbc11d7827836">fhe_test_force_bsgs</a> = 0</td></tr>
<tr class="separator:a443844fce5e8d1b68b5bbc11d7827836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4064daef7469afa9d911c7ba658e9285"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4064daef7469afa9d911c7ba658e9285">fhe_test_force_hoist</a> = 0</td></tr>
<tr class="separator:a4064daef7469afa9d911c7ba658e9285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e11abf6db9206e9dc7ac9397ce28fb"><td class="memItemLeft" align="right" valign="top">const long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa4e11abf6db9206e9dc7ac9397ce28fb">PI</a></td></tr>
<tr class="separator:aa4e11abf6db9206e9dc7ac9397ce28fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac088f2fa765a2ab95c318d60df164b6d"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ac088f2fa765a2ab95c318d60df164b6d">erfc_inverse</a> []</td></tr>
<tr class="separator:ac088f2fa765a2ab95c318d60df164b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a63df2a7e377c38ac5d33853caff325"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a6a63df2a7e377c38ac5d33853caff325">thinRecrypt_initial_level</a></td></tr>
<tr class="separator:a6a63df2a7e377c38ac5d33853caff325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c8e1d9a3a6012dba0e881be855ab6"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a369c8e1d9a3a6012dba0e881be855ab6">fhe_force_chen_han</a> = 0</td></tr>
<tr class="separator:a369c8e1d9a3a6012dba0e881be855ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244137dad8f49e984df751ef5d044f4c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a244137dad8f49e984df751ef5d044f4c">printFlag</a></td></tr>
<tr class="separator:a244137dad8f49e984df751ef5d044f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f0fb8de69aa81c6224003a79011ed3"><td class="memItemLeft" align="right" valign="top">NTL_THREAD_LOCAL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a47f0fb8de69aa81c6224003a79011ed3">replicateVerboseFlag</a> = false</td></tr>
<tr class="separator:a47f0fb8de69aa81c6224003a79011ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15af59c8cd87bc4a475ed3e1ce577cc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a15af59c8cd87bc4a475ed3e1ce577cc7">fhe_watcher</a> = 0</td></tr>
<tr class="separator:a15af59c8cd87bc4a475ed3e1ce577cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562cdbdb456ba0e706002518589d2b1f"><td class="memItemLeft" align="right" valign="top">const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a562cdbdb456ba0e706002518589d2b1f">CLOCK_SCALE</a> = (unsigned long)CLOCKS_PER_SEC</td></tr>
<tr class="separator:a562cdbdb456ba0e706002518589d2b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Strategies for generating key-switching matrices</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7d2878e27d1f99949dac6474bd0f3c5d"></a>These functions are implemented in KeySwitching.cpp </p>
</td></tr>
<tr class="memitem:a4fb58a793bef4befd9d75d8852d8fc55"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4fb58a793bef4befd9d75d8852d8fc55">KSGiantStepSize</a> (long D)</td></tr>
<tr class="memdesc:a4fb58a793bef4befd9d75d8852d8fc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns number of baby steps. Used to keep this and matmul routines "in sync".  <a href="namespacehelib.html#a4fb58a793bef4befd9d75d8852d8fc55">More...</a><br /></td></tr>
<tr class="separator:a4fb58a793bef4befd9d75d8852d8fc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da7a89f85244e58f456a86832c46a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4da7a89f85244e58f456a86832c46a27">addAllMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long keyID=0)</td></tr>
<tr class="memdesc:a4da7a89f85244e58f456a86832c46a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximalistic approach: generate matrices s(X^e)-&gt;s(X) for all e in Zm*.  <a href="namespacehelib.html#a4da7a89f85244e58f456a86832c46a27">More...</a><br /></td></tr>
<tr class="separator:a4da7a89f85244e58f456a86832c46a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7803e7000d31eda4aa3af44bfe0ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acd7803e7000d31eda4aa3af44bfe0ef0">addFewMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long keyID=0)</td></tr>
<tr class="memdesc:acd7803e7000d31eda4aa3af44bfe0ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate matrices so every s(X^e) can be reLinearized in at most two steps.  <a href="namespacehelib.html#acd7803e7000d31eda4aa3af44bfe0ef0">More...</a><br /></td></tr>
<tr class="separator:acd7803e7000d31eda4aa3af44bfe0ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ace8477657e91faeb4c33824bab098d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3ace8477657e91faeb4c33824bab098d">addSome1DMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long bound=HELIB_KEYSWITCH_THRESH, long keyID=0)</td></tr>
<tr class="memdesc:a3ace8477657e91faeb4c33824bab098d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate some matrices of the form s(X^{g^i})-&gt;s(X), but not all. For a generator g whose order is larger than bound, generate only enough matrices for the giant-step/baby-step procedures (2*sqrt(ord(g))of them).  <a href="namespacehelib.html#a3ace8477657e91faeb4c33824bab098d">More...</a><br /></td></tr>
<tr class="separator:a3ace8477657e91faeb4c33824bab098d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3689b135fde2c843eed5ce0813a975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8f3689b135fde2c843eed5ce0813a975">add1DMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long keyID=0)</td></tr>
<tr class="memdesc:a8f3689b135fde2c843eed5ce0813a975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all matrices s(X^{g^i})-&gt;s(X) for generators g of Zm* /(p) and i&lt;ord(g). If g has different orders in Zm* and Zm* /(p) then generate also matrices of the form s(X^{g^{-i}})-&gt;s(X)  <a href="namespacehelib.html#a8f3689b135fde2c843eed5ce0813a975">More...</a><br /></td></tr>
<tr class="separator:a8f3689b135fde2c843eed5ce0813a975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d75eed1d12814e2e858ab82e07d311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a63d75eed1d12814e2e858ab82e07d311">addBSGS1DMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long keyID=0)</td></tr>
<tr class="separator:a63d75eed1d12814e2e858ab82e07d311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b42a155c81c0507222ebca1f0a39f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a40b42a155c81c0507222ebca1f0a39f8">addSomeFrbMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long bound=HELIB_KEYSWITCH_THRESH, long keyID=0)</td></tr>
<tr class="memdesc:a40b42a155c81c0507222ebca1f0a39f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all/some Frobenius matrices of the form s(X^{p^i})-&gt;s(X)  <a href="namespacehelib.html#a40b42a155c81c0507222ebca1f0a39f8">More...</a><br /></td></tr>
<tr class="separator:a40b42a155c81c0507222ebca1f0a39f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bfda232309a69cc3824e5323345073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a62bfda232309a69cc3824e5323345073">addFrbMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long keyID=0)</td></tr>
<tr class="separator:a62bfda232309a69cc3824e5323345073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9483c8e129d827f9b49f140a327dd15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af9483c8e129d827f9b49f140a327dd15">addBSGSFrbMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long keyID=0)</td></tr>
<tr class="separator:af9483c8e129d827f9b49f140a327dd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3d6b66cd30aed055d9c5a6333eca7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0c3d6b66cd30aed055d9c5a6333eca7c">addMinimal1DMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long keyID=0)</td></tr>
<tr class="memdesc:a0c3d6b66cd30aed055d9c5a6333eca7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">These routines just add a single matrix (or two, for bad dimensions)  <a href="namespacehelib.html#a0c3d6b66cd30aed055d9c5a6333eca7c">More...</a><br /></td></tr>
<tr class="separator:a0c3d6b66cd30aed055d9c5a6333eca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94886e3afbcd49800243fd7fdaedd39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa94886e3afbcd49800243fd7fdaedd39">addMinimalFrbMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, long keyID=0)</td></tr>
<tr class="separator:aa94886e3afbcd49800243fd7fdaedd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d420cdf0dc5b6968a8a89809cd5b5f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7d420cdf0dc5b6968a8a89809cd5b5f3">addMatrices4Network</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, const <a class="el" href="classhelib_1_1_perm_network.html">PermNetwork</a> &amp;net, long keyID=0)</td></tr>
<tr class="separator:a7d420cdf0dc5b6968a8a89809cd5b5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c1092ac50c752cc8577da03cf232d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a96c1092ac50c752cc8577da03cf232d4">addTheseMatrices</a> (<a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;sKey, const std::set&lt; long &gt; &amp;automVals, long keyID=0)</td></tr>
<tr class="memdesc:a96c1092ac50c752cc8577da03cf232d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate specific key-switching matrices, described by the given set.  <a href="namespacehelib.html#a96c1092ac50c752cc8577da03cf232d4">More...</a><br /></td></tr>
<tr class="separator:a96c1092ac50c752cc8577da03cf232d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae977d2527a20cd02ae18841eea99aa2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae977d2527a20cd02ae18841eea99aa2e">PolyRed</a> (NTL::ZZX &amp;out, const NTL::ZZX &amp;in, long q, bool abs=false)</td></tr>
<tr class="memdesc:ae977d2527a20cd02ae18841eea99aa2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce all the coefficients of a polynomial modulo q.  <a href="namespacehelib.html#ae977d2527a20cd02ae18841eea99aa2e">More...</a><br /></td></tr>
<tr class="separator:ae977d2527a20cd02ae18841eea99aa2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2078641e9787af3d6acbee6d557dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acd2078641e9787af3d6acbee6d557dad">PolyRed</a> (NTL::ZZX &amp;out, const NTL::ZZX &amp;in, const NTL::ZZ &amp;q, bool abs=false)</td></tr>
<tr class="separator:acd2078641e9787af3d6acbee6d557dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8847d93fff429651833026b9553e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aec8847d93fff429651833026b9553e1b">PolyRed</a> (NTL::ZZX &amp;F, long q, bool abs=false)</td></tr>
<tr class="separator:aec8847d93fff429651833026b9553e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ada257cf26f3f2074300fddf5381f11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7ada257cf26f3f2074300fddf5381f11">PolyRed</a> (NTL::ZZX &amp;F, const NTL::ZZ &amp;q, bool abs=false)</td></tr>
<tr class="separator:a7ada257cf26f3f2074300fddf5381f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc3d452674c06b19349e1bfc47cd6bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9bc3d452674c06b19349e1bfc47cd6bb">vecRed</a> (NTL::Vec&lt; NTL::ZZ &gt; &amp;out, const NTL::Vec&lt; NTL::ZZ &gt; &amp;in, long q, bool abs)</td></tr>
<tr class="separator:a9bc3d452674c06b19349e1bfc47cd6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30e7633ce81720d2e73bb8225f82923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae30e7633ce81720d2e73bb8225f82923">vecRed</a> (NTL::Vec&lt; NTL::ZZ &gt; &amp;out, const NTL::Vec&lt; NTL::ZZ &gt; &amp;in, const NTL::ZZ &amp;q, bool abs)</td></tr>
<tr class="separator:ae30e7633ce81720d2e73bb8225f82923"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Some enhanced conversion routines</h2></td></tr>
<tr class="memitem:a877d5bbaf6ad7ef25042c6711e6a6aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a877d5bbaf6ad7ef25042c6711e6a6aa2">convert</a> (long &amp;x1, const NTL::GF2X &amp;x2)</td></tr>
<tr class="separator:a877d5bbaf6ad7ef25042c6711e6a6aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d74d8c1673da0da8d2d53a9f56f30a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad7d74d8c1673da0da8d2d53a9f56f30a">convert</a> (long &amp;x1, const NTL::zz_pX &amp;x2)</td></tr>
<tr class="separator:ad7d74d8c1673da0da8d2d53a9f56f30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea2ca2bb25fb996d1d3544a353d83eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#afea2ca2bb25fb996d1d3544a353d83eb">convert</a> (NTL::vec_zz_pE &amp;X, const std::vector&lt; NTL::ZZX &gt; &amp;A)</td></tr>
<tr class="separator:afea2ca2bb25fb996d1d3544a353d83eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20c6011cba88e302d44bb0db4a6e7f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa20c6011cba88e302d44bb0db4a6e7f8">convert</a> (NTL::mat_zz_pE &amp;X, const std::vector&lt; std::vector&lt; NTL::ZZX &gt;&gt; &amp;A)</td></tr>
<tr class="separator:aa20c6011cba88e302d44bb0db4a6e7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ec8745473d116541a8b302dfa70fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af1ec8745473d116541a8b302dfa70fa9">convert</a> (std::vector&lt; NTL::ZZX &gt; &amp;X, const NTL::vec_zz_pE &amp;A)</td></tr>
<tr class="separator:af1ec8745473d116541a8b302dfa70fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89daf2e69e1e8c09c09311b1430021f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a89daf2e69e1e8c09c09311b1430021f4">convert</a> (std::vector&lt; std::vector&lt; NTL::ZZX &gt;&gt; &amp;X, const NTL::mat_zz_pE &amp;A)</td></tr>
<tr class="separator:a89daf2e69e1e8c09c09311b1430021f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7508506eab50bf677b80d5dc6669c980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7508506eab50bf677b80d5dc6669c980">convert</a> (NTL::Vec&lt; long &gt; &amp;out, const NTL::ZZX &amp;in)</td></tr>
<tr class="separator:a7508506eab50bf677b80d5dc6669c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb539ffd2cd2268861ad793f88f6393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1eb539ffd2cd2268861ad793f88f6393">convert</a> (NTL::Vec&lt; long &gt; &amp;out, const NTL::zz_pX &amp;in, bool symmetric=true)</td></tr>
<tr class="separator:a1eb539ffd2cd2268861ad793f88f6393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195d039398c66533aa7a1ba455ffcd4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a195d039398c66533aa7a1ba455ffcd4b">convert</a> (NTL::Vec&lt; long &gt; &amp;out, const NTL::GF2X &amp;in)</td></tr>
<tr class="separator:a195d039398c66533aa7a1ba455ffcd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ddd5fc2763e981326700c9dcc2e777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af3ddd5fc2763e981326700c9dcc2e777">convert</a> (NTL::ZZX &amp;out, const NTL::Vec&lt; long &gt; &amp;in)</td></tr>
<tr class="separator:af3ddd5fc2763e981326700c9dcc2e777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9c95cba9d0a0f6f4a8220548276003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4b9c95cba9d0a0f6f4a8220548276003">convert</a> (NTL::GF2X &amp;out, const NTL::Vec&lt; long &gt; &amp;in)</td></tr>
<tr class="separator:a4b9c95cba9d0a0f6f4a8220548276003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c561d9f496e4d62c96dfab1e5040a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a60c561d9f496e4d62c96dfab1e5040a4">boundFreshNoise</a> (long m, long phim, double sigma, double epsilon=9e-13)</td></tr>
<tr class="separator:a60c561d9f496e4d62c96dfab1e5040a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16658952887fd437cdaccb4ec43b5717"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a16658952887fd437cdaccb4ec43b5717">boundRoundingNoise</a> (long m, long phim, long p2r, double epsilon=9e-13)</td></tr>
<tr class="separator:a16658952887fd437cdaccb4ec43b5717"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abd32b2ba6d41fbd5943e40c4371e86a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd32b2ba6d41fbd5943e40c4371e86a5">&#9670;&nbsp;</a></span>aligned_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehelib.html#abd32b2ba6d41fbd5943e40c4371e86a5">helib::aligned_vector</a> = typedef <a class="el" href="classhelib_1_1_p_g_f_f_t.html#a618bb04e868985f8159d8063829f1f88">PGFFT::aligned_vector</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c94755e338132a41051da4c73f35ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c94755e338132a41051da4c73f35ae4">&#9670;&nbsp;</a></span>cmplx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef complex&lt;double&gt; <a class="el" href="namespacehelib.html#a3c94755e338132a41051da4c73f35ae4">helib::cmplx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac54132076174cf5388da4f1121f4d417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54132076174cf5388da4f1121f4d417">&#9670;&nbsp;</a></span>CtPtrMat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_matrix.html">PtrMatrix</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#ac54132076174cf5388da4f1121f4d417">helib::CtPtrMat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3985a932f1b51600445c078fc5531d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3985a932f1b51600445c078fc5531d19">&#9670;&nbsp;</a></span>CtPtrMat_ptVecCt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_matrix__pt_vec.html">PtrMatrix_ptVec</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#a3985a932f1b51600445c078fc5531d19">helib::CtPtrMat_ptVecCt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2417782a109df301d765fbcdfe6ac1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2417782a109df301d765fbcdfe6ac1b7">&#9670;&nbsp;</a></span>CtPtrMat_ptvectorCt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_matrix__ptvector.html">PtrMatrix_ptvector</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#a2417782a109df301d765fbcdfe6ac1b7">helib::CtPtrMat_ptvectorCt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a536b3dcc07d9bee58c6f52f62118cd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536b3dcc07d9bee58c6f52f62118cd53">&#9670;&nbsp;</a></span>CtPtrMat_VecCt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_matrix___vec.html">PtrMatrix_Vec</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#a536b3dcc07d9bee58c6f52f62118cd53">helib::CtPtrMat_VecCt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f951b4c929a807f0a369b1aed560c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f951b4c929a807f0a369b1aed560c6a">&#9670;&nbsp;</a></span>CtPtrMat_vectorCt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_matrix__vector.html">PtrMatrix_vector</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#a2f951b4c929a807f0a369b1aed560c6a">helib::CtPtrMat_vectorCt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afac4e5ae4b272f9ffd07daee26285dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac4e5ae4b272f9ffd07daee26285dad">&#9670;&nbsp;</a></span>CtPtrs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">helib::CtPtrs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afddae64ffeb6698a0b2a5214ab66273b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddae64ffeb6698a0b2a5214ab66273b">&#9670;&nbsp;</a></span>CtPtrs_slice</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_vector__slice.html">PtrVector_slice</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#afddae64ffeb6698a0b2a5214ab66273b">helib::CtPtrs_slice</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68bdc610c69d2325ae28b53783225701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bdc610c69d2325ae28b53783225701">&#9670;&nbsp;</a></span>CtPtrs_VecCt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_vector___vec_t.html">PtrVector_VecT</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#a68bdc610c69d2325ae28b53783225701">helib::CtPtrs_VecCt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf611a971d91604083e4a4f4d2745a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf611a971d91604083e4a4f4d2745a46">&#9670;&nbsp;</a></span>CtPtrs_VecPt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_vector___vec_pt.html">PtrVector_VecPt</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#adf611a971d91604083e4a4f4d2745a46">helib::CtPtrs_VecPt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70957f911bb89f6b84e7838ac4363d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70957f911bb89f6b84e7838ac4363d07">&#9670;&nbsp;</a></span>CtPtrs_vectorCt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_vector__vector_t.html">PtrVector_vectorT</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#a70957f911bb89f6b84e7838ac4363d07">helib::CtPtrs_vectorCt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9e2fec60563f1741cf5b38e9c975781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e2fec60563f1741cf5b38e9c975781">&#9670;&nbsp;</a></span>CtPtrs_vectorPt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhelib_1_1_ptr_vector__vector_pt.html">PtrVector_vectorPt</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; <a class="el" href="namespacehelib.html#ac9e2fec60563f1741cf5b38e9c975781">helib::CtPtrs_vectorPt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a719cb433e43e9f4a88ada8b72d3b715d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719cb433e43e9f4a88ada8b72d3b715d">&#9670;&nbsp;</a></span>cx_double</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::complex&lt; double &gt; <a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">helib::cx_double</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a428c028bc71d7be0bdaa0118f286ee2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428c028bc71d7be0bdaa0118f286ee2e">&#9670;&nbsp;</a></span>DCRTptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a>&gt; <a class="el" href="namespacehelib.html#a428c028bc71d7be0bdaa0118f286ee2e">helib::DCRTptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af547f7016fc73b7174a2018ea28ef298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af547f7016fc73b7174a2018ea28ef298">&#9670;&nbsp;</a></span>FlowGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespacehelib.html#a22330000dbd6d83a79f312ccb04405fb">FNeighborList</a>&gt; <a class="el" href="namespacehelib.html#af547f7016fc73b7174a2018ea28ef298">helib::FlowGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22330000dbd6d83a79f312ccb04405fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22330000dbd6d83a79f312ccb04405fb">&#9670;&nbsp;</a></span>FNeighborList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt;long, <a class="el" href="classhelib_1_1_flow_edge.html">FlowEdge</a>&gt; <a class="el" href="namespacehelib.html#a22330000dbd6d83a79f312ccb04405fb">helib::FNeighborList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b643292f10bf869b8650f9392ff2d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b643292f10bf869b8650f9392ff2d90">&#9670;&nbsp;</a></span>ldbl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long double <a class="el" href="namespacehelib.html#a9b643292f10bf869b8650f9392ff2d90">helib::ldbl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3940838420e66ad737389ec211730b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3940838420e66ad737389ec211730b3">&#9670;&nbsp;</a></span>LNeighborList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_multimap&lt;long, <a class="el" href="classhelib_1_1_labeled_edge.html">LabeledEdge</a>&gt; <a class="el" href="namespacehelib.html#ab3940838420e66ad737389ec211730b3">helib::LNeighborList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6eb9f0889a704dbc4684ce445c48456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6eb9f0889a704dbc4684ce445c48456">&#9670;&nbsp;</a></span>LONG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef long <a class="el" href="namespacehelib.html#ad6eb9f0889a704dbc4684ce445c48456">helib::LONG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9af476860763122a38ad2ae71ad5b9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af476860763122a38ad2ae71ad5b9bc">&#9670;&nbsp;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">helib::Matrix</a> = typedef <a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt;T, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a007ac83d6ec59826a48a73602b739510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007ac83d6ec59826a48a73602b739510">&#9670;&nbsp;</a></span>NodeIdx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;long, long&gt; <a class="el" href="namespacehelib.html#a007ac83d6ec59826a48a73602b739510">helib::NodeIdx</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22b83b7df1af539c07c804d7888448ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b83b7df1af539c07c804d7888448ce">&#9670;&nbsp;</a></span>OneGeneratorTree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classhelib_1_1_full_binary_tree.html">FullBinaryTree</a>&lt;<a class="el" href="classhelib_1_1_sub_dimension.html">SubDimension</a>&gt; <a class="el" href="namespacehelib.html#a22b83b7df1af539c07c804d7888448ce">helib::OneGeneratorTree</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0769a209e14d5e1bfd8579072397867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0769a209e14d5e1bfd8579072397867">&#9670;&nbsp;</a></span>Permut</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NTL::Vec&lt;long&gt; <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">helib::Permut</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple permutation is just a vector with p[i]=\pi_i. </p>

</div>
</div>
<a id="a72bfe799ca2748e0f67e80e799bbcebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bfe799ca2748e0f67e80e799bbcebb">&#9670;&nbsp;</a></span>QueryExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">helib::QueryExpr</a> = typedef std::shared_ptr&lt;<a class="el" href="structhelib_1_1_expr.html">Expr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for a shared pointer to an <code><a class="el" href="structhelib_1_1_expr.html" title="Base structure for logical expressions.">Expr</a></code> object. </p>

</div>
</div>
<a id="a67a60bb8531261415fb3615bde85ae65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a60bb8531261415fb3615bde85ae65">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehelib.html#a67a60bb8531261415fb3615bde85ae65">helib::Vector</a> = typedef <a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt;T, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d6002f36f1a61982fded09adf1331ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6002f36f1a61982fded09adf1331ca">&#9670;&nbsp;</a></span>zzX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NTL::Vec&lt;long&gt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">helib::zzX</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3652f33aab9e225a4c136eb14a50bc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3652f33aab9e225a4c136eb14a50bc53">&#9670;&nbsp;</a></span>ZZXptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;NTL::ZZX&gt; <a class="el" href="namespacehelib.html#a3652f33aab9e225a4c136eb14a50bc53">helib::ZZXptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ab0181d82dc81ed4d1f8c1d950b4efd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0181d82dc81ed4d1f8c1d950b4efd7e">&#9670;&nbsp;</a></span>PA_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehelib.html#ab0181d82dc81ed4d1f8c1d950b4efd7e">helib::PA_tag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab0181d82dc81ed4d1f8c1d950b4efd7eab33244c736f38a4c21e6d86c6a683d58"></a>PA_GF2_tag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab0181d82dc81ed4d1f8c1d950b4efd7ea63d35380340004730e7cb505a4da38e2"></a>PA_zz_p_tag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab0181d82dc81ed4d1f8c1d950b4efd7ea7d944116ae9eb1abb2d5fa92bb6d21ee"></a>PA_cx_tag&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a42185bbb249368e34f515e09e90bc7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42185bbb249368e34f515e09e90bc7b0">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33424cc1805af9dc818e142033c9d9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33424cc1805af9dc818e142033c9d9be">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::add </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa160e775ba4dcac09cec20c2febb5de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa160e775ba4dcac09cec20c2febb5de2">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f3689b135fde2c843eed5ce0813a975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3689b135fde2c843eed5ce0813a975">&#9670;&nbsp;</a></span>add1DMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::add1DMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate all matrices s(X^{g^i})-&gt;s(X) for generators g of Zm* /(p) and i&lt;ord(g). If g has different orders in Zm* and Zm* /(p) then generate also matrices of the form s(X^{g^{-i}})-&gt;s(X) </p>

</div>
</div>
<a id="a4da7a89f85244e58f456a86832c46a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da7a89f85244e58f456a86832c46a27">&#9670;&nbsp;</a></span>addAllMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addAllMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximalistic approach: generate matrices s(X^e)-&gt;s(X) for all e in Zm*. </p>

</div>
</div>
<a id="a63d75eed1d12814e2e858ab82e07d311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d75eed1d12814e2e858ab82e07d311">&#9670;&nbsp;</a></span>addBSGS1DMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addBSGS1DMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9483c8e129d827f9b49f140a327dd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9483c8e129d827f9b49f140a327dd15">&#9670;&nbsp;</a></span>addBSGSFrbMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addBSGSFrbMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd7803e7000d31eda4aa3af44bfe0ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7803e7000d31eda4aa3af44bfe0ef0">&#9670;&nbsp;</a></span>addFewMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addFewMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate matrices so every s(X^e) can be reLinearized in at most two steps. </p>

</div>
</div>
<a id="a62bfda232309a69cc3824e5323345073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bfda232309a69cc3824e5323345073">&#9670;&nbsp;</a></span>addFrbMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addFrbMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34e793367187e97095f9f2590eb4dc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e793367187e97095f9f2590eb4dc5e">&#9670;&nbsp;</a></span>addManyNumbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addManyNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#ac54132076174cf5388da4f1121f4d417">CtPtrMat</a> &amp;&#160;</td>
          <td class="paramname"><em>numbers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sizeLimit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum an arbitrary amount of numbers in binary representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sum</td><td>result of the summation. </td></tr>
    <tr><td class="paramname">numbers</td><td>values of which to sum. </td></tr>
    <tr><td class="paramname">sizeLimit</td><td>number of bits to compute on, taken from the least significant end. </td></tr>
    <tr><td class="paramname">unpackSlotEncoding</td><td>vector of constants for unpacking, as used in bootstrapping.</td></tr>
  </table>
  </dd>
</dl>
<p>Calculates the sum of many numbers using the 3-for-2 method. </p>

</div>
</div>
<a id="a7d420cdf0dc5b6968a8a89809cd5b5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d420cdf0dc5b6968a8a89809cd5b5f3">&#9670;&nbsp;</a></span>addMatrices4Network()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addMatrices4Network </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_perm_network.html">PermNetwork</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c3d6b66cd30aed055d9c5a6333eca7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3d6b66cd30aed055d9c5a6333eca7c">&#9670;&nbsp;</a></span>addMinimal1DMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addMinimal1DMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These routines just add a single matrix (or two, for bad dimensions) </p>

</div>
</div>
<a id="aa94886e3afbcd49800243fd7fdaedd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94886e3afbcd49800243fd7fdaedd39">&#9670;&nbsp;</a></span>addMinimalFrbMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addMinimalFrbMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bcb58c007d8e3cb2a1b4c7d0c162895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcb58c007d8e3cb2a1b4c7d0c162895">&#9670;&nbsp;</a></span>addOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addOffset </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>aux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED bool&#160;</td>
          <td class="paramname"><em>good</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ace8477657e91faeb4c33824bab098d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ace8477657e91faeb4c33824bab098d">&#9670;&nbsp;</a></span>addSome1DMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addSome1DMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bound</em> = <code>HELIB_KEYSWITCH_THRESH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate some matrices of the form s(X^{g^i})-&gt;s(X), but not all. For a generator g whose order is larger than bound, generate only enough matrices for the giant-step/baby-step procedures (2*sqrt(ord(g))of them). </p>

</div>
</div>
<a id="a40b42a155c81c0507222ebca1f0a39f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b42a155c81c0507222ebca1f0a39f8">&#9670;&nbsp;</a></span>addSomeFrbMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addSomeFrbMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bound</em> = <code>HELIB_KEYSWITCH_THRESH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate all/some Frobenius matrices of the form s(X^{p^i})-&gt;s(X) </p>

</div>
</div>
<a id="aac13602434c22102de26465c49856eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac13602434c22102de26465c49856eeb">&#9670;&nbsp;</a></span>addSomePrimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addSomePrimes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c1092ac50c752cc8577da03cf232d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c1092ac50c752cc8577da03cf232d4">&#9670;&nbsp;</a></span>addTheseMatrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addTheseMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>automVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>keyID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate specific key-switching matrices, described by the given set. </p>

</div>
</div>
<a id="a277237f0883421a2abee740db9f1b6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277237f0883421a2abee740db9f1b6ef">&#9670;&nbsp;</a></span>addTwoNumbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::addTwoNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sizeLimit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two numbers in binary representation where each ciphertext of the input vector contains a bit. </p>
<p>Add two integers in binary representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sum</td><td>result of the addition operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side of the addition. </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side of the addition. </td></tr>
    <tr><td class="paramname">sizeLimit</td><td>number of bits to compute on, taken from the least significant end. </td></tr>
    <tr><td class="paramname">unpackSlotEncoding</td><td>vector of constants for unpacking, as used in bootstrapping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a379dfd6585b3c7aab695a9ca33a7ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379dfd6585b3c7aab695a9ca33a7ad89">&#9670;&nbsp;</a></span>applyLinPoly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyLinPoly </td>
          <td>(</td>
          <td class="paramtype">NTL::GF2E &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_GF2E &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2E &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version for GF2: must be called with p == 2 and r == 1. </p>

</div>
</div>
<a id="a0dda3f81ff66fb0e9a92bc39ecad0a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dda3f81ff66fb0e9a92bc39ecad0a92">&#9670;&nbsp;</a></span>applyLinPoly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyLinPoly </td>
          <td>(</td>
          <td class="paramtype">NTL::zz_pE &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pE &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a linearized polynomial with coefficient vector C. </p>
<p>NTL's current smallint modulus, zz_p::modulus(), is assumed to be p^r, for p prime, r &gt;= 1 integer. </p>

</div>
</div>
<a id="a583abeb8ab8021559fb519621b42c3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583abeb8ab8021559fb519621b42c3d7">&#9670;&nbsp;</a></span>applyLinPoly1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyLinPoly1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f6f5e7fb2a932db709cbb632e644a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6f5e7fb2a932db709cbb632e644a81">&#9670;&nbsp;</a></span>applyLinPolyLL() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::applyLinPolyLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>encodedC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a896039fe9d2b2bda45cf62d278e52a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896039fe9d2b2bda45cf62d278e52a5f">&#9670;&nbsp;</a></span>applyLinPolyLL() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::applyLinPolyLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>encodedC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21457a6ed2a6de2701b394bfcc90be1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21457a6ed2a6de2701b394bfcc90be1e">&#9670;&nbsp;</a></span>applyLinPolyLL() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyLinPolyLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>encodedC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bc9fd386812fdc5f5067522dc4ceced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc9fd386812fdc5f5067522dc4ceced">&#9670;&nbsp;</a></span>applyLinPolyLL() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::applyLinPolyLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>encodedC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8e520a1528ee0d150a9818c7ddc4850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e520a1528ee0d150a9818c7ddc4850">&#9670;&nbsp;</a></span>applyLinPolyMany()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyLinPolyMany </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; NTL::ZZX &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Cvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf575ea763b7454a6e8df566a9e64b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf575ea763b7454a6e8df566a9e64b3c">&#9670;&nbsp;</a></span>applyPerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyPerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ae17bbc28a578112d0fe28b99f5e204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae17bbc28a578112d0fe28b99f5e204">&#9670;&nbsp;</a></span>applyPermsToVec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyPermsToVec </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply two permutations to a std::vector out[i]=in[p2[p1[i]]] (NOT in-place) </p>

</div>
</div>
<a id="a6c6d61d4ac69597feb9beedc26bf93cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6d61d4ac69597feb9beedc26bf93cc">&#9670;&nbsp;</a></span>applyPermsToVec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyPermsToVec </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe7675aa123a573bc6d687c1421f2308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7675aa123a573bc6d687c1421f2308">&#9670;&nbsp;</a></span>applyPermsToVec&lt; long &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacehelib.html#a0ae17bbc28a578112d0fe28b99f5e204">helib::applyPermsToVec</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc4a600c33f24c48a5074b19d9db9d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4a600c33f24c48a5074b19d9db9d24">&#9670;&nbsp;</a></span>applyPermsToVec&lt; long &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacehelib.html#a0ae17bbc28a578112d0fe28b99f5e204">helib::applyPermsToVec</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cf8627539f6c1c46e6ae9287058f7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf8627539f6c1c46e6ae9287058f7cc">&#9670;&nbsp;</a></span>applyPermToVec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyPermToVec </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a permutation to a std::vector, out[i]=in[p1[i]] (NOT in-place) </p>

</div>
</div>
<a id="abae99af99454c783bed9cbde7cd72058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae99af99454c783bed9cbde7cd72058">&#9670;&nbsp;</a></span>applyPermToVec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::applyPermToVec </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81a1417dec7a02c2dc600a3802cb3102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a1417dec7a02c2dc600a3802cb3102">&#9670;&nbsp;</a></span>applyPermToVec&lt; long &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacehelib.html#a0cf8627539f6c1c46e6ae9287058f7cc">helib::applyPermToVec</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a331891be147b33a730e697f3d9e9bc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331891be147b33a730e697f3d9e9bc92">&#9670;&nbsp;</a></span>applyPermToVec&lt; long &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacehelib.html#a0cf8627539f6c1c46e6ae9287058f7cc">helib::applyPermToVec</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff1608eb4840762727e4733e2c63b8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1608eb4840762727e4733e2c63b8bb">&#9670;&nbsp;</a></span>applyPermToVec&lt; NTL::ZZX &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacehelib.html#a0cf8627539f6c1c46e6ae9287058f7cc">helib::applyPermToVec</a>&lt; NTL::ZZX &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94c1a39dcabf4a83066a2908a02e274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94c1a39dcabf4a83066a2908a02e274">&#9670;&nbsp;</a></span>areTimersOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::areTimersOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acced988b8c7248219e7c13e20d1d0e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acced988b8c7248219e7c13e20d1d0e6c">&#9670;&nbsp;</a></span>argmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::argmax </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(long, long)&#160;</td>
          <td class="paramname"><em>moreThan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant with a specialized comparison function (*moreThan)(a,b) returns the comparison a&gt;b. </p>

</div>
</div>
<a id="ae84a9818e92cbee595e4895ad9dee849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84a9818e92cbee595e4895ad9dee849">&#9670;&nbsp;</a></span>argmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long helib::argmax </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4218a947a483c68d1727c537c216c347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4218a947a483c68d1727c537c216c347">&#9670;&nbsp;</a></span>argmin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long helib::argmin </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa88363f3a91a37ba8e213b0cb764ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa88363f3a91a37ba8e213b0cb764ea5">&#9670;&nbsp;</a></span>argminmax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool maxFlag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long helib::argminmax </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of the (first) largest/smallest element. </p>
<p>These procedures are roughly just simpler variants of std::max_element and std::min_element. argmin/argmax are implemented as a template, so the code must be placed in the header file for the compiler to find it. The class T must have an implementation of operator&gt; and operator&lt; for this template to work. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">maxFlag</td><td>A boolean value: true - argmax, false - argmin </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec77ae5fa0fd11a0a42e07fefe49b99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec77ae5fa0fd11a0a42e07fefe49b99d">&#9670;&nbsp;</a></span>assertEq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::assertEq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function throwing an exception of type ExceptionTy if the two arguments are not equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExceptionTy</td><td>type of the exception thrown. </td></tr>
    <tr><td class="paramname">T</td><td>type of the elements to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first element to be compared. </td></tr>
    <tr><td class="paramname">b</td><td>the second element to be compared. </td></tr>
    <tr><td class="paramname">message</td><td>the message of the exception raised if the two values are not equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ExceptionTy</td><td>exception if the two values are not equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ExceptionTy first and T defaulted to void so that one can specify only ExceptionTy, letting T be inferred from the argument passed. </dd></dl>

</div>
</div>
<a id="ad5fc5ad34739ea66baa96f988dd07beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fc5ad34739ea66baa96f988dd07beb">&#9670;&nbsp;</a></span>assertFalse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::assertFalse </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function throwing an exception of type ExceptionTy if the condition is true.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExceptionTy</td><td>type of the exception thrown. </td></tr>
    <tr><td class="paramname">T</td><td>type of the condition being checked (must be a bool). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the condition being checked. </td></tr>
    <tr><td class="paramname">message</td><td>the message of the exception raised if the condition is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ExceptionTy</td><td>exception if condition is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ExceptionTy first and T defaulted to void so that one can specify only ExceptionTy, letting T be inferred from the argument passed. </dd></dl>

</div>
</div>
<a id="a8e36344202aac3b245f5ba71f69a3e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e36344202aac3b245f5ba71f69a3e8b">&#9670;&nbsp;</a></span>assertInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExceptionTy  = ::helib::OutOfRangeError, typename T  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::assertInRange </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_inclusive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function throwing an exception of type ExceptionTy if the element is in the range [min,max) or [min, max]</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExceptionTy</td><td>type of the exception thrown. </td></tr>
    <tr><td class="paramname">T</td><td>type of the element (and of the range). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>the element to be tested. </td></tr>
    <tr><td class="paramname">min</td><td>the left side of the range (always inclusive). </td></tr>
    <tr><td class="paramname">max</td><td>the right side of the range (default exclusive). </td></tr>
    <tr><td class="paramname">message</td><td>the message of the exception raised if the element is not in the range. </td></tr>
    <tr><td class="paramname">right_inclusive</td><td>flag specifying if the right side is inclusive (default false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ExceptionTy</td><td>exception if elem is not in the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ExceptionTy first and T defaulted to void so that one can specify only ExceptionTy, letting T be inferred from the argument passed. </dd></dl>

</div>
</div>
<a id="acd5b530c0837ef9111dc4a361364d669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5b530c0837ef9111dc4a361364d669">&#9670;&nbsp;</a></span>assertNeq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::assertNeq </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function throwing an exception of type ExceptionTy if the two arguments are equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExceptionTy</td><td>type of the exception thrown. </td></tr>
    <tr><td class="paramname">T</td><td>type of the elements to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first element to be compared. </td></tr>
    <tr><td class="paramname">b</td><td>the second element to be compared. </td></tr>
    <tr><td class="paramname">message</td><td>the message of the exception raised if the two values are equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ExceptionTy</td><td>exception if the two values are equal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ExceptionTy first and T defaulted to void so that one can specify only ExceptionTy, letting T be inferred from the argument passed. </dd></dl>

</div>
</div>
<a id="aa7b1da8169ee8b9a0ab221e4c67961c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b1da8169ee8b9a0ab221e4c67961c5">&#9670;&nbsp;</a></span>assertNotNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::assertNotNull </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function throwing an exception of type ExceptionTy if the argument is nullptr.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExceptionTy</td><td>type of the exception thrown. </td></tr>
    <tr><td class="paramname">T</td><td>type of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the element to be tested. </td></tr>
    <tr><td class="paramname">message</td><td>the message of the exception raised if the element is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ExceptionTy</td><td>exception if p is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ExceptionTy first and T defaulted to void so that one can specify only ExceptionTy, letting T be inferred from the argument passed. </dd></dl>

</div>
</div>
<a id="aca37b5e05bffd4550c995e83594d7325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca37b5e05bffd4550c995e83594d7325">&#9670;&nbsp;</a></span>assertTrue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExceptionTy  = ::helib::LogicError, typename T  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::assertTrue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function throwing an exception of type ExceptionTy if the condition is false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExceptionTy</td><td>type of the exception thrown. </td></tr>
    <tr><td class="paramname">T</td><td>type of the condition being checked (must be a bool). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the condition being checked. </td></tr>
    <tr><td class="paramname">message</td><td>the message of the exception raised if the condition is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ExceptionTy</td><td>exception if condition is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>ExceptionTy first and T defaulted to void so that one can specify only ExceptionTy, letting T be inferred from the argument passed. </dd></dl>

</div>
</div>
<a id="a1040284398724d43661ac3eff7a7400e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1040284398724d43661ac3eff7a7400e">&#9670;&nbsp;</a></span>atoVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NTL::Vec&lt;T&gt; helib::atoVec </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdd11aa1bf58d7ac5843fe3ee5fb244c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd11aa1bf58d7ac5843fe3ee5fb244c">&#9670;&nbsp;</a></span>atovector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; helib::atovector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00e504f2374c5e7357c7608a94527887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e504f2374c5e7357c7608a94527887">&#9670;&nbsp;</a></span>balanced_MulMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::balanced_MulMod </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the polynomial f by the integer a modulo q output coefficients are balanced (appropriately randomized for even q) </p>

</div>
</div>
<a id="a508dcf9321109128c609e466a3e33181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508dcf9321109128c609e466a3e33181">&#9670;&nbsp;</a></span>balanced_zzX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> helib::balanced_zzX </td>
          <td>(</td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b1aa9d391c181e780742a2117e9af78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1aa9d391c181e780742a2117e9af78">&#9670;&nbsp;</a></span>balanced_zzX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> helib::balanced_zzX </td>
          <td>(</td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af183ee91810e5601837e62dfb85df0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af183ee91810e5601837e62dfb85df0cd">&#9670;&nbsp;</a></span>balRem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::balRem </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return balanced remainder. Assumes a in [0, q) and returns balanced remainder in (-q/2, q/2] </p>

</div>
</div>
<a id="a6cc8eab5085d47ef2587ff4253ec5d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc8eab5085d47ef2587ff4253ec5d77">&#9670;&nbsp;</a></span>binaryCond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::binaryCond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>trueValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>falseValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <code>output = cond * trueValue + (1 - cond) * falseValue</code>. </p>
<p>Implementation of output = cond ? trueValue : falseValue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Equal to <code>trueValue</code> in slots where <code>cond</code> is one and <code>falseValue</code> in slots where <code>cond</code> is zero. </td></tr>
    <tr><td class="paramname">cond</td><td>The condition, namely a <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code> containing elements of {0,1} in each slot. </td></tr>
    <tr><td class="paramname">trueValue</td><td>Value of <code>output</code> wherever <code>cond</code> is one. </td></tr>
    <tr><td class="paramname">falseValue</td><td>Value of <code>output</code> wherever <code>cond</code> is zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>trueValue</code>, <code>falseValue</code> and <code>output</code> must have the same size. </dd></dl>

</div>
</div>
<a id="aa08be8ce0b0f4ca1f870c56508889598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08be8ce0b0f4ca1f870c56508889598">&#9670;&nbsp;</a></span>binaryMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::binaryMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>binaryNums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zeroes the slots of <code>binaryNums</code> where the corresponding slot of <code>mask</code> is 0. </p>
<p>Apply mask across the vector of bits slot-wise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binaryNums</td><td>Input bits on which to mask (this is done in place). </td></tr>
    <tr><td class="paramname">mask</td><td>Encrypted mask indicating desired slots. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa51c5cbd9691dfde759a98c2d7b48542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51c5cbd9691dfde759a98c2d7b48542">&#9670;&nbsp;</a></span>binSumReduction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TXT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::binSumReduction </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; TXT &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctxtArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a binary summation of a vector of elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TXT</td><td>type of the elements of which to sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxtArray</td><td>The array on which to perform the binary sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is destructive on the array. </dd></dl>

</div>
</div>
<a id="af6cd0b7c9b7fa0afbb885295f10d9354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cd0b7c9b7fa0afbb885295f10d9354">&#9670;&nbsp;</a></span>bitSetToLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::bitSetToLong </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bitSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Considers <code>bits</code> as a vector of bits and returns the value it represents when interpreted as a n-bit 2's complement number, where n is given by <code>bitSize</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>The value containing the bits to be reinterpreted. </td></tr>
    <tr><td class="paramname">bitSize</td><td>The number of bits to use, taken from the least significant end of <code>bits</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the reinterpreted number as a long. </dd></dl>

</div>
</div>
<a id="a95a2868fe4324ee643869930d159f8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a2868fe4324ee643869930d159f8ff">&#9670;&nbsp;</a></span>bitwiseAnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::bitwiseAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bitwise AND between <code>input</code> and a <code>std::vector&lt;long&gt;</code>. </p>
<p>Compute a bitwise AND between <code>input</code> and <code>mask</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Equal to the output of the AND operation. </td></tr>
    <tr><td class="paramname">input</td><td>Number to AND. </td></tr>
    <tr><td class="paramname">mask</td><td>Number to AND with <code>input</code>. This should be a vector of elements of {0,1}. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <code>output</code> and <code>input</code> must be the same. </dd></dl>

</div>
</div>
<a id="a6e4ba60fb6ef861f9601a3c22c589315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4ba60fb6ef861f9601a3c22c589315">&#9670;&nbsp;</a></span>bitwiseAnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::bitwiseAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bitwise AND between <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Result of bitwise <code>lhs</code> AND <code>rhs</code>. </td></tr>
    <tr><td class="paramname">lhs</td><td>Left operand to the AND operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand to the AND operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>output</code>, <code>lhs</code> and <code>rhs</code> must all have the same size. </dd></dl>

</div>
</div>
<a id="a3bc4da63675257eacdf323d32ca23a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc4da63675257eacdf323d32ca23a83">&#9670;&nbsp;</a></span>bitwiseNot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::bitwiseNot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bitwise NOT of <code>input</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Result of bit-flipping <code>input</code>. </td></tr>
    <tr><td class="paramname">input</td><td>Binary number to be bit-flipped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <code>output</code> and <code>input</code> must be the same. </dd></dl>

</div>
</div>
<a id="a2928d18450500f401e36d50a8288bf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2928d18450500f401e36d50a8288bf0e">&#9670;&nbsp;</a></span>bitwiseOr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::bitwiseOr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bitwise OR between <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Result of bitwise <code>lhs</code> OR <code>rhs</code>. </td></tr>
    <tr><td class="paramname">lhs</td><td>Left operand to the OR operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand to the OR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>output</code>, <code>lhs</code> and <code>rhs</code> must all have the same size. </dd></dl>

</div>
</div>
<a id="a7a59ff05d1c4f1800bb2010e451576ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a59ff05d1c4f1800bb2010e451576ab">&#9670;&nbsp;</a></span>bitwiseRotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::bitwiseRotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rotamt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate <code>input</code> by <code>rotamt</code>. </p>
<p>Rotate binary numbers by <code>rotamt</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Rotated result. </td></tr>
    <tr><td class="paramname">input</td><td>The number to be bitwise-rotated. </td></tr>
    <tr><td class="paramname">rotamt</td><td>The amount by which to rotate <code>input</code>. May be negative for opposite-direction rotations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For positive <code>rotamt</code> arguments, this rotates towards the most-significant end (i.e. the same direction as leftBitwiseShift). </dd>
<dd>
The size of <code>output</code> and <code>input</code> must be the same. </dd></dl>

</div>
</div>
<a id="abaa682a93edca39cb5ce5524219c486c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa682a93edca39cb5ce5524219c486c">&#9670;&nbsp;</a></span>bitwiseXOR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::bitwiseXOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bitwise XOR between <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Result of bitwise <code>lhs</code> XOR <code>rhs</code>. </td></tr>
    <tr><td class="paramname">lhs</td><td>Left operand to the XOR operation. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand to the XOR operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>output</code>, <code>lhs</code> and <code>rhs</code> must all have the same size. </dd></dl>

</div>
</div>
<a id="ab66ba03453e871a61eda59e0f8e574af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66ba03453e871a61eda59e0f8e574af">&#9670;&nbsp;</a></span>BluesteinFFT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::BluesteinFFT </td>
          <td>(</td>
          <td class="paramtype">NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_p &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>powers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; NTL::mulmod_precon_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>powers_aux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::fftRep &amp;&#160;</td>
          <td class="paramname"><em>Rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply bluestein </p>

</div>
</div>
<a id="a76f968f2ead15d0f33947d7f1bc165f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f968f2ead15d0f33947d7f1bc165f5">&#9670;&nbsp;</a></span>BluesteinFFT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::BluesteinFFT </td>
          <td>(</td>
          <td class="paramtype">NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED const NTL::zz_p &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>powers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; NTL::mulmod_precon_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>powers_aux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::fftRep &amp;&#160;</td>
          <td class="paramname"><em>Rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac544d20010a35c78a75ce913a2b15979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac544d20010a35c78a75ce913a2b15979">&#9670;&nbsp;</a></span>BluesteinInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::BluesteinInit </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_p &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>powers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; NTL::mulmod_precon_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>powers_aux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::fftRep &amp;&#160;</td>
          <td class="paramname"><em>Rb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize bluestein </p>

</div>
</div>
<a id="a60c561d9f496e4d62c96dfab1e5040a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c561d9f496e4d62c96dfab1e5040a4">&#9670;&nbsp;</a></span>boundFreshNoise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::boundFreshNoise </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>phim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>9e-13</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper functions, return a bound B such that for random noise terms we have Pr[|canonicalEmbed(noise)|_{\infty} &gt; B] &lt; epsilon. (The default is epsilon = 2^{-40}.) </p>

</div>
</div>
<a id="a16658952887fd437cdaccb4ec43b5717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16658952887fd437cdaccb4ec43b5717">&#9670;&nbsp;</a></span>boundRoundingNoise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::boundRoundingNoise </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>phim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p2r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>9e-13</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c4cfecd6dc28011302b7b86d15dbaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4cfecd6dc28011302b7b86d15dbaa9">&#9670;&nbsp;</a></span>boundRoundingNoise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::boundRoundingNoise </td>
          <td>(</td>
          <td class="paramtype">UNUSED long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>phim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p2r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11554e25622d14682edfa2be22ed6df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11554e25622d14682edfa2be22ed6df6">&#9670;&nbsp;</a></span>breakPermByDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::breakPermByDim </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelib_1_1_col_perm.html">ColPerm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_cube_signature.html">CubeSignature</a> &amp;&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a permutation pi over m-dimensional cube C=Z_{n1} x...x Z_{nm} and expresses pi as a product pi = rho_{2m-1} o ... o rho_2 o rho_1 where each rho_i is a column permutation along one dimension. Specifically for i&lt;m, the permutations rho_i and rho_{2(m-1)-i} permute the i'th dimension. </p>

</div>
</div>
<a id="a060e401ccfa17753d928fb1812fa020f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060e401ccfa17753d928fb1812fa020f">&#9670;&nbsp;</a></span>breakPermTo3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::breakPermTo3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_col_perm.html">ColPerm</a> &amp;&#160;</td>
          <td class="paramname"><em>rho1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>rho2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_col_perm.html">ColPerm</a> &amp;&#160;</td>
          <td class="paramname"><em>rho3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5435c81f125b4a3b2fddf126601aed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5435c81f125b4a3b2fddf126601aed2">&#9670;&nbsp;</a></span>build_ConstMultiplier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structhelib_1_1_const_multiplier.html">ConstMultiplier</a>&gt; helib::build_ConstMultiplier </td>
          <td>(</td>
          <td class="paramtype">const RX &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34b18eda7cc825761797b906e47f9074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b18eda7cc825761797b906e47f9074">&#9670;&nbsp;</a></span>build_ConstMultiplier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RX , typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structhelib_1_1_const_multiplier.html">ConstMultiplier</a>&gt; helib::build_ConstMultiplier </td>
          <td>(</td>
          <td class="paramtype">const RX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array_derived.html">EncryptedArrayDerived</a>&lt; type &gt; &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7534536bd1101ec60aa4c8fe1ccdf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7534536bd1101ec60aa4c8fe1ccdf30">&#9670;&nbsp;</a></span>buildBenesCostTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::buildBenesCostTable </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>good</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; NTL::Vec&lt; long &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af02b70fdba8bb78c1f19964759f497b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02b70fdba8bb78c1f19964759f497b5">&#9670;&nbsp;</a></span>BuildContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::zz_pContext helib::BuildContext </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxroot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcfd34a416649164e3b01c4af1c8654e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfd34a416649164e3b01c4af1c8654e">&#9670;&nbsp;</a></span>buildContextFromAscii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classhelib_1_1_context.html">Context</a> &gt; helib::buildContextFromAscii </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4036006b2d0e378ce2aa90a5332a8d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4036006b2d0e378ce2aa90a5332a8d73">&#9670;&nbsp;</a></span>buildContextFromBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classhelib_1_1_context.html">Context</a> &gt; helib::buildContextFromBinary </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf194ed39fc9a3694d1a11a0cd4c75d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf194ed39fc9a3694d1a11a0cd4c75d4">&#9670;&nbsp;</a></span>buildEncryptedArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_encrypted_array_base.html">EncryptedArrayBase</a> * helib::buildEncryptedArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra_mod.html">PAlgebraMod</a> &amp;&#160;</td>
          <td class="paramname"><em>alMod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>G</em> = <code>NTL::ZZX::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A "factory" for building EncryptedArrays. </p>

</div>
</div>
<a id="a7acbf567c5271c1d20df20c6f4fa1714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acbf567c5271c1d20df20c6f4fa1714">&#9670;&nbsp;</a></span>buildGeneralAutomorphPrecon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classhelib_1_1_general_automorph_precon.html">GeneralAutomorphPrecon</a>&gt; helib::buildGeneralAutomorphPrecon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae78f42668b74b50bfeec97988619350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78f42668b74b50bfeec97988619350c">&#9670;&nbsp;</a></span>buildLinPolyCoeffs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::buildLinPolyCoeffs </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_GF2E &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_GF2E &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version for GF2: must be called with p == 2 and r == 1. </p>

</div>
</div>
<a id="a5711dacd10c102835bd585bff52e32c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5711dacd10c102835bd585bff52e32c5">&#9670;&nbsp;</a></span>buildLinPolyCoeffs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::buildLinPolyCoeffs </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combination of buildLinPolyMatrix and ppsolve. </p>
<p>Obtain the linearized polynomial coefficients from a vector L representing the action of a linear map on the standard basis for zz_pE over zz_p.</p>
<p>NTL's current smallint modulus, zz_p::modulus(), is assumed to be p^r, for p prime, r &gt;= 1 integer. </p>

</div>
</div>
<a id="a82218a5a8f14a790b60cd7f288863b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82218a5a8f14a790b60cd7f288863b9d">&#9670;&nbsp;</a></span>buildLinPolyMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::buildLinPolyMatrix </td>
          <td>(</td>
          <td class="paramtype">NTL::mat_GF2E &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7db28e5ca105b114e0c89655eee171b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db28e5ca105b114e0c89655eee171b9">&#9670;&nbsp;</a></span>buildLinPolyMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::buildLinPolyMatrix </td>
          <td>(</td>
          <td class="paramtype">NTL::mat_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add048fff3de003ad2b670a9ae3ed6f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add048fff3de003ad2b670a9ae3ed6f2b">&#9670;&nbsp;</a></span>buildLookupTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::buildLookupTable </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(double)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nbits_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>scale_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sign_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nbits_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>scale_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sign_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Built a table-lookup for a function in fixed-point representation. </p>
<p>@function buildLookupTable FIXED-POINT CONVENTIONS: Fixed-point numbers are specified by a triple (nbits,scale,signed). Such a number is represented as an integer x with nbits bits. If signed == 1, then x is treated as a signed integer in 2's compliment; otherwise it is as an unsigned integer. The value represented by x is x*2^{scale}.</p>
<p>The buildLookupTable function builds a lookup table T, which can be used in conjunction with the tableLookup function above. The size of T will be 2^{nbits_in}. For every signed integer x with bit-size 'nbits_in', we will have T[x] = f(x * 2^{scale_in}) * 2^{-scale_out}), rounded to the nearest integer and truncated to 'nbits_out' bits. The bits are packed inside the slots, so it is assumed that each slot has enough room to fit these many bits. (Otherwise we only keep as many low-order bits as fit in a slot.)</p>
<p>SATURATED ARITHMETIC: Applications of f that return a result that is too large to represent in the output format will be converted to the maximum representable value. Similarly, Applications of f that return a result that is too small will be converted to the minimal representable value. (This applies also to applications of f that return infinites, NaNs will just be mapped to zero.) For this to work correctly, you should be working with standard IEEE arithmetic...which will be the case on almost all platforms.</p>
<p>EXAMPLE:</p>
<p>buildLookupTable(T, [](double x){ return 1/x;}, nbits_in, scale_in, nbits_out, scale_out, sign_out, ea)</p>
<p>will build a lookup table for inversion. </p>

</div>
</div>
<a id="af68cc874f7e017cd4c35d1ea52739c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68cc874f7e017cd4c35d1ea52739c0f">&#9670;&nbsp;</a></span>buildModChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::buildModChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nDgts</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>willBeBootstrappable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>skHwt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bitsInSpecialPrimes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7ad5bd5c310b0ad7f96d6e2065e5b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ad5bd5c310b0ad7f96d6e2065e5b2b">&#9670;&nbsp;</a></span>buildPAlgebraMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_p_algebra_mod_base.html">PAlgebraModBase</a> * helib::buildPAlgebraMod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>zMStar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a table, of type PA_GF2 if p == 2 and r == 1, and PA_zz_p otherwise. </p>

</div>
</div>
<a id="aa512e08a2be7acf51509eb138d53f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa512e08a2be7acf51509eb138d53f819">&#9670;&nbsp;</a></span>buildRandomBlockMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_block_mat_mul1_d.html">BlockMatMul1D</a> * helib::buildRandomBlockMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40abf9db3a61a5c21c6f836acbeb8c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40abf9db3a61a5c21c6f836acbeb8c80">&#9670;&nbsp;</a></span>buildRandomFullBlockMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_block_mat_mul_full.html">BlockMatMulFull</a> * helib::buildRandomFullBlockMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb1a434a5001c49cfce898915c2faa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1a434a5001c49cfce898915c2faa51">&#9670;&nbsp;</a></span>buildRandomFullMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_mat_mul_full.html">MatMulFull</a> * helib::buildRandomFullMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6dcd30d8cce97ee562725b5c096b464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6dcd30d8cce97ee562725b5c096b464">&#9670;&nbsp;</a></span>buildRandomMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_mat_mul1_d.html">MatMul1D</a> * helib::buildRandomMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f720bf0e8e389648203490dd91630ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f720bf0e8e389648203490dd91630ec">&#9670;&nbsp;</a></span>buildRandomMultiBlockMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_block_mat_mul1_d.html">BlockMatMul1D</a> * helib::buildRandomMultiBlockMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3080cc6971659bc69c9c758f42300cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3080cc6971659bc69c9c758f42300cb9">&#9670;&nbsp;</a></span>buildRandomMultiMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_mat_mul1_d.html">MatMul1D</a> * helib::buildRandomMultiMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1b9141d04abb14f7f9fe94ee4d5c9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b9141d04abb14f7f9fe94ee4d5c9ed">&#9670;&nbsp;</a></span>buildUnpackSlotEncoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::buildUnpackSlotEncoding </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a742ec1357ca244079dacd7c1cb2fcb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742ec1357ca244079dacd7c1cb2fcb90">&#9670;&nbsp;</a></span>calcPolyNormBnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::calcPolyNormBnd </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3afe505ae7315e1226c3fd95f8ea3487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afe505ae7315e1226c3fd95f8ea3487">&#9670;&nbsp;</a></span>calculateMasks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TXT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt;<a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a>&gt; helib::calculateMasks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; TXT &gt;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>database</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a query set and a database, calculates a mask of {0,1} where 1 signifies a matching element and 0 otherwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TXT</td><td>type of the query set. Must be a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> or <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>The encrypted array object holding information about the scheme. </td></tr>
    <tr><td class="paramname">query</td><td>The query set to mask against the database. Must be a row vector of the same dimension as the second dimension of the database matrix. </td></tr>
    <tr><td class="paramname">database</td><td>The matrix holding the encrypted database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated mask. Is the same size as the database. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is an overloaded function for when the database is encrypted. </dd></dl>

</div>
</div>
<a id="ac65801611ad6b47e4cb4c37bf86e5be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65801611ad6b47e4cb4c37bf86e5be5">&#9670;&nbsp;</a></span>calculateMasks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TXT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt;TXT&gt; helib::calculateMasks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; TXT &gt;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>database</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a query set and a database, calculates a mask of {0,1} where 1 signifies a matching element and 0 otherwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TXT</td><td>type of the query set. Must be a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> or <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>The encrypted array object holding information about the scheme. </td></tr>
    <tr><td class="paramname">query</td><td>The query set to mask against the database. Must be a row vector of the same dimension as the second dimension of the database matrix. </td></tr>
    <tr><td class="paramname">database</td><td>The matrix holding the plaintext database. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated mask. Is the same size as the database. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is an overloaded function for when the database is not encrypted. </dd></dl>

</div>
</div>
<a id="a78b9e18a6520b9b54c6adc3096bdaf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b9e18a6520b9b54c6adc3096bdaf87">&#9670;&nbsp;</a></span>calculateScores()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TXT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt;TXT&gt; helib::calculateScores </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; long &gt;&gt;&#160;</td>
          <td class="paramname"><em>index_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; long &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; TXT &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a mask and information about the query to be performed, calculates a score for each matching element signified by the mask. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TXT</td><td>type of the mask matrix. Must be a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> or <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_sets</td><td>The set of indicies signifying which columns of the mask to query. </td></tr>
    <tr><td class="paramname">offsets</td><td>The constant term to be added to the final score of each queried column. </td></tr>
    <tr><td class="paramname">weights</td><td>The weighted importance assigned to each queried column. </td></tr>
    <tr><td class="paramname">mask</td><td>The mask with which to calculate the score from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A single <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code> or <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> containing the total score for each queried column. </dd></dl>

</div>
</div>
<a id="a11746f6a5bcf33d5667cfaae083f3e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11746f6a5bcf33d5667cfaae083f3e35">&#9670;&nbsp;</a></span>calculateSetIntersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TXT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TXT helib::calculateSetIntersection </td>
          <td>(</td>
          <td class="paramtype">const TXT &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>server_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two sets, calculates and returns the set intersection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TXT</td><td>type of the query set. Must be a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> or <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>The query set of type <code>TXT</code> where the elements of the set are held in the slots. </td></tr>
    <tr><td class="paramname">server_set</td><td>The server set. A vector of integer polynomials. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of the same size as <code>query</code> holding the elements in the intersecting set. </dd></dl>

</div>
</div>
<a id="ab2d7f36557c69a4840112f35af186a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d7f36557c69a4840112f35af186a29">&#9670;&nbsp;</a></span>card()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::card </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functional cardinality. </p>

</div>
</div>
<a id="a887b96d1f7918079c15b6fa1d8cbfae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887b96d1f7918079c15b6fa1d8cbfae4">&#9670;&nbsp;</a></span>CheckCtxt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::CheckCtxt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print to cerr some info about ciphertext </p>

</div>
</div>
<a id="ac845c61472e33fa76df608e536b25b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac845c61472e33fa76df608e536b25b5a">&#9670;&nbsp;</a></span>checkNoise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::checkNoise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>thresh</em> = <code>10.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ec3f9852eabd8796caf38d347501acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec3f9852eabd8796caf38d347501acd">&#9670;&nbsp;</a></span>CKKS_canonicalEmbedding() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::CKKS_canonicalEmbedding </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">cx_double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cd57ab6741a87f8b261d0a1417b8c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd57ab6741a87f8b261d0a1417b8c5b">&#9670;&nbsp;</a></span>CKKS_canonicalEmbedding() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::CKKS_canonicalEmbedding </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">cx_double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affe1779765ee918f4c7e869ed86baf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe1779765ee918f4c7e869ed86baf6a">&#9670;&nbsp;</a></span>CKKS_canonicalEmbedding() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::CKKS_canonicalEmbedding </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">cx_double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes canonical embedding. Requires p==-1 and m==2^k where k &gt;=2 and f.length() &lt; m/2. Sets v[m/4-1-i] = DFT[palg.ith_rep(i)] for i in range(m/4), where DFT[j] = f(W^j) for j in range(m), and W = exp(-2*pi*I/m). </p>

</div>
</div>
<a id="a5ec40f00efeb846267027bd14353fe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec40f00efeb846267027bd14353fe4a">&#9670;&nbsp;</a></span>CKKS_embedInSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::CKKS_embedInSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelib.html#a719cb433e43e9f4a88ada8b72d3b715d">cx_double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requires p==-1 and m==2^k where k &gt;=2. Computes the inverse of canonical embedding, scaled by scaling and then rounded to nearest integer. </p>

</div>
</div>
<a id="aaa77bdb78bd529a55c239df60039e335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa77bdb78bd529a55c239df60039e335">&#9670;&nbsp;</a></span>cleanupDebugGlobals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::cleanupDebugGlobals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleanup function for clearing the global debug variables. </p>

</div>
</div>
<a id="ada22455ae91e6bacc49e719536a8c5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada22455ae91e6bacc49e719536a8c5da">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b607a9ca070971badf105209dc47583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b607a9ca070971badf105209dc47583">&#9670;&nbsp;</a></span>closeToOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::closeToOne </td>
          <td>(</td>
          <td class="paramtype">const NTL::xdouble &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f7865779ff5d7047037583852782963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7865779ff5d7047037583852782963">&#9670;&nbsp;</a></span>coeffsL2Norm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NTL::xdouble helib::coeffsL2Norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ae9e83dde78e745c57a36e18fc4372b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae9e83dde78e745c57a36e18fc4372b">&#9670;&nbsp;</a></span>coeffsL2Norm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NTL::xdouble helib::coeffsL2Norm </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52c99506d6fcb0a0f0611a555e77fab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c99506d6fcb0a0f0611a555e77fab3">&#9670;&nbsp;</a></span>coeffsL2Norm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double helib::coeffsL2Norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac39c73d6b51367807eca721bb748aadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39c73d6b51367807eca721bb748aadc">&#9670;&nbsp;</a></span>coeffsL2NormSquared() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::xdouble helib::coeffsL2NormSquared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09fe1adbf8a3a923231957865d6f7ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fe1adbf8a3a923231957865d6f7ade">&#9670;&nbsp;</a></span>coeffsL2NormSquared() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::xdouble helib::coeffsL2NormSquared </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05eeef94d05d407f020712567c5eef27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05eeef94d05d407f020712567c5eef27">&#9670;&nbsp;</a></span>coeffsL2NormSquared() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::coeffsL2NormSquared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The L2-norm of an element (in coefficient representation) </p>

</div>
</div>
<a id="aed4e8a7e6a0c99087b87431d7478e4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4e8a7e6a0c99087b87431d7478e4d6">&#9670;&nbsp;</a></span>comparePAlgebra() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::comparePAlgebra </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>gens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>ords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the palg parameters match the rest, false otherwise </p>

</div>
</div>
<a id="ad733002556086f79ab0153f09916d2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad733002556086f79ab0153f09916d2be">&#9670;&nbsp;</a></span>comparePAlgebra() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::comparePAlgebra </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED unsigned long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>gens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>ords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eda8a61661cec76566fb5c6f475eb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eda8a61661cec76566fb5c6f475eb24">&#9670;&nbsp;</a></span>compareTwoNumbers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::compareTwoNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twosComplement</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two integers in binary <code>a</code>, <code>b</code>. Returns <code>max(a, b)</code>, <code>min(a, b)</code> and indicator bits <code>mu</code>=(<code>a</code>&gt;<code>b</code>) and <code>ni</code>=(<code>a</code>&lt;<code>b</code>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>Maximum of <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramname">min</td><td>Minimum of <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramname">mu</td><td>Indicator bits <code>mu</code>=(<code>a</code>&gt;<code>b</code>). </td></tr>
    <tr><td class="paramname">ni</td><td>Indicator bits <code>ni</code>=(<code>a</code>&lt;<code>b</code>). </td></tr>
    <tr><td class="paramname">a</td><td>First number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>Second number to compare. </td></tr>
    <tr><td class="paramname">twosComplement</td><td>When set to <code>true</code>, the inputs are signed integers in 2's complement. If set to <code>false</code> (default), unsigned comparison is performed. </td></tr>
    <tr><td class="paramname">unpackSlotEncoding</td><td>Vector of constants for unpacking, as used in bootstrapping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>a</code>=<code>b</code> then <code>mu</code>=<code>ni</code>=<code>0</code> </dd></dl>

</div>
</div>
<a id="ad7d423993b1ba7f3a05bb0184d6e5dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d423993b1ba7f3a05bb0184d6e5dd8">&#9670;&nbsp;</a></span>compareTwoNumbers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::compareTwoNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twosComplement</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two integers in binary <code>a</code>, <code>b</code>. Returns only indicator bits <code>mu</code>=(<code>a</code>&gt;<code>b</code>) and <code>ni</code>=(<code>a</code>&lt;<code>b</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu</td><td>Indicator bits <code>mu</code>=(<code>a</code>&gt;<code>b</code>). </td></tr>
    <tr><td class="paramname">ni</td><td>Indicator bits <code>ni</code>=(<code>a</code>&lt;<code>b</code>). </td></tr>
    <tr><td class="paramname">a</td><td>First number to compare. </td></tr>
    <tr><td class="paramname">b</td><td>Second number to compare. </td></tr>
    <tr><td class="paramname">twosComplement</td><td>When set to <code>true</code>, the inputs are signed integers in 2's complement. If set to <code>false</code> (default), unsigned comparison is performed. </td></tr>
    <tr><td class="paramname">unpackSlotEncoding</td><td>Vector of constants for unpacking, as used in bootstrapping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>a</code>=<code>b</code> then <code>mu</code>=<code>ni</code>=<code>0</code> </dd></dl>

</div>
</div>
<a id="aa6a682bb0c0c84f0d6eaddde8fd2f8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a682bb0c0c84f0d6eaddde8fd2f8b9">&#9670;&nbsp;</a></span>compareTwoNumbersImplementation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::compareTwoNumbersImplementation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>aa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twosComplement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cmp_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa13b0418c17fe6b26a2006507d2b57ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13b0418c17fe6b26a2006507d2b57ac">&#9670;&nbsp;</a></span>computeAllProducts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::computeAllProducts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>products</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For an n-size array, compute the 2^n products products[j] = \prod_{i s.t. j_i=1} array[i] \times \prod_{i s.t. j_i=0}(a-array[i]) </p>

</div>
</div>
<a id="a5db58bd9f9ec928c07dc95b2bd2aa26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db58bd9f9ec928c07dc95b2bd2aa26b">&#9670;&nbsp;</a></span>computeDivVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::computeDivVec </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>divVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>powVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abf8bfb70b1212c781ee1c510a2f456cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8bfb70b1212c781ee1c510a2f456cf">&#9670;&nbsp;</a></span>computeIntervalForMul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::computeIntervalForMul </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e5b39e20fa9f25946cbd4f0064c32a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5b39e20fa9f25946cbd4f0064c32a1">&#9670;&nbsp;</a></span>computeIntervalForSqr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::computeIntervalForSqr </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacdc9f121e0356fcc0c2d469126da20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdc9f121e0356fcc0c2d469126da20c">&#9670;&nbsp;</a></span>computeInvVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::computeInvVec </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>invVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>divVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>powVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1c49d134949a4cf5cc7ef6c0ffa1206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c49d134949a4cf5cc7ef6c0ffa1206">&#9670;&nbsp;</a></span>ComputeOneGenMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::ComputeOneGenMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>genMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a22b83b7df1af539c07c804d7888448ce">OneGeneratorTree</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>to a single generator tree </p>

</div>
</div>
<a id="a9837bdade0e2dabb7bbf0d03a5e2e93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9837bdade0e2dabb7bbf0d03a5e2e93b">&#9670;&nbsp;</a></span>computeProd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::computeProd </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns \prod_d vec[d] </p>

</div>
</div>
<a id="aababf76c7325db9e7409cf950a581993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aababf76c7325db9e7409cf950a581993">&#9670;&nbsp;</a></span>computeProd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::computeProd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab31dff00b9bd2df3454c7dc7a7edf16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31dff00b9bd2df3454c7dc7a7edf16b">&#9670;&nbsp;</a></span>concatBinaryNums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::concatBinaryNums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two binary numbers into a single <code>CtPtrs</code> object. E.g. If <code>a=10111</code>, <code>b=00101</code> then <code>output = 1011100101</code>. </p>
<p>Concatenate two binary numbers into a single <code>CtPtrs</code> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Equal to the concatenation of <code>a</code> and <code>b</code>. </td></tr>
    <tr><td class="paramname">a</td><td>First number to copy into <code>output</code>. </td></tr>
    <tr><td class="paramname">b</td><td>Second number to concatenate to <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <code>output</code> must be of size <code>a.size() + b.size()</code>. </dd></dl>

</div>
</div>
<a id="af5a79c25bb9e1285c93b486ce07c4d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a79c25bb9e1285c93b486ce07c4d52">&#9670;&nbsp;</a></span>conv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::conv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f5fe8f0918a6b964a75728b61d15c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5fe8f0918a6b964a75728b61d15c2c">&#9670;&nbsp;</a></span>conv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::conv </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a194a7e93c41b4da649614c39e9a77c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194a7e93c41b4da649614c39e9a77c8f">&#9670;&nbsp;</a></span>convert() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T1 helib::convert </td>
          <td>(</td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a877d5bbaf6ad7ef25042c6711e6a6aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877d5bbaf6ad7ef25042c6711e6a6aa2">&#9670;&nbsp;</a></span>convert() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7d74d8c1673da0da8d2d53a9f56f30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d74d8c1673da0da8d2d53a9f56f30a">&#9670;&nbsp;</a></span>convert() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b9c95cba9d0a0f6f4a8220548276003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9c95cba9d0a0f6f4a8220548276003">&#9670;&nbsp;</a></span>convert() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa20c6011cba88e302d44bb0db4a6e7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20c6011cba88e302d44bb0db4a6e7f8">&#9670;&nbsp;</a></span>convert() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">NTL::mat_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; NTL::ZZX &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a195d039398c66533aa7a1ba455ffcd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195d039398c66533aa7a1ba455ffcd4b">&#9670;&nbsp;</a></span>convert() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1eb539ffd2cd2268861ad793f88f6393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb539ffd2cd2268861ad793f88f6393">&#9670;&nbsp;</a></span>convert() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7508506eab50bf677b80d5dc6669c980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7508506eab50bf677b80d5dc6669c980">&#9670;&nbsp;</a></span>convert() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33593bb6e050f5639138bf3f76a28d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33593bb6e050f5639138bf3f76a28d8c">&#9670;&nbsp;</a></span>convert() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afea2ca2bb25fb996d1d3544a353d83eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea2ca2bb25fb996d1d3544a353d83eb">&#9670;&nbsp;</a></span>convert() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d6406c9fda9c55cde649bc033ad7317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6406c9fda9c55cde649bc033ad7317">&#9670;&nbsp;</a></span>convert() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3ddd5fc2763e981326700c9dcc2e777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ddd5fc2763e981326700c9dcc2e777">&#9670;&nbsp;</a></span>convert() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1ec8745473d116541a8b302dfa70fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ec8745473d116541a8b302dfa70fa9">&#9670;&nbsp;</a></span>convert() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89daf2e69e1e8c09c09311b1430021f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89daf2e69e1e8c09c09311b1430021f4">&#9670;&nbsp;</a></span>convert() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; NTL::ZZX &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::mat_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa59b9ea3393970dcb1c4a9ef6ef310ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59b9ea3393970dcb1c4a9ef6ef310ef">&#9670;&nbsp;</a></span>convert() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trivial type conversion, useful for generic code. </p>

</div>
</div>
<a id="ab5d8cacfd0370294ae07fb571ee2caee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d8cacfd0370294ae07fb571ee2caee">&#9670;&nbsp;</a></span>convert() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59e1e9edc58b546c8d12a4cb56812f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e1e9edc58b546c8d12a4cb56812f81">&#9670;&nbsp;</a></span>convert() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generic vector conversion routines </p>

</div>
</div>
<a id="ab2e47ad408b14cf352174243c3c8adf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e47ad408b14cf352174243c3c8adf6">&#9670;&nbsp;</a></span>convert() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::convert </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A generic template that resolves to NTL's conv routine. </p>

</div>
</div>
<a id="ae05ae4d1e5789165fa5fe70824e87077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05ae4d1e5789165fa5fe70824e87077">&#9670;&nbsp;</a></span>convertDataToSlotVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename From , typename Scheme &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Scheme::SlotType&gt; helib::convertDataToSlotVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; From &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>std::vector&lt;From&gt;</code> to <code>std::vector&lt;Scheme::SlotType&gt;</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">From</td><td>Type of the element in the input vector. </td></tr>
    <tr><td class="paramname">Scheme</td><td>The encryption scheme to be used, must be <code><a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a></code> or <code><a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Vector to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of converted values of type <code>Scheme::SlotType</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only exists for <code><a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a></code> and <code><a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a></code>. </dd></dl>

</div>
</div>
<a id="afcde52d4dcf5f9f26931c54efa401258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcde52d4dcf5f9f26931c54efa401258">&#9670;&nbsp;</a></span>CRTcoeff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::CRTcoeff </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a CRT coefficient: x = (0 mod p, 1 mod q). If symmetric is set then x \in [-pq/2, pq/2), else x \in [0,pq) </p>

</div>
</div>
<a id="a181a74dc451ffc410450d6c238f2a68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181a74dc451ffc410450d6c238f2a68c">&#9670;&nbsp;</a></span>Cyclotomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX helib::Cyclotomic </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute cyclotomic polynomial. </p>

</div>
</div>
<a id="a7d7757fc124c051547f6d8d62f57e6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7757fc124c051547f6d8d62f57e6ee">&#9670;&nbsp;</a></span>decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::decode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37ce1cf83ebb14807ec5fd0ecebd03be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ce1cf83ebb14807ec5fd0ecebd03be">&#9670;&nbsp;</a></span>decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::decode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19a60ea778c6bbcc5d2732ca137c7e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a60ea778c6bbcc5d2732ca137c7e15">&#9670;&nbsp;</a></span>decryptAndCompare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::decryptAndCompare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a436a592900880109024757d11bb3949d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436a592900880109024757d11bb3949d">&#9670;&nbsp;</a></span>decryptAndPrint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::decryptAndPrint </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1285dad7ef04a62fde04003b87ee1110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1285dad7ef04a62fde04003b87ee1110">&#9670;&nbsp;</a></span>decryptBinaryNums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::decryptBinaryNums </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>pNums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>eNums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twosComplement</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allSlots</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt the binary numbers that are encrypted in eNums. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNums</td><td>vector to decrypt the binary numbers into. </td></tr>
    <tr><td class="paramname">eNums</td><td>encrypted binary numbers of which to be decrypted. </td></tr>
    <tr><td class="paramname">sKey</td><td>secret key used for decryption. </td></tr>
    <tr><td class="paramname">ea</td><td>encrypted array that holds necessary information for decryption. </td></tr>
    <tr><td class="paramname">twosComplement</td><td>when set to true, the number to decrypt is a signed integer in 2's complement. </td></tr>
    <tr><td class="paramname">allSlots</td><td>when set to false, return only the sub-cube with index=0 in the last dimension within each ciphertext.</td></tr>
  </table>
  </dd>
</dl>
<p>The bits are encrypted in a bit-sliced manner. Namely, encNums[0] contains the LSB of all the numbers, encNums[1] the next bits from all, etc. If twosComplement==true then the number is interpreted as a signed integer in 2's-complement representation. If allSlots==false then we only return the subcube with index i=0 in the last dimension within each ciphertext. Namely, the bit for the j'th counter is found in slot of index j*sizeOf(lastDim). </p>

</div>
</div>
<a id="aa19a69725c1500ca956f0a89dd7226e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19a69725c1500ca956f0a89dd7226e8">&#9670;&nbsp;</a></span>defaultPmiddle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::defaultPmiddle </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ae485ed628fe5d0b73b7fc80efcfb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae485ed628fe5d0b73b7fc80efcfb36">&#9670;&nbsp;</a></span>defaultQmiddle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::defaultQmiddle </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a511bb2a1c3583d18b858d5362489139c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511bb2a1c3583d18b858d5362489139c">&#9670;&nbsp;</a></span>deserialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Input <code>std::istream</code>. </td></tr>
    <tr><td class="paramname">poly</td><td>Destination <code><a class="el" href="classhelib_1_1_poly_mod.html" title="An object that contains an NTL::ZZX polynomial along with a coefficient modulus p2r and a polynomial ...">PolyMod</a></code> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classhelib_1_1_i_o_error.html" title="Inherits from Exception and std::runtime_error.">IOError</a></td><td>if the stream is badly formatted (i.e. it is not delimited by '[' and ']'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>poly</code> must be constructed with an appropriate p2r and G <b>BEFORE</b> calling this function. For example, <div class="fragment"><div class="line">PolyMod my_poly(p2r, G);</div>
<div class="line"><a class="code" href="namespacehelib.html#aa69f30064b062723cecac335a73fdcdd">deserialize</a>(std::cin, my_poly);</div>
</div><!-- fragment --></dd></dl>
<p>The input stream has to be formatted as a comma-separated list surrounded by '[' and ']'.<br  />
Each element of the list will be deserialized as a coefficient of the polynomial.<br  />
For example '['coef0', 'coef1', 'coef2']' will be deserialized as a <code><a class="el" href="classhelib_1_1_poly_mod.html" title="An object that contains an NTL::ZZX polynomial along with a coefficient modulus p2r and a polynomial ...">PolyMod</a></code> object <code>poly</code> where <code>poly[0]=coef0</code>, <code>poly[1]=coef1</code>, <code>poly[2]=coef2</code> and <code>poly[i]=0</code> for <code>i&gt;2</code>. </p>

</div>
</div>
<a id="a9b41101191111377485d5adf5c4693c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b41101191111377485d5adf5c4693c1">&#9670;&nbsp;</a></span>deserialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scheme &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to deserialize a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;Scheme&gt;</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scheme</td><td>The <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> object scheme. Can be only be <code><a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a></code> or <code><a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Input <code>std::istream</code>. </td></tr>
    <tr><td class="paramname">ptxt</td><td>Destination <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classhelib_1_1_i_o_error.html" title="Inherits from Exception and std::runtime_error.">IOError</a></td><td>if the stream is badly formatted (i.e. it is not delimited by '[' and ']'). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>ptxt</code> must be constructed with an appropriate context <b>BEFORE</b> calling this function. For example, <div class="fragment"><div class="line">Ptxt my_ptxt(context);</div>
<div class="line"><a class="code" href="namespacehelib.html#aa69f30064b062723cecac335a73fdcdd">deserialize</a>(std::cin, my_ptxt);</div>
</div><!-- fragment --></dd></dl>
<p>The input stream has to be formatted as a comma-separated list surrounded by '[' and ']'.<br  />
Each element of the list will be deserialized as a slot of the type determined by the scheme.<br  />
If the number of tokens in the list is less than the number of slots, the remaining slots will be padded by 0.<br  />
For example '['slot0', 'slot1', 'slot2']' will be deserialized as a plaintext <code>ptxt</code> where <code>ptxt[0]=slot0</code>, <code>ptxt[1]=slot1</code>, <code>ptxt[2]=slot2</code> and <code>ptxt[i]=0</code> for <code>i&gt;2</code>. </p>

</div>
</div>
<a id="aa69f30064b062723cecac335a73fdcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69f30064b062723cecac335a73fdcdd">&#9670;&nbsp;</a></span>deserialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::deserialize </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize a <code>std::complex&lt;double&gt;</code> from the input stream <code>is</code> delimited by '[' and ']' (instead of the default '(', ')'). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>The input stream reference. </td></tr>
    <tr><td class="paramname">num</td><td>The complex number to deserialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classhelib_1_1_i_o_error.html" title="Inherits from Exception and std::runtime_error.">IOError</a></td><td>if the stream contains more than 2 parts.</td></tr>
  </table>
  </dd>
</dl>
<p>The input stream has to be formatted as '['number']' (this will be deserialized as (number, 0)) or '['real_part', 'imag_part']' (this will be deserialized as (real_part, imag_part)). </p>

</div>
</div>
<a id="a7935d14fb3f04f52a685e6655d12e613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7935d14fb3f04f52a685e6655d12e613">&#9670;&nbsp;</a></span>deserialize&lt; BGV &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacehelib.html#aa69f30064b062723cecac335a73fdcdd">helib::deserialize</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f0989e95794866905149bd8defaa3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0989e95794866905149bd8defaa3f8">&#9670;&nbsp;</a></span>deserialize&lt; CKKS &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacehelib.html#aa69f30064b062723cecac335a73fdcdd">helib::deserialize</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90b78436c866a0477b9b2957a50bb119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b78436c866a0477b9b2957a50bb119">&#9670;&nbsp;</a></span>DestMulAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::DestMulAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structhelib_1_1_const_multiplier.html">ConstMultiplier</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a593337ace30bc0dd968cae8ed4564b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a593337ace30bc0dd968cae8ed4564b">&#9670;&nbsp;</a></span>disjoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::disjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functional disjoint. </p>

</div>
</div>
<a id="a9965244b44a7884f3e08999f6adec16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9965244b44a7884f3e08999f6adec16f">&#9670;&nbsp;</a></span>div() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::div </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbe210bf717f8ba00aca5995fb479593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe210bf717f8ba00aca5995fb479593">&#9670;&nbsp;</a></span>div() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8ff9e17791a3dd96ca79b2dd4d0654d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ff9e17791a3dd96ca79b2dd4d0654d">&#9670;&nbsp;</a></span>divc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::divc </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns ceiling(a/b); assumes a &gt;=0, b&gt;0, a+b &lt;= MAX_LONG </p>

</div>
</div>
<a id="ae695d0fc0099e58790b874885c563efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae695d0fc0099e58790b874885c563efd">&#9670;&nbsp;</a></span>DoubleCRT::Op&lt; DoubleCRT::AddFun &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a>&amp; helib::DoubleCRT::Op&lt; DoubleCRT::AddFun &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AddFun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>matchIndexSets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab878e7e7e17b6d6caf65e7f289965e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab878e7e7e17b6d6caf65e7f289965e28">&#9670;&nbsp;</a></span>DoubleCRT::Op&lt; DoubleCRT::AddFun &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a>&amp; helib::DoubleCRT::Op&lt; DoubleCRT::AddFun &gt; </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AddFun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad523a1ce005b9562e1574d19f8ce7936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad523a1ce005b9562e1574d19f8ce7936">&#9670;&nbsp;</a></span>DoubleCRT::Op&lt; DoubleCRT::AddFun &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a>&amp; helib::DoubleCRT::Op&lt; DoubleCRT::AddFun &gt; </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AddFun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae75ba76e26d04df9d1a9fca73d3a718b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75ba76e26d04df9d1a9fca73d3a718b">&#9670;&nbsp;</a></span>DoubleCRT::Op&lt; DoubleCRT::MulFun &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a>&amp; helib::DoubleCRT::Op&lt; DoubleCRT::MulFun &gt; </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MulFun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a6290cf4257cb23cf95aa5c354c46e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6290cf4257cb23cf95aa5c354c46e6">&#9670;&nbsp;</a></span>DoubleCRT::Op&lt; DoubleCRT::MulFun &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a>&amp; helib::DoubleCRT::Op&lt; DoubleCRT::MulFun &gt; </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MulFun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3db7c0c4fd741adba512c54bc7c3ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3db7c0c4fd741adba512c54bc7c3ee4">&#9670;&nbsp;</a></span>DoubleCRT::Op&lt; DoubleCRT::SubFun &gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a>&amp; helib::DoubleCRT::Op&lt; DoubleCRT::SubFun &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubFun&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>matchIndexSets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3891679919f78713c9067c3ae9f9ad0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3891679919f78713c9067c3ae9f9ad0c">&#9670;&nbsp;</a></span>DoubleCRT::Op&lt; DoubleCRT::SubFun &gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a>&amp; helib::DoubleCRT::Op&lt; DoubleCRT::SubFun &gt; </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubFun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcba19e19a8aae778a080d8a4833f2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcba19e19a8aae778a080d8a4833f2d1">&#9670;&nbsp;</a></span>DoubleCRT::Op&lt; DoubleCRT::SubFun &gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a>&amp; helib::DoubleCRT::Op&lt; DoubleCRT::SubFun &gt; </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubFun&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc33dc76f8abeaf3557b98dd5a400922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc33dc76f8abeaf3557b98dd5a400922">&#9670;&nbsp;</a></span>EDF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::EDF </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_zz_pX &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a309c3ca72a6d812a3ea23d62e48e42bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309c3ca72a6d812a3ea23d62e48e42bf">&#9670;&nbsp;</a></span>embeddingLargestCoeff() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::xdouble helib::embeddingLargestCoeff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff1d310e2dc35b38b4f87aeaa0e8c73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1d310e2dc35b38b4f87aeaa0e8c73c">&#9670;&nbsp;</a></span>embeddingLargestCoeff() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::xdouble helib::embeddingLargestCoeff </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a9543f301395b419a4026ea72424c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9543f301395b419a4026ea72424c01">&#9670;&nbsp;</a></span>embeddingLargestCoeff() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::embeddingLargestCoeff </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1163a93bce42908b4edfa4e2a2989c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1163a93bce42908b4edfa4e2a2989c49">&#9670;&nbsp;</a></span>embeddingLargestCoeff() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::embeddingLargestCoeff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computing the L-infinity norm of the canonical embedding Assumed: deg(f) &lt; phi(m). </p>

</div>
</div>
<a id="a338704cc219609b1663cc3b5bf1cb631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338704cc219609b1663cc3b5bf1cb631">&#9670;&nbsp;</a></span>embeddingLargestCoeff_x2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::embeddingLargestCoeff_x2 </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>norm1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>norm2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94835a294c90ee0ea0336561c8f38ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94835a294c90ee0ea0336561c8f38ad">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aab8cf8fcdf629a076db0d0206670a7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8cf8fcdf629a076db0d0206670a7c3">&#9670;&nbsp;</a></span>encode() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf08ccbcd03824fa3825640c1b171481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf08ccbcd03824fa3825640c1b171481">&#9670;&nbsp;</a></span>encode() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac40cf1967be4e2bf1b9a63564abe3485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40cf1967be4e2bf1b9a63564abe3485">&#9670;&nbsp;</a></span>encode() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a517b7c650eafd6c9ac20ef4605a4d4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517b7c650eafd6c9ac20ef4605a4d4a1">&#9670;&nbsp;</a></span>encode() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcdd1f22927d282e9bbce15a18f5f3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdd1f22927d282e9bbce15a18f5f3ad">&#9670;&nbsp;</a></span>endBuildModChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::endBuildModChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa271293d5f46187af89cc81ecb0235e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa271293d5f46187af89cc81ecb0235e9">&#9670;&nbsp;</a></span>equals() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae140aabda8f5c9ace67b657134451df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae140aabda8f5c9ace67b657134451df8">&#9670;&nbsp;</a></span>equals() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab2e1e9931564eca3665358957b06cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2e1e9931564eca3665358957b06cd3">&#9670;&nbsp;</a></span>equals() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f9b160771517accfb43d16c5590942c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9b160771517accfb43d16c5590942c">&#9670;&nbsp;</a></span>extendExtractDigits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::extendExtractDigits </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab463f07c91389f56b58bb09da140230d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab463f07c91389f56b58bb09da140230d">&#9670;&nbsp;</a></span>extractDigits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::extractDigits </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortCut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90e48196b014916b26112c02883f64e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e48196b014916b26112c02883f64e3">&#9670;&nbsp;</a></span>extractDigits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::extractDigits </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the mod-p digits of a mod-p^r ciphertext. </p>
<p>extractDigits returns in the slots of digits[j] the j'th-lowest digits from the integers in the slots of the input. Namely, the i'th slot of digits[j] contains the j'th digit in the p-base expansion of the integer in the i'th slot of the *this.</p>
<p>If r==0 then it is set to c.effectiveR(). It is assumed that the slots of *this contains integers mod p^r, i.e., that only the free terms are nonzero. If that assumptions does not hold then the result will not be a valid ciphertext anymore.</p>
<p>The "shortcut" flag is deprecated, it often leads to catastrophic failure in the noise estimate. Calling the function with shortcut=true has not effect, except printing a warning message to cerr.</p>
<p>The output ciphertext digits[j] contains the j'th digit in the base-p expansion of the input, and its plaintext space is modulo p^{r-j}. All the ciphertexts in the output are at the same level. </p>

</div>
</div>
<a id="a4a30217f5c0a87bea091193f7dddddc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a30217f5c0a87bea091193f7dddddc4">&#9670;&nbsp;</a></span>extractDigitsPacked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::extractDigitsPacked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>botHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ePrime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2b1296539466b880a55d12ea9ac6864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b1296539466b880a55d12ea9ac6864">&#9670;&nbsp;</a></span>extractDigitsThin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::extractDigitsThin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>botHigh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ePrime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5b904688ca513ad603df4d470c5ae21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b904688ca513ad603df4d470c5ae21">&#9670;&nbsp;</a></span>extractTokenizeRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::stringstream &gt; helib::extractTokenizeRegion </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>istr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>begin_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>end_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_space</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the input stream <code>istr</code> beyond white spaces. Then split the region delimited by <code>begin_char</code> and <code>end_char</code> at each occurrence of <code>separator</code> that is not contained in an inner <code>begin_char</code> - <code>end_char</code> section. The function returns a <code>std::vector&lt;std::stringstream&gt;</code> with the stream of every section of the input region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">istr</td><td>The stream to be advanced. </td></tr>
    <tr><td class="paramname">begin_char</td><td>The character determining the beginning of the region-of-interest. </td></tr>
    <tr><td class="paramname">end_char</td><td>The character determining the end of the region-of-interest </td></tr>
    <tr><td class="paramname">separator</td><td>The separator character to split at. </td></tr>
    <tr><td class="paramname">skip_space</td><td>Boolean value determining whether to skip spaces when extracting the sub-streams (default = <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::vector&lt;std::stringstream&gt;</code> with the stream of every section of the input region. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classhelib_1_1_i_o_error.html" title="Inherits from Exception and std::runtime_error.">IOError</a></td><td>If the stream is badly formatted (i.e. it does not start with <code>begin_char</code> or it does not end with <code>end_char</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Requires <code>begin_char</code>, <code>end_char</code> and <code>separator</code> to be distinct and different from (space). </dd></dl>

</div>
</div>
<a id="a75dc52f12b0306195238f56bcf4a112b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dc52f12b0306195238f56bcf4a112b">&#9670;&nbsp;</a></span>factorize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::factorize </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; NTL::Pair&lt; long, long &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factoring by trial division, only works for N&lt;2^{60} primes and multiplicities are recorded. </p>

</div>
</div>
<a id="a8d163aa9f73ad476ebd97d7778d79258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d163aa9f73ad476ebd97d7778d79258">&#9670;&nbsp;</a></span>factorize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::factorize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factoring by trial division, only works for N&lt;2^{60}, only the primes are recorded, not their multiplicity. </p>

</div>
</div>
<a id="a0a26515bfdcb0f7e654cefa0d955d4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a26515bfdcb0f7e654cefa0d955d4be">&#9670;&nbsp;</a></span>factorize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::factorize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; NTL::ZZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a028abbe1151a190d5f4ff23bd3a29c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028abbe1151a190d5f4ff23bd3a29c3a">&#9670;&nbsp;</a></span>fastPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::fastPower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af35e417bff539eb8c29da182c8365e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35e417bff539eb8c29da182c8365e41">&#9670;&nbsp;</a></span>fetch_saved_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; * helib::fetch_saved_values </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a635ecc26ac755424a9f834d4eca7d68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635ecc26ac755424a9f834d4eca7d68e">&#9670;&nbsp;</a></span>fifteenOrLess4Four()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::fifteenOrLess4Four </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sizeLimit</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add together up to fifteen {0,1} integers, producing a 4-bit counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>4-bit counter to be outputted. </td></tr>
    <tr><td class="paramname">in</td><td>bits to be counted. </td></tr>
    <tr><td class="paramname">sizeLimit</td><td>number of bits to compute on, taken from the least significant end. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of output bits that are not identically zero (i.e. != null).</dd></dl>
<p>Adding fifteen input bits, getting a 4-bit counter. Some of the input pointers may be null, but output pointers must point to allocated <a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a> objects. If sizeLimit&lt;4, only that many bits are computed (taken from the least significant end). </p><dl class="section note"><dt>Note</dt><dd>This function is currently not thread safe. </dd></dl>

</div>
</div>
<a id="a67f0037687252f6999a8526165cd8e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f0037687252f6999a8526165cd8e41">&#9670;&nbsp;</a></span>findGenerators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::findGenerators </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>gens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>ords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em> = <code>std::vector&lt;long&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns in gens a generating set for Zm* /</p>
<p>, and in ords the order of these generators. Return value is the order of p in Zm*. </p>

</div>
</div>
<a id="abbf9f5de032fca82af2ce94a97041bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf9f5de032fca82af2ce94a97041bc6">&#9670;&nbsp;</a></span>FindM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::FindM </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>chosen_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns smallest parameter m satisfying various constraints: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>security parameter </td></tr>
    <tr><td class="paramname">L</td><td>number of levels </td></tr>
    <tr><td class="paramname">c</td><td>number of columns in key switching matrices </td></tr>
    <tr><td class="paramname">p</td><td>characteristic of plaintext space </td></tr>
    <tr><td class="paramname">d</td><td>embedding degree (d ==0 or d==1 =&gt; no constraint) </td></tr>
    <tr><td class="paramname">s</td><td>at least that many plaintext slots </td></tr>
    <tr><td class="paramname">chosen_m</td><td>preselected value of m (0 =&gt; not preselected) Fails with an error message if no suitable m is found prints an informative message if verbose == true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57538912bfe96e264dab8aac85f0be75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57538912bfe96e264dab8aac85f0be75">&#9670;&nbsp;</a></span>findMinBitCapacity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::findMinBitCapacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ac54132076174cf5388da4f1121f4d417">CtPtrMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f5129e7d3dfa1e3c31cf5df21ae581d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5129e7d3dfa1e3c31cf5df21ae581d">&#9670;&nbsp;</a></span>findMinBitCapacity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::findMinBitCapacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a544c38d5177ea1f1d47d3e204ac1eb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544c38d5177ea1f1d47d3e204ac1eb77">&#9670;&nbsp;</a></span>findMinBitCapacity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::findMinBitCapacity </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> * &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e1f9936cf8c582202702cbb65eaf2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1f9936cf8c582202702cbb65eaf2ce">&#9670;&nbsp;</a></span>FindPrimitiveRoot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::FindPrimitiveRoot </td>
          <td>(</td>
          <td class="paramtype">NTL::zz_p &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find e-th root of unity modulo the current modulus. </p>

</div>
</div>
<a id="ae3ed622332f1680e6384644d3c347e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ed622332f1680e6384644d3c347e19">&#9670;&nbsp;</a></span>FindPrimitiveRoot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::FindPrimitiveRoot </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ_p &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcf094f13d09fba535a0ac173449843f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf094f13d09fba535a0ac173449843f">&#9670;&nbsp;</a></span>FindPrimRootT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename zp , typename zz &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::FindPrimRootT </td>
          <td>(</td>
          <td class="paramtype">zp &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a291c0b1560a80e0cda02f89617fd16d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291c0b1560a80e0cda02f89617fd16d5">&#9670;&nbsp;</a></span>frobeniusAutomorph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::frobeniusAutomorph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab08d6e1c47a1f0b8ed57aff211929548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08d6e1c47a1f0b8ed57aff211929548">&#9670;&nbsp;</a></span>frobeniusAutomorph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::frobeniusAutomorph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0741932e68cabac1a19a68d0a4810bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0741932e68cabac1a19a68d0a4810bf">&#9670;&nbsp;</a></span>FrobeniusMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::zz_pEX helib::FrobeniusMap </td>
          <td>(</td>
          <td class="paramtype">const NTL::zz_pEXModulus &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad92538fab792f75e009a2330c365637d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92538fab792f75e009a2330c365637d">&#9670;&nbsp;</a></span>fsquare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double helib::fsquare </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square of a number as a double. </p>

</div>
</div>
<a id="ac78c4e23cc87c6109c26c3cf86fd1dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78c4e23cc87c6109c26c3cf86fd1dd0">&#9670;&nbsp;</a></span>GenBabySteps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::GenBabySteps </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5711697a702a0f5c4351b3be5644591f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5711697a702a0f5c4351b3be5644591f">&#9670;&nbsp;</a></span>getG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX helib::getG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad24ba24d435ed51afa0737dddfc01bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24ba24d435ed51afa0737dddfc01bb2">&#9670;&nbsp;</a></span>getHyperColumn() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::getHyperColumn </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_const_cube_slice.html">ConstCubeSlice</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb40b60558125630cb15e09a63906c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb40b60558125630cb15e09a63906c2e">&#9670;&nbsp;</a></span>getHyperColumn() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::getHyperColumn </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_const_cube_slice.html">ConstCubeSlice</a>&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab89bc5e58dddac6b2dc64435b98417e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89bc5e58dddac6b2dc64435b98417e1">&#9670;&nbsp;</a></span>getHyperColumn() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::getHyperColumn </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_const_cube_slice.html">ConstCubeSlice</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>getHyperColumn reads out a (multi-dimensional) column from a slice. The parameter pos specifies the position of the column, which must be in the range 0 &lt;= pos &lt; s.getProd(1). The vector v is filled with values whose coordinate in the lower dimensional subcube is equal to pos. The length of v will be set to s.getDim(0). </p>

</div>
</div>
<a id="ab0fdf54d28eb816a5a395b7e1e1efe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fdf54d28eb816a5a395b7e1e1efe51">&#9670;&nbsp;</a></span>getPhimXMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const NTL::zz_pXModulus &amp; helib::getPhimXMod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad19aadcc92555c2f4dbb3b3b34ae6633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19aadcc92555c2f4dbb3b3b34ae6633">&#9670;&nbsp;</a></span>getTimerByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhelib_1_1_f_h_etimer.html">FHEtimer</a> * helib::getTimerByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73d5dae8af9bd253bc591ea37db51a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d5dae8af9bd253bc591ea37db51a58">&#9670;&nbsp;</a></span>GetTimerClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long helib::GetTimerClock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a693b16168065219388722259c6a02c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693b16168065219388722259c6a02c5d">&#9670;&nbsp;</a></span>incrementalProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::incrementalProduct </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For i=n-1...0, set v[i]=prod_{j&lt;=i} v[j] This implementation uses depth log n and (nlog n)/2 products </p>

</div>
</div>
<a id="ab42c58780be6927575c8548d842f47b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42c58780be6927575c8548d842f47b9">&#9670;&nbsp;</a></span>incrementalZeroTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::incrementalZeroTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> *&#160;</td>
          <td class="paramname"><em>res</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1e7877c8a04ea75594a2295518c70d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e7877c8a04ea75594a2295518c70d8">&#9670;&nbsp;</a></span>innerProduct() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> helib::innerProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa738424e1ab49c4f39cbcb3e3e920591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa738424e1ab49c4f39cbcb3e3e920591">&#9670;&nbsp;</a></span>innerProduct() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> helib::innerProduct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0d0484b1e2d0105b7a2b70a3c6dc182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d0484b1e2d0105b7a2b70a3c6dc182">&#9670;&nbsp;</a></span>innerProduct() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> helib::innerProduct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d67040ef7ba12958be263a7a93dac9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d67040ef7ba12958be263a7a93dac9e">&#9670;&nbsp;</a></span>innerProduct() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> helib::innerProduct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a391719dad458fcb9560406cb565f8cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391719dad458fcb9560406cb565f8cbe">&#9670;&nbsp;</a></span>innerProduct() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::innerProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f851f7c167ee39bfc4ceb06d754dcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f851f7c167ee39bfc4ceb06d754dcf0">&#9670;&nbsp;</a></span>innerProduct() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::innerProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb001c145ac75147f598002b33806849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb001c145ac75147f598002b33806849">&#9670;&nbsp;</a></span>innerProduct() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::innerProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inner product of a vectors of ciphertexts and a constant vector. </p>

</div>
</div>
<a id="ab7a60dc124ede5f7baecc0d6c7ab6df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a60dc124ede5f7baecc0d6c7ab6df6">&#9670;&nbsp;</a></span>innerProduct() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::innerProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98d0e8b458fb8f75fa79ff7c7effe58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d0e8b458fb8f75fa79ff7c7effe58e">&#9670;&nbsp;</a></span>innerProduct() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scheme &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::innerProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>first_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>second_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free function that computes the inner product of two vectors of <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The output <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> that will hold the result. </td></tr>
    <tr><td class="paramname">first_vec</td><td>The first input vector of plaintexts. </td></tr>
    <tr><td class="paramname">second_vec</td><td>The second input vector of plaintexts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the two vector sizes differ, the shorter vector will be padded with zeroes. </dd></dl>

</div>
</div>
<a id="a9e7d6d68a0351702ae31c17eb4e72307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7d6d68a0351702ae31c17eb4e72307">&#9670;&nbsp;</a></span>interpolateMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::interpolateMod </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_long &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_long &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>e</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate polynomial such that poly(x[i] mod p)=y[i] (mod p^e) It is assumed that the points x[i] are all distinct modulo p. </p>

</div>
</div>
<a id="a2c41ad906b8626fb07781c8927102b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c41ad906b8626fb07781c8927102b4f">&#9670;&nbsp;</a></span>intVecCRT() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool helib::intVecCRT </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_ZZ &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3781935233076f4d0110d4c7a358ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3781935233076f4d0110d4c7a358ccf">&#9670;&nbsp;</a></span>intVecCRT() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool helib::intVecCRT </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_ZZ &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_long &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dae2334b1ae6358865ee8fd0c6a8fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dae2334b1ae6358865ee8fd0c6a8fc6">&#9670;&nbsp;</a></span>intVecCRT() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template bool helib::intVecCRT </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_ZZ &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_ZZ &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5165f6a4ea9a752c8c40d5790acfb4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5165f6a4ea9a752c8c40d5790acfb4e0">&#9670;&nbsp;</a></span>intVecCRT() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class zzvec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool helib::intVecCRT </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_ZZ &amp;&#160;</td>
          <td class="paramname"><em>vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const zzvec &amp;&#160;</td>
          <td class="paramname"><em>vq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incremental integer CRT for vectors. </p>
<p>Expects co-primes p,q with q odd, and such that all the entries in v1 are in [-p/2,p/2). Returns in v1 the CRT of vp mod p and vq mod q, as integers in [-pq/2, pq/2). Uses the formula: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ CRT(vp,p,vq,q) = vp + [(vq-vp) * p^{-1}]_q * p, \]" src="form_4.png" width="251" height="16"/>
</p>
<p> where [...]_q means reduction to the interval [-q/2,q/2). Notice that if q is odd then this is the same as reducing to [-(q-1)/2,(q-1)/2], which means that [...]_q * p is in [-p(q-1)/2, p(q-1)/2], and since vp is in [-p/2,p/2) then the sum is indeed in [-pq/2,pq/2).</p>
<p>Return true is both vectors are of the same length, false otherwise </p>

</div>
</div>
<a id="a7cac9469e49eec3d2bcd9db31e0122f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cac9469e49eec3d2bcd9db31e0122f1">&#9670;&nbsp;</a></span>InvModpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::InvModpr </td>
          <td>(</td>
          <td class="paramtype">NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57dbaa8bc9cf194a1e08fd5af3497a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dbaa8bc9cf194a1e08fd5af3497a5e">&#9670;&nbsp;</a></span>is2power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::is2power </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1249c9ddf12d285f6c06985342e52562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1249c9ddf12d285f6c06985342e52562">&#9670;&nbsp;</a></span>is_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::is_in </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds whether x is an element of the set X of size sz, Returns -1 it not and the location if true. </p>

</div>
</div>
<a id="aa79a0a06add60a27a1a2198fcf948e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79a0a06add60a27a1a2198fcf948e01">&#9670;&nbsp;</a></span>isDryRun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::isDryRun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac639ce6687180f2ac5e50e8706d79488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac639ce6687180f2ac5e50e8706d79488">&#9670;&nbsp;</a></span>isSetAutomorphVals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::isSetAutomorphVals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff7fd713547b09f8f18fbf95ccf83f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7fd713547b09f8f18fbf95ccf83f95">&#9670;&nbsp;</a></span>isSetAutomorphVals2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::isSetAutomorphVals2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adaf92545afe42e1f4810b40c9e455af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf92545afe42e1f4810b40c9e455af2">&#9670;&nbsp;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::IsZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a002c386c997a1dfb9113bb7a7070d95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002c386c997a1dfb9113bb7a7070d95e">&#9670;&nbsp;</a></span>iterateInterestRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::iterateInterestRegion </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the input stream <code>str</code> beyond white spaces and a single <code>separator</code> in the region-of-interest delimited by <code>begin_char</code> and <code>end_char</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The stream to be advanced. </td></tr>
    <tr><td class="paramname">begin_char</td><td>The character determining the beginning of the region-of-interest (to advance beyond of). </td></tr>
    <tr><td class="paramname">separator</td><td>The separator character to advance beyond of. </td></tr>
    <tr><td class="paramname">end_char</td><td>The character determining the end of the region-of-interest (to advance beyond of). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the region-of-interest is not completed (i.e.: <code>end_char</code> is not reached). <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Throws <code><a class="el" href="classhelib_1_1_runtime_error.html" title="Inherits from Exception and std::runtime_error.">helib::RuntimeError</a></code> if after spaces there is a character different from <code>begin_char</code>, <code>beyond</code>, or <code>end_char</code>. </dd></dl>

</div>
</div>
<a id="a5d98d78d4a4dddc7c6859af409b17e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d98d78d4a4dddc7c6859af409b17e07">&#9670;&nbsp;</a></span>killVec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::killVec </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ca37f043534295ce82c13c09b48325f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca37f043534295ce82c13c09b48325f">&#9670;&nbsp;</a></span>killVec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::killVec </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NTL/std compatibility. </p>

</div>
</div>
<a id="a4fb58a793bef4befd9d75d8852d8fc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb58a793bef4befd9d75d8852d8fc55">&#9670;&nbsp;</a></span>KSGiantStepSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::KSGiantStepSize </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that returns number of baby steps. Used to keep this and matmul routines "in sync". </p>

</div>
</div>
<a id="abe1a3a33c80ba67655fd3cf8e6e66831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1a3a33c80ba67655fd3cf8e6e66831">&#9670;&nbsp;</a></span>largestCoeff() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ helib::largestCoeff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46eaa10d04eed2ee69d9e2c0a52528a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46eaa10d04eed2ee69d9e2c0a52528a7">&#9670;&nbsp;</a></span>largestCoeff() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ helib::largestCoeff </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; NTL::ZZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb4453a3ae42dffc130876e783bea3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4453a3ae42dffc130876e783bea3fe">&#9670;&nbsp;</a></span>largestCoeff() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double helib::largestCoeff </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The L-infinity norm of an element (in coefficient representation) </p>

</div>
</div>
<a id="a1a20a91635cf835f5d24ba9fc0431002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a20a91635cf835f5d24ba9fc0431002">&#9670;&nbsp;</a></span>largestCoeff() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ helib::largestCoeff </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77f80e02dad1c557005618be367c28f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f80e02dad1c557005618be367c28f8">&#9670;&nbsp;</a></span>largestCoeff() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double helib::largestCoeff </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac577a548455a706fa164247e3801e05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac577a548455a706fa164247e3801e05a">&#9670;&nbsp;</a></span>leftBitwiseShift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::leftBitwiseShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>shamt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left shift <code>input</code> by <code>shamt</code>. </p>
<p>Shift binary numbers to the left by <code>shamt</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Shifted result. </td></tr>
    <tr><td class="paramname">input</td><td>The number to be shifted. </td></tr>
    <tr><td class="paramname">shamt</td><td>The number to bits to shift by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a left shift only, i.e. the bits are moved to the most-significant end. </dd>
<dd>
<code>shamt</code> must be positive. </dd>
<dd>
The size of <code>output</code> and <code>input</code> must be the same. </dd></dl>

</div>
</div>
<a id="ac5bd3c856c7b75630a3fee625848debf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bd3c856c7b75630a3fee625848debf">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::length </td>
          <td>(</td>
          <td class="paramtype">GenNodePtr&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a592d23357f47db9beb431daa00b1837b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592d23357f47db9beb431daa00b1837b">&#9670;&nbsp;</a></span>less_than() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::less_than </td>
          <td>(</td>
          <td class="paramtype">const NTL::GF2E &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2E &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a95ea63e91091bd7cae299abf5b60e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a95ea63e91091bd7cae299abf5b60e9">&#9670;&nbsp;</a></span>less_than() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::less_than </td>
          <td>(</td>
          <td class="paramtype">const NTL::GF2EX &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2EX &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acba849e54a054c14527a708b0738735d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba849e54a054c14527a708b0738735d">&#9670;&nbsp;</a></span>less_than() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::less_than </td>
          <td>(</td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade745be425656ca6550b68e91647df4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade745be425656ca6550b68e91647df4d">&#9670;&nbsp;</a></span>less_than() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::less_than </td>
          <td>(</td>
          <td class="paramtype">const NTL::zz_pE &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pE &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58072d3099fe887b7de62dba4b16a337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58072d3099fe887b7de62dba4b16a337">&#9670;&nbsp;</a></span>less_than() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::less_than </td>
          <td>(</td>
          <td class="paramtype">const NTL::zz_pEX &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pEX &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6da437fc5e5b62183567bd8885b5b086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da437fc5e5b62183567bd8885b5b086">&#9670;&nbsp;</a></span>less_than() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::less_than </td>
          <td>(</td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0780cab8a4fd2f230bfcc1822814cf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0780cab8a4fd2f230bfcc1822814cf06">&#9670;&nbsp;</a></span>less_than() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::less_than </td>
          <td>(</td>
          <td class="paramtype">NTL::GF2&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::GF2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a507149d174b7d75b1db57d876791fa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507149d174b7d75b1db57d876791fa93">&#9670;&nbsp;</a></span>less_than() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::less_than </td>
          <td>(</td>
          <td class="paramtype">NTL::zz_p&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::zz_p&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1630d15e5b8352685afcf561db40323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1630d15e5b8352685afcf561db40323">&#9670;&nbsp;</a></span>log2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double helib::log2 </td>
          <td>(</td>
          <td class="paramtype">const NTL::xdouble &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base-2 logarithm. </p>

</div>
</div>
<a id="a07a78ea9ad3d9a0793325a14262965f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a78ea9ad3d9a0793325a14262965f5">&#9670;&nbsp;</a></span>log2_realToEstimatedNoise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::log2_realToEstimatedNoise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0f609e8138ce597457cbf6168d27363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f609e8138ce597457cbf6168d27363">&#9670;&nbsp;</a></span>longToBitVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; long &gt; helib::longToBitVector </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bitSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a number as a vector of bits with LSB on the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Number to be converted. </td></tr>
    <tr><td class="paramname">bitSize</td><td>Number of bits of the input and output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bit vector representation of num. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>bitSize</code> must be non-negative. </dd></dl>

</div>
</div>
<a id="a50cb104179094690467c87a1c09c8a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cb104179094690467c87a1c09c8a05">&#9670;&nbsp;</a></span>lsize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::lsize </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d7c647ab302e0d9844b52884e086071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7c647ab302e0d9844b52884e086071">&#9670;&nbsp;</a></span>lsize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long helib::lsize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhelib_1_1_ptr_matrix.html">PtrMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a368a1406fcc81e32dce3caebda60477b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368a1406fcc81e32dce3caebda60477b">&#9670;&nbsp;</a></span>lsize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long helib::lsize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8f65ef133cee27ad846423d012d5487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f65ef133cee27ad846423d012d5487">&#9670;&nbsp;</a></span>lsize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::lsize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of STL vector as a long (rather than unsigned long) </p>

</div>
</div>
<a id="a454437c5c0e3415fe2a360fa48a3eb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454437c5c0e3415fe2a360fa48a3eb5f">&#9670;&nbsp;</a></span>make_lazy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::make_lazy </td>
          <td>(</td>
          <td class="paramtype">const NTL::Lazy&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This should go in NTL some day... Just call as make_lazy(obj, ...) to initialize a lazy object via a call to a constructor T(...) </p>

</div>
</div>
<a id="a05c7ab380349944791e571afd60e7a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c7ab380349944791e571afd60e7a06">&#9670;&nbsp;</a></span>make_lazy_with_fun()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename F , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::make_lazy_with_fun </td>
          <td>(</td>
          <td class="paramtype">const NTL::Lazy&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This should go in NTL some day... Just call as make_lazy(obj, f, ....) to initialize a lazy object via a call to f(*obj, ...) </p>

</div>
</div>
<a id="adad7e0c1723b324e29278f21aa889143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad7e0c1723b324e29278f21aa889143">&#9670;&nbsp;</a></span>makeIrredPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX helib::makeIrredPoly </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a degree-d irreducible polynomial mod p. </p>

</div>
</div>
<a id="a5b2e968f2faca98f693ac809962242ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2e968f2faca98f693ac809962242ba">&#9670;&nbsp;</a></span>makeQueryExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classhelib_1_1_col_number.html">ColNumber</a>&gt; helib::makeQueryExpr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for creating a shared pointer to a specified column in a query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cl</td><td>The index of the column to be used in the query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the class <code><a class="el" href="classhelib_1_1_col_number.html" title="An object representing a column of a database as an expression which inherits from Expr.">ColNumber</a></code>. </dd></dl>

</div>
</div>
<a id="a6ec750de20965b96fdc12370f8222f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec750de20965b96fdc12370f8222f15">&#9670;&nbsp;</a></span>mapTo01() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::mapTo01 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7e150be3c72dc211544b82bd1250376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e150be3c72dc211544b82bd1250376">&#9670;&nbsp;</a></span>mapTo01() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::mapTo01 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a80f9aef0e58c5e559789b25355c64717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f9aef0e58c5e559789b25355c64717">&#9670;&nbsp;</a></span>mapTo01() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scheme &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::mapTo01 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d0fb010c5631535fe448caabc974860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0fb010c5631535fe448caabc974860">&#9670;&nbsp;</a></span>mapTo01() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::mapTo01 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21a15540439b4c2c57e1e5eb129cd54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a15540439b4c2c57e1e5eb129cd54a">&#9670;&nbsp;</a></span>max_abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double helib::max_abs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a113e6cbc8db288631df5f13330027dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113e6cbc8db288631df5f13330027dc3">&#9670;&nbsp;</a></span>max_abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double helib::max_abs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple routine for computing the max-abs of a vector of complex numbers and real numbers </p>

</div>
</div>
<a id="a5e9f98f558e2fcf0a90b77e74f54958f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9f98f558e2fcf0a90b77e74f54958f">&#9670;&nbsp;</a></span>maximum_flow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::maximum_flow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#af547f7016fc73b7174a2018ea28ef298">FlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove from the graph all the flow-zero edges for (long i=0; i&lt;(long)fg.size(); i++) { FNeighborList::iterator it1=fg[i].begin(); do { FNeighborList::iterator it2 = it1; it1++; // increment the iterator before potentially erasing the edge if (it2-&gt;second.flow == 0) fg[i].erase(it2); } while (it1 != fg[i].end()); }</p>
<p>Remove from the graph all the flow-zero edges for (long i=0; i&lt;(long)fg.size(); i++) { FNeighborList::iterator it1=fg[i].begin(); do { FNeighborList::iterator it2 = it1; it1++; // increment the iterator before potentially erasing the edge if (it2-&gt;second.flow == 0) fg[i].erase(it2); } while (it1 != fg[i].end()); }</p>

</div>
</div>
<a id="a51f60e27cb24d575d4b10a522dbb4279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f60e27cb24d575d4b10a522dbb4279">&#9670;&nbsp;</a></span>mcDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::mcDiv </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f2638750d81a618d59217f3e9b3218a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2638750d81a618d59217f3e9b3218a">&#9670;&nbsp;</a></span>mcMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::mcMod </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines for computing mathematically correct mod and div. </p>
<p>mcDiv(a, b) = floor(a / b), mcMod(a, b) = a - b*mcDiv(a, b); in particular, mcMod(a, b) is 0 or has the same sign as b </p>

</div>
</div>
<a id="ad4d98c1a6634ea3827fafd456ea56a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d98c1a6634ea3827fafd456ea56a5e">&#9670;&nbsp;</a></span>mobius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::mobius </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute mobius function (naive method as n is small). </p>

</div>
</div>
<a id="ad7d7a435e482d03e39e3b592765adc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d7a435e482d03e39e3b592765adc85">&#9670;&nbsp;</a></span>ModComp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::ModComp </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modular composition of polynomials: res = g(h) mod f. </p>

</div>
</div>
<a id="a0cfe07d1b0c2f0e6385f2b6525e0a69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfe07d1b0c2f0e6385f2b6525e0a69b">&#9670;&nbsp;</a></span>mul() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8141de7917e8d05d1a056a45a500615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8141de7917e8d05d1a056a45a500615">&#9670;&nbsp;</a></span>mul() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_block_mat_mul1_d.html">BlockMatMul1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac82ecaab9292facff3375eaf73ba6196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82ecaab9292facff3375eaf73ba6196">&#9670;&nbsp;</a></span>mul() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_block_mat_mul_full.html">BlockMatMulFull</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c4bb86fb8d5306854596862d66e440e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4bb86fb8d5306854596862d66e440e">&#9670;&nbsp;</a></span>mul() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_mat_mul1_d.html">MatMul1D</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22728992014e959480483be6cad9c86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22728992014e959480483be6cad9c86f">&#9670;&nbsp;</a></span>mul() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_mat_mul_full.html">MatMulFull</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50c25069289464e0a2fb8398199fd5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c25069289464e0a2fb8398199fd5ef">&#9670;&nbsp;</a></span>mul() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::mul </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8f88c1ce38bfe194b79c6fff9842e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f88c1ce38bfe194b79c6fff9842e3a">&#9670;&nbsp;</a></span>mul() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a408eff115fb052630554303601257388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408eff115fb052630554303601257388">&#9670;&nbsp;</a></span>MulAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::MulAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structhelib_1_1_const_multiplier.html">ConstMultiplier</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16376b83d0b9ac08d1cc631756741220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16376b83d0b9ac08d1cc631756741220">&#9670;&nbsp;</a></span>MulMod() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX helib::MulMod </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44a8cf8d3d1da74a8060a177e3e49028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a8cf8d3d1da74a8060a177e3e49028">&#9670;&nbsp;</a></span>MulMod() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX helib::MulMod </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7f0968146827a1378c640d201604a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f0968146827a1378c640d201604a02">&#9670;&nbsp;</a></span>MulMod() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> helib::MulMod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af73b2f08337ba65b54609e7bfca96cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73b2f08337ba65b54609e7bfca96cda">&#9670;&nbsp;</a></span>MulMod() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::MulMod </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fc507c5ea1850c348a7c2d743b59a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc507c5ea1850c348a7c2d743b59a57">&#9670;&nbsp;</a></span>MulMod() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::MulMod </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af65e2fcd58de0be9a17f875701fec9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65e2fcd58de0be9a17f875701fec9e3">&#9670;&nbsp;</a></span>MulMod() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::MulMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96fc760be384a17313e24f5383ceabd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fc760be384a17313e24f5383ceabd1">&#9670;&nbsp;</a></span>multOrd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::multOrd </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return multiplicative order of p modulo m, or 0 if GCD(p, m) != 1. </p>

</div>
</div>
<a id="aa9936528f7b1f6865e4a496047caba21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9936528f7b1f6865e4a496047caba21">&#9670;&nbsp;</a></span>multTwoNumbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::multTwoNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>product</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rhsTwosComplement</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sizeLimit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two numbers in binary representation where each ciphertext of the input vector contains a bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">product</td><td>result of the multiplication operation. </td></tr>
    <tr><td class="paramname">lhs</td><td>left hand side of the multiplication. </td></tr>
    <tr><td class="paramname">rhs</td><td>right hand side of the multiplication. </td></tr>
    <tr><td class="paramname">rhsTwosComplement</td><td>flag to state the multiplier is potentially negative. </td></tr>
    <tr><td class="paramname">sizeLimit</td><td>number of bits to compute on, taken from the least significant end. </td></tr>
    <tr><td class="paramname">unpackSlotEncoding</td><td>vector of constants for unpacking, as used in bootstrapping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f6016d5e65b16abb1feba5a82067b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6016d5e65b16abb1feba5a82067b14">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::negate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaff515cbc7e22db14c0b22c910f4cee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff515cbc7e22db14c0b22c910f4cee2">&#9670;&nbsp;</a></span>negateBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::negateBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>negation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negates a number in binary 2's complement representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">negation</td><td>Reference to the negated number that will be populated. </td></tr>
    <tr><td class="paramname">input</td><td>Number to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>input</code> will be treated as a number in 2's complement. </dd>
<dd>
<code>input</code> must not alias negation. </dd></dl>

</div>
</div>
<a id="ac285b2405b33a6bf1d27953c5bb89e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac285b2405b33a6bf1d27953c5bb89e61">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcd34bfd104a104754a69b08d12882a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd34bfd104a104754a69b08d12882a4">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool helib::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_map.html">IndexMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_map.html">IndexMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf1a512fb48fe7d9cfc27c26a727ed6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1a512fb48fe7d9cfc27c26a727ed6f">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> helib::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>intersection </p>

</div>
</div>
<a id="ad1e3d7533fd36aed14028db8a0aec5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e3d7533fd36aed14028db8a0aec5c2">&#9670;&nbsp;</a></span>operator&amp;&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classhelib_1_1_and.html">And</a>&gt; helib::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">QueryExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">QueryExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded operator for creating a shared pointer to an AND expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left operand of the AND expression. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand of the AND expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the class <code><a class="el" href="classhelib_1_1_and.html" title="An object representing the logical AND expression which inherits from Expr.">And</a></code>. </dd></dl>

</div>
</div>
<a id="a741ff01e6d83fef924789f35d31af24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741ff01e6d83fef924789f35d31af24b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , typename std::enable_if_t&lt; std::is_convertible&lt; T, std::size_t &gt;::value &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt; T, 2 &gt; helib::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_tensor.html">Tensor</a>&lt; T2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a426440bf36745c2e46ae9826ca70724c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426440bf36745c2e46ae9826ca70724c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> helib::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2526335487a72bde255cc7a916f9736f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2526335487a72bde255cc7a916f9736f">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a>&amp; helib::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0efa98b2b2f5303eee2c106240c17b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efa98b2b2f5303eee2c106240c17b11">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> helib::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1a8de3a0f340ce6a600fa1da2233191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a8de3a0f340ce6a600fa1da2233191">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a>&amp; helib::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32e627abcebb74bf780514be8d6c744c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e627abcebb74bf780514be8d6c744c">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> helib::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set minus </p>

</div>
</div>
<a id="a70e5cb71e5ab89ad99c81b175ed126cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e5cb71e5ab89ad99c81b175ed126cd">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> helib::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dbb01a7d1b26b95c0abff58d28bdb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbb01a7d1b26b95c0abff58d28bdb0e">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a>&amp; helib::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd46fc7a6f4b03ce4a28aea9e7c0a451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd46fc7a6f4b03ce4a28aea9e7c0a451">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is s1 strict subset of s2. </p>

</div>
</div>
<a id="af8df733be35482f6834a083a9de5e4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8df733be35482f6834a083a9de5e4a6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scheme &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output shift operator. Uses the <code>serialize</code> function internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output <code>std::ostream</code>. </td></tr>
    <tr><td class="paramname">ptxt</td><td><code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> object to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input <code>std::ostream</code> post writing. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> <code>context</code> is not serialized, see note of <code>operator&gt;&gt;</code>.</dd></dl>
<p>The output stream will be formatted as a comma-separated list surrounded by '[' and ']'.<br  />
Each slot of <code>ptxt</code> will be serialized in an element of such list by the <code>serialize</code> function determined by the scheme.<br  />
For example if we have a plaintext <code>ptxt</code> such that <code>ptxt[0]=slot0</code>, <code>ptxt[1]=slot1</code>, <code>ptxt[2]=slot2</code>, and <code>ptxt[i]=0</code> for <code>i&gt;2</code>, it will be serialized as '['slot0', 'slot1', 'slot2', <code>0</code>, <code>0</code> ...]'. </p>

</div>
</div>
<a id="a8e75bdb938a5f96094db55ea323250d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e75bdb938a5f96094db55ea323250d2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output <code>std::ostream</code>. </td></tr>
    <tr><td class="paramname">poly</td><td><code><a class="el" href="classhelib_1_1_poly_mod.html" title="An object that contains an NTL::ZZX polynomial along with a coefficient modulus p2r and a polynomial ...">PolyMod</a></code> object to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input <code>std::ostream</code> post writing. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>p2r and G are not serialized, see note of <code>operator&gt;&gt;</code>.</dd></dl>
<p>The output stream will be formatted as a comma-separated list surrounded by '[' and ']'.<br  />
Each coefficient of <code>poly</code> will be serialized in an element of such list by the <code>&gt;&gt;</code> operator.<br  />
For example if we have a <code><a class="el" href="classhelib_1_1_poly_mod.html" title="An object that contains an NTL::ZZX polynomial along with a coefficient modulus p2r and a polynomial ...">PolyMod</a></code> object <code>poly</code> such that <code>poly[0]=coef0</code>, <code>poly[1]=coef1</code>, <code>poly[2]=coef2</code>, and <code>poly[i]=0</code> for <code>i&gt;2</code>, it will be serialized as '['coef0', 'coef1', 'coef2']'. </p>

</div>
</div>
<a id="a56cf6e939823e9a136817850ea93c1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cf6e939823e9a136817850ea93c1cb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelib_1_1_poly_mod_ring.html">PolyModRing</a> &amp;&#160;</td>
          <td class="paramname"><em>ring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output <code>std::ostream</code>. </td></tr>
    <tr><td class="paramname">ring</td><td><code><a class="el" href="structhelib_1_1_poly_mod_ring.html" title="Lightweight type for describing the structure of a single slot of the plaintext space.">PolyModRing</a></code> object to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input <code>std::ostream</code> post writing. </dd></dl>

</div>
</div>
<a id="ac6b38e2bdf2734a792b5f11fe5f293be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b38e2bdf2734a792b5f11fe5f293be">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_col_perm.html">ColPerm</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d941f20d5c3e55e3b36b36dd5164d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d941f20d5c3e55e3b36b36dd5164d6b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt_part.html">CtxtPart</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55a30d40b8861180c13416755e880749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a30d40b8861180c13416755e880749">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_cube_signature.html">CubeSignature</a> &amp;&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a548b26739f763a0bb78c6ca1eec1a3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548b26739f763a0bb78c6ca1eec1a3d4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_generator_trees.html">GeneratorTrees</a> &amp;&#160;</td>
          <td class="paramname"><em>trees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba72e7396d96094a33df27ad8d11d5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba72e7396d96094a33df27ad8d11d5d0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_moduli_sizes.html">ModuliSizes</a> &amp;&#160;</td>
          <td class="paramname"><em>szs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a546b744efbb3ba1575148bcb9e2ba724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546b744efbb3ba1575148bcb9e2ba724">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16380874c94bf4781b228d986d9882ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16380874c94bf4781b228d986d9882ca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_perm_network.html">PermNetwork</a> &amp;&#160;</td>
          <td class="paramname"><em>net</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5cdfe4d2a5d750a2f2ae0f2d0addabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cdfe4d2a5d750a2f2ae0f2d0addabc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="addc58993c7093dd07d98335bab200e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc58993c7093dd07d98335bab200e82">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_s_k_handle.html">SKHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8794be0244c26078eabc3c5343c86897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8794be0244c26078eabc3c5343c86897">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sub_dimension.html">SubDimension</a> &amp;&#160;</td>
          <td class="paramname"><em>sd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd38c901ef879aa74f5070cdd2b38790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd38c901ef879aa74f5070cdd2b38790">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenNodePtr&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1924de36f81ef4338bb2526dd03bfe97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1924de36f81ef4338bb2526dd03bfe97">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LongNodePtr&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8407900faf89358e471aef0bdb902da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8407900faf89358e471aef0bdb902da8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitNodePtr&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91bd0e83a2e59c7de3a489b5d3fb3aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bd0e83a2e59c7de3a489b5d3fb3aa8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[17/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c8dd31cc08df15a8e5925a06eae00de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8dd31cc08df15a8e5925a06eae00de">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[18/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6e1a9de8dac4a717ec046b76d4d9381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e1a9de8dac4a717ec046b76d4d9381">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[19/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad05fd6e657aa88416b97a48fb5112d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05fd6e657aa88416b97a48fb5112d8a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[20/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c345e01afae95eff45dd95f58fab624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c345e01afae95eff45dd95f58fab624">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[21/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5b3ba4659fee95212891f530d1a88c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b3ba4659fee95212891f530d1a88c1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[22/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_key_switch.html">KeySwitch</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a794976b9b52689a77c7895c58ffd65da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794976b9b52689a77c7895c58ffd65da">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[23/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_pub_key.html">PubKey</a> &amp;&#160;</td>
          <td class="paramname"><em>pk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1777b65a3298c49a20e8554bc70a2cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1777b65a3298c49a20e8554bc70a2cd1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[24/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb431149ad4752359e90a9559196b71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb431149ad4752359e90a9559196b71b">&#9670;&nbsp;</a></span>operator&lt;&lt;&lt;BGV &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::ostream&amp; helib::operator&lt;&lt;&lt;<a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af69b9423e994641a90a8401f74631180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69b9423e994641a90a8401f74631180">&#9670;&nbsp;</a></span>operator&lt;&lt;&lt;CKKS &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::ostream&amp; helib::operator&lt;&lt;&lt;<a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa13e586e5a2a1ea2fd8fe9e3c45b4c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13e586e5a2a1ea2fd8fe9e3c45b4c98">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is s1 subset or equal to s2. </p>

</div>
</div>
<a id="ad5f68b7e6b0ff2bbf68b999655480fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f68b7e6b0ff2bbf68b999655480fac">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool helib::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_map.html">IndexMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_map.html">IndexMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparing maps, by comparing all the elements. </p>

</div>
</div>
<a id="ab7d409fa53b729e5d370d032f643f321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d409fa53b729e5d370d032f643f321">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is s2 strict subset of s1. </p>

</div>
</div>
<a id="abf366cbdad4242e525976c1f8664a3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf366cbdad4242e525976c1f8664a3fc">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4807b29449792c9a8456921063d03c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4807b29449792c9a8456921063d03c91">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is s2 subset or equal to s2. </p>

</div>
</div>
<a id="a3a5af20ad95e41b4f1d072aef127abe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5af20ad95e41b4f1d072aef127abe8">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Input <code>std::istream</code>. </td></tr>
    <tr><td class="paramname">poly</td><td>Destination <code><a class="el" href="classhelib_1_1_poly_mod.html" title="An object that contains an NTL::ZZX polynomial along with a coefficient modulus p2r and a polynomial ...">PolyMod</a></code> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input <code>std::istream</code> post reading. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>poly</code> must be constructed with an appropriate p2r and G <b>BEFORE</b> calling this function. For example, <div class="fragment"><div class="line">PolyMod my_poly(p2r, G);</div>
<div class="line">std::cin &gt;&gt; my_poly;</div>
</div><!-- fragment --></dd></dl>
<p>The input stream has to be formatted as a comma-separated list surrounded by '[' and ']'.<br  />
Each element of the list will be deserialized as a coefficient of the polynomial.<br  />
If the number of tokens in the list is less than the number of coefficients, the higher-degree coefficients will be padded by 0.<br  />
For example '['coef0', 'coef1', 'coef2']' will be deserialized as a <code><a class="el" href="classhelib_1_1_poly_mod.html" title="An object that contains an NTL::ZZX polynomial along with a coefficient modulus p2r and a polynomial ...">PolyMod</a></code> object <code>poly</code> where <code>poly[0]=coef0</code>, <code>poly[1]=coef1</code>, <code>poly[2]=coef2</code> and <code>poly[i]=0</code> for <code>i&gt;2</code>. </p>

</div>
</div>
<a id="abc2e5c3ec63886e4fbb71a7ed16f4a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2e5c3ec63886e4fbb71a7ed16f4a9b">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scheme &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Input shift operator. Uses the <code>deserialize</code> function internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Input <code>std::istream</code>. </td></tr>
    <tr><td class="paramname">ptxt</td><td>Destination <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input <code>std::istream</code> post reading. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>ptxt</code> must be constructed with an appropriate context <b>BEFORE</b> calling this function. For example, <div class="fragment"><div class="line">Ptxt my_ptxt(context);</div>
<div class="line">std::cin &gt;&gt; my_ptxt;</div>
</div><!-- fragment --></dd></dl>
<p>The input stream has to be formatted as a comma-separated list surrounded by '[' and ']'.<br  />
Each element of the list will be deserialized as a slot of the type determined by the scheme.<br  />
If the number of tokens in the list is less than the number of slots, the remaining slots will be padded by 0.<br  />
For example '['slot0', 'slot1', 'slot2']' will be deserialized as a plaintext <code>ptxt</code> where <code>ptxt[0]=slot0</code>, <code>ptxt[1]=slot1</code>, <code>ptxt[2]=slot2</code> and <code>ptxt[i]=0</code> for <code>i&gt;2</code>. </p>

</div>
</div>
<a id="a84b37f68c4bdc42558ad0360b00984fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b37f68c4bdc42558ad0360b00984fb">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt_part.html">CtxtPart</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d6655763e3378a03fc07dca9178ec44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6655763e3378a03fc07dca9178ec44">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_moduli_sizes.html">ModuliSizes</a> &amp;&#160;</td>
          <td class="paramname"><em>szs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6bfd95691bb88ca7ee135b5ad074f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bfd95691bb88ca7ee135b5ad074f4d">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b06418a6494e921dec0c5d086cf46ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b06418a6494e921dec0c5d086cf46ce">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2051c31f2618de7d4cd905020cba5ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2051c31f2618de7d4cd905020cba5ad4">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade316a04cccc9355774eff8e6c013278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade316a04cccc9355774eff8e6c013278">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5ebb5536c5ee682d8490d2eac03f6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ebb5536c5ee682d8490d2eac03f6ef">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83df2fff1dfafef1f94191d2eb7d17e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83df2fff1dfafef1f94191d2eb7d17e4">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97c53db90234d3f191cf4887f2bb8c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c53db90234d3f191cf4887f2bb8c2c">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_pub_key.html">PubKey</a> &amp;&#160;</td>
          <td class="paramname"><em>pk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a658c0331d08e78e757984e06107f75f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658c0331d08e78e757984e06107f75f0">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae22055624d2a4b9a21d1ff101f7eac03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22055624d2a4b9a21d1ff101f7eac03">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; helib::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_s_k_handle.html">SKHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12538d07e5bfd87d5705821d3a6fd72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12538d07e5bfd87d5705821d3a6fd72d">&#9670;&nbsp;</a></span>operator&gt;&gt;&lt;BGV &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::istream&amp; helib::operator&gt;&gt;&lt;<a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26590bae1e4d74412c28dd3abbb24b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26590bae1e4d74412c28dd3abbb24b72">&#9670;&nbsp;</a></span>operator&gt;&gt;&lt;CKKS &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::istream&amp; helib::operator&gt;&gt;&lt;<a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6f7e4e0b2339b3ac2e3b7a761357d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f7e4e0b2339b3ac2e3b7a761357d0c">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> helib::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>exclusive-or </p>

</div>
</div>
<a id="a8172413911da7a2c6f38d9eb34899140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8172413911da7a2c6f38d9eb34899140">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> helib::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_index_set.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>union </p>

</div>
</div>
<a id="a52eacb5c692c3fbf563e88a7ee693fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52eacb5c692c3fbf563e88a7ee693fcf">&#9670;&nbsp;</a></span>operator||()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classhelib_1_1_or.html">Or</a>&gt; helib::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">QueryExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a72bfe799ca2748e0f67e80e799bbcebb">QueryExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded operator for creating a shared pointer to an OR expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left operand of the OR expression. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand of the OR expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the class <code><a class="el" href="classhelib_1_1_or.html" title="An object representing the logical OR expression which inherits from Expr.">Or</a></code>. </dd></dl>

</div>
</div>
<a id="ab80751b68918a0cba13cb9bab3da12ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80751b68918a0cba13cb9bab3da12ed">&#9670;&nbsp;</a></span>optimalBenes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::optimalBenes </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>budget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>good</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LongNodePtr &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a188c595f95739f28a8eaffd5fcc55ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188c595f95739f28a8eaffd5fcc55ffd">&#9670;&nbsp;</a></span>optimalBenesAux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BenesMemoEntry helib::optimalBenesAux </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>budget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nlev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; NTL::Vec&lt; long &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>costTab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BenesMemoTable &amp;&#160;</td>
          <td class="paramname"><em>memoTab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05a4b7e9cb04f6760740db3d4dc3186d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a4b7e9cb04f6760740db3d4dc3186d">&#9670;&nbsp;</a></span>optimalLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LowerMemoEntry helib::optimalLower </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>good</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>budget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LowerMemoTable &amp;&#160;</td>
          <td class="paramname"><em>lowerMemoTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b9b2fbc501abb90f6400679ee15f9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9b2fbc501abb90f6400679ee15f9aa">&#9670;&nbsp;</a></span>optimalUpperAux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UpperMemoEntry helib::optimalUpperAux </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; <a class="el" href="classhelib_1_1_gen_descriptor.html">GenDescriptor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>budget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UpperMemoTable &amp;&#160;</td>
          <td class="paramname"><em>upperMemoTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LowerMemoTable &amp;&#160;</td>
          <td class="paramname"><em>lowerMemoTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8693a4a2d91babebc9b8887bbcd1f0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8693a4a2d91babebc9b8887bbcd1f0ea">&#9670;&nbsp;</a></span>ord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::ord </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the highest power of p that divides N. </p>

</div>
</div>
<a id="a72ce2f6953045411b111ff7ee6f9c2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ce2f6953045411b111ff7ee6f9c2d1">&#9670;&nbsp;</a></span>packConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::packConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae46ff7d24d107f5d26d907d52aea5264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46ff7d24d107f5d26d907d52aea5264">&#9670;&nbsp;</a></span>packConstants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::packConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nbits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7653c8cc828041d87ed9805c35bf0b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7653c8cc828041d87ed9805c35bf0b6f">&#9670;&nbsp;</a></span>packedRecrypt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::packedRecrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#ac54132076174cf5388da4f1121f4d417">CtPtrMat</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unpackConsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>belowLvl</em> = <code>LONG_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea4d00f74735017eb674bc25cca0d47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4d00f74735017eb674bc25cca0d47d">&#9670;&nbsp;</a></span>packedRecrypt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::packedRecrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for packed recryption to recrypt multiple numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first input of which to recrypt. </td></tr>
    <tr><td class="paramname">b</td><td>second input of which to recrypt. </td></tr>
    <tr><td class="paramname">unpackSlotEncoding</td><td>vector of constants for unpacking, as used in bootstrapping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2903cc43702e2dccc9006f6af1da249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2903cc43702e2dccc9006f6af1da249f">&#9670;&nbsp;</a></span>packedRecrypt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::packedRecrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unpackConsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>belowLvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6abd6bae5306a86a4f95fb62fad44c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abd6bae5306a86a4f95fb62fad44c14">&#9670;&nbsp;</a></span>packedRecrypt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::packedRecrypt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>cPtrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unpackConsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4c4516b395810588dc11afabdd11b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c4516b395810588dc11afabdd11b62">&#9670;&nbsp;</a></span>PAlgebraLift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::PAlgebraLift </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>phimx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_zz_pX &amp;&#160;</td>
          <td class="paramname"><em>lfactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::vec_zz_pX &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::vec_zz_pX &amp;&#160;</td>
          <td class="paramname"><em>crtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac531d997cd86bd46ac62c3f7cd5665de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac531d997cd86bd46ac62c3f7cd5665de">&#9670;&nbsp;</a></span>PAlgebraLift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::PAlgebraLift </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>phimx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lfactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>crtc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a527dbcddde6c00dcf8ba8117b9290043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527dbcddde6c00dcf8ba8117b9290043">&#9670;&nbsp;</a></span>partialMatchEncode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a> helib::partialMatchEncode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a value, encode the value across the coefficients of a polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The value of which to encode. </td></tr>
    <tr><td class="paramname">context</td><td>The context object holding information on how to encode the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A polynomial representing the encoded value. </dd></dl>

</div>
</div>
<a id="a93e575c4502d7606d86b46af66600ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e575c4502d7606d86b46af66600ce0">&#9670;&nbsp;</a></span>phi_N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::phi_N </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Phi(N). </p>

</div>
</div>
<a id="add32ec15c61473a42b7136dee8360b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add32ec15c61473a42b7136dee8360b8b">&#9670;&nbsp;</a></span>phiN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::phiN </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>phiN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>facts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Phi(N) and also factorize N. </p>

</div>
</div>
<a id="a62dc0ba06446370515708c0229fa046e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62dc0ba06446370515708c0229fa046e">&#9670;&nbsp;</a></span>phiN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::phiN </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>phiN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; NTL::ZZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>facts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f36286a4ff72a05ddf16c2e5bfaeba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f36286a4ff72a05ddf16c2e5bfaeba5">&#9670;&nbsp;</a></span>plaintextAutomorph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RX , typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::plaintextAutomorph </td>
          <td>(</td>
          <td class="paramtype">RX &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RX &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array_derived.html">EncryptedArrayDerived</a>&lt; type &gt; &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefd5d1a56f7036cae390706fe49e8fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd5d1a56f7036cae390706fe49e8fcb">&#9670;&nbsp;</a></span>plaintextAutomorph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RX , typename RXModulus &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::plaintextAutomorph </td>
          <td>(</td>
          <td class="paramtype">RX &amp;&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RX &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RXModulus &amp;&#160;</td>
          <td class="paramname"><em>PhimX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac405b201e920430c5995a7408e08e99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac405b201e920430c5995a7408e08e99d">&#9670;&nbsp;</a></span>plaintextAutomorph_CKKS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::plaintextAutomorph_CKKS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array_cx.html">EncryptedArrayCx</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab77a93b123ead6eef9e6c899afab897c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77a93b123ead6eef9e6c899afab897c">&#9670;&nbsp;</a></span>poly_comp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool helib::poly_comp </td>
          <td>(</td>
          <td class="paramtype">const RX &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RX &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad15c89ffe2770b53c9484aa56555bc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15c89ffe2770b53c9484aa56555bc3f">&#9670;&nbsp;</a></span>polyEval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::polyEval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an encrypted polynomial on an encrypted input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>to hold the return value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>the degree-d polynomial to evaluate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the point on which to evaluate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a342c01cce2724537976f9ce808e6b8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342c01cce2724537976f9ce808e6b8ec">&#9670;&nbsp;</a></span>polyEval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::polyEval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZX&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a cleartext polynomial on an encrypted input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">res</td><td>to hold the return value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>the degree-d polynomial to evaluate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the point on which to evaluate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>optional optimization parameter, defaults to sqrt(d/2) rounded up or down to a power of two </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11db92e970f97ed66aebb1702dc5a0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11db92e970f97ed66aebb1702dc5a0df">&#9670;&nbsp;</a></span>polyEvalMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::polyEvalMod </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a modular integer polynomial, returns poly(x) mod p. </p>

</div>
</div>
<a id="a7ada257cf26f3f2074300fddf5381f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ada257cf26f3f2074300fddf5381f11">&#9670;&nbsp;</a></span>PolyRed() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::PolyRed </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec8847d93fff429651833026b9553e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8847d93fff429651833026b9553e1b">&#9670;&nbsp;</a></span>PolyRed() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::PolyRed </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd2078641e9787af3d6acbee6d557dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2078641e9787af3d6acbee6d557dad">&#9670;&nbsp;</a></span>PolyRed() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::PolyRed </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae977d2527a20cd02ae18841eea99aa2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae977d2527a20cd02ae18841eea99aa2e">&#9670;&nbsp;</a></span>PolyRed() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::PolyRed </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce all the coefficients of a polynomial modulo q. </p>
<p>When abs=false reduce to interval (-q/2,...,q/2), when abs=true reduce to [0,q). When abs=false and q=2, maintains the same sign as the input. </p>

</div>
</div>
<a id="a83b1a8080de040baddd971b44488ca51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b1a8080de040baddd971b44488ca51">&#9670;&nbsp;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::power </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a407ad6533d4dd3820cc35b07ad41988b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407ad6533d4dd3820cc35b07ad41988b">&#9670;&nbsp;</a></span>pp_factorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::pp_factorize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prime-power factorization. </p>

</div>
</div>
<a id="af35b575565f163995c6abd08972bddf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35b575565f163995c6abd08972bddf2">&#9670;&nbsp;</a></span>ppInvert() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::ppInvert </td>
          <td>(</td>
          <td class="paramtype">NTL::mat_GF2 &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::mat_GF2 &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac46606ccee8c1fe481e3b5a1f90291c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46606ccee8c1fe481e3b5a1f90291c5">&#9670;&nbsp;</a></span>ppInvert() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::ppInvert </td>
          <td>(</td>
          <td class="paramtype">NTL::mat_GF2E &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::mat_GF2E &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a784e87216f278000cfa935b61657da58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784e87216f278000cfa935b61657da58">&#9670;&nbsp;</a></span>ppInvert() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::ppInvert </td>
          <td>(</td>
          <td class="paramtype">NTL::mat_zz_p &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::mat_zz_p &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inverse mod p^r of an n x n matrix. </p>
<p>NTL's current smallint modulus zz_p::modulus() is assumed to be p^r for p prime, r &gt;= 1 integer. For the zz_pE variant also zz_pE::modulus() must be initialized. An error is raised if A is not invertible mod p. </p>

</div>
</div>
<a id="a73a34ea89aec17e40d20d534e210a14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a34ea89aec17e40d20d534e210a14f">&#9670;&nbsp;</a></span>ppInvert() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::ppInvert </td>
          <td>(</td>
          <td class="paramtype">NTL::mat_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::mat_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0faaee69d7f687471cb483dfa78e6701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0faaee69d7f687471cb483dfa78e6701">&#9670;&nbsp;</a></span>ppsolve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::ppsolve </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_GF2E &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::mat_GF2E &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_GF2E &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version for GF2: must have p == 2 and r == 1. </p>

</div>
</div>
<a id="acdb8f2124f5f56970fe7f88802c976b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb8f2124f5f56970fe7f88802c976b1">&#9670;&nbsp;</a></span>ppsolve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::ppsolve </td>
          <td>(</td>
          <td class="paramtype">NTL::vec_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::mat_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_zz_pE &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prime power solver. </p>
<p>A is an n x n matrix, b is a length n (row) vector, this function finds a solution for the matrix-vector equation x A = b. An error is raised if A is not invertible mod p.</p>
<p>NTL's current smallint modulus, zz_p::modulus(), is assumed to be p^r, for p prime, r &gt;= 1 integer. </p>

</div>
</div>
<a id="a9b5c3e6a25c84bcec39b646e10598378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5c3e6a25c84bcec39b646e10598378">&#9670;&nbsp;</a></span>primroot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::primroot </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>phiN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a primitive root modulo N. </p>

</div>
</div>
<a id="a8bdc2438d837bb24ddb0dc0ba0a859cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdc2438d837bb24ddb0dc0ba0a859cc">&#9670;&nbsp;</a></span>print() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b924cfad7a9d34755b6175d88a6a207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b924cfad7a9d34755b6175d88a6a207">&#9670;&nbsp;</a></span>print() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplitNodePtr&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90f4cdaad8d1b3eba56f013ad96e0d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f4cdaad8d1b3eba56f013ad96e0d49">&#9670;&nbsp;</a></span>print3D() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::print3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a518fab30f484391dbbc23fa0ddfdc2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518fab30f484391dbbc23fa0ddfdc2bf">&#9670;&nbsp;</a></span>print3D() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::print3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d24bda05c48a744ffffd08de68736ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d24bda05c48a744ffffd08de68736ed">&#9670;&nbsp;</a></span>print3D() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::print3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_hyper_cube.html">HyperCube</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a14bd686a2e209597f3acecd89f1a3520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bd686a2e209597f3acecd89f1a3520">&#9670;&nbsp;</a></span>print_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::print_stats </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a544a973c30afed0df368cda6e0ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a544a973c30afed0df368cda6e0ad9e">&#9670;&nbsp;</a></span>printAllTimers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::printAllTimers </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>std::cerr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the value of all timers to stream. </p>

</div>
</div>
<a id="a8da295dc142953405e0a3e30509df973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da295dc142953405e0a3e30509df973">&#9670;&nbsp;</a></span>printFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::printFlow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#af547f7016fc73b7174a2018ea28ef298">FlowGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>fg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ffb94ff808c50cb557b7ab67d925453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffb94ff808c50cb557b7ab67d925453">&#9670;&nbsp;</a></span>printMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::printMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a9af476860763122a38ad2ae71ad5b9bc">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0def7d8004a69413ec72c12f1b2bdfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0def7d8004a69413ec72c12f1b2bdfe2">&#9670;&nbsp;</a></span>printNamedTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::printNamedTimer </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7844ba559695a1952e4d6309d21b354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7844ba559695a1952e4d6309d21b354">&#9670;&nbsp;</a></span>printVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VEC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::printVec </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VEC &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nCoeffs</em> = <code>40</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a742bf72a76d5b9389251abfee9223303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742bf72a76d5b9389251abfee9223303">&#9670;&nbsp;</a></span>printZZX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; helib::printZZX </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nCoeffs</em> = <code>40</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab33a07f0cc97da66e279f71195515763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33a07f0cc97da66e279f71195515763">&#9670;&nbsp;</a></span>ptr2nonNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* helib::ptr2nonNull </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; const <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38c7c1b517a8ec41eacfc5c2dba6e293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c7c1b517a8ec41eacfc5c2dba6e293">&#9670;&nbsp;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::random </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa74c29f86e466570325f829fe4ea74b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74c29f86e466570325f829fe4ea74b0">&#9670;&nbsp;</a></span>randomPerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::randomPerm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#ae0769a209e14d5e1bfd8579072397867">Permut</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A random size-n permutation. </p>

</div>
</div>
<a id="afcac17a647635226217c42d858bc155d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcac17a647635226217c42d858bc155d">&#9670;&nbsp;</a></span>randomSlot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scheme &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scheme::SlotType helib::randomSlot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebcaec251bd8b00a025d3868342fbe85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcaec251bd8b00a025d3868342fbe85">&#9670;&nbsp;</a></span>randomSlot&lt; BGV &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelib_1_1_b_g_v.html#a09c79ac9a958d2d2b93c34d89c3ca65b">BGV::SlotType</a> <a class="el" href="namespacehelib.html#afcac17a647635226217c42d858bc155d">helib::randomSlot</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48baf3cc1410cb87bf86a9065dee38a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48baf3cc1410cb87bf86a9065dee38a9">&#9670;&nbsp;</a></span>randomSlot&lt; CKKS &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelib_1_1_c_k_k_s.html#a7c8b6e96117c89f9395b2f1ccdc1e0a0">CKKS::SlotType</a> <a class="el" href="namespacehelib.html#afcac17a647635226217c42d858bc155d">helib::randomSlot</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">UNUSED const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0bcd83ef1650a094f9ba12551a2e9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bcd83ef1650a094f9ba12551a2e9e4">&#9670;&nbsp;</a></span>RandPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX helib::RandPoly </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4c6fd54cca700ce3a8beca19bf0ceaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c6fd54cca700ce3a8beca19bf0ceaa">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1general__range.html">general_range</a>&lt;long&gt; helib::range </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dcff6470686ad80a2319fa1652ac1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcff6470686ad80a2319fa1652ac1e3">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1general__range.html">general_range</a>&lt;long&gt; helib::range </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03f697f7ff3bbb3d9d17f75d35946991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f697f7ff3bbb3d9d17f75d35946991">&#9670;&nbsp;</a></span>rationalApprox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; long, long &gt; helib::rationalApprox </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>denomBound</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a564d4348157a8775888f09a680313ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564d4348157a8775888f09a680313ba6">&#9670;&nbsp;</a></span>rationalApprox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; NTL::ZZ, NTL::ZZ &gt; helib::rationalApprox </td>
          <td>(</td>
          <td class="paramtype">NTL::xdouble&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::xdouble&#160;</td>
          <td class="paramname"><em>denomBound</em> = <code>NTL::xdouble(0.0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50b26a9740fbaba1c3b7b5c7e89ee55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b26a9740fbaba1c3b7b5c7e89ee55c">&#9670;&nbsp;</a></span>rawDecrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::rawDecrypt </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>plaintxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; NTL::ZZX &gt; &amp;&#160;</td>
          <td class="paramname"><em>zzParts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>sKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5197bb5b6cad37f9d4a4a7c7e7bf8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5197bb5b6cad37f9d4a4a7c7e7bf8d0">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5ff4e18ef29f688fc071601becaafef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ff4e18ef29f688fc071601becaafef">&#9670;&nbsp;</a></span>read_ntl_vec_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::read_ntl_vec_long </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::vec_long &amp;&#160;</td>
          <td class="paramname"><em>vl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1c396577dc7ac07293effb9e8e20364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c396577dc7ac07293effb9e8e20364">&#9670;&nbsp;</a></span>read_raw_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::read_raw_double </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab66308212a98df1821b9bf48c5713bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66308212a98df1821b9bf48c5713bd2">&#9670;&nbsp;</a></span>read_raw_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::read_raw_int </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a529e6135abd723e5eeb63a156224e39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529e6135abd723e5eeb63a156224e39a">&#9670;&nbsp;</a></span>read_raw_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int helib::read_raw_int32 </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa0e61f1c81f568bd942e3f50b4c5301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0e61f1c81f568bd942e3f50b4c5301">&#9670;&nbsp;</a></span>read_raw_vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::read_raw_vector </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03a42dc495a369c587d7bfe577a1fc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a42dc495a369c587d7bfe577a1fc29">&#9670;&nbsp;</a></span>read_raw_vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::read_raw_vector </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e907022dc0cd7bdf40f457b786ab924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e907022dc0cd7bdf40f457b786ab924">&#9670;&nbsp;</a></span>read_raw_vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::read_raw_vector </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a591c5643829af4b3738d1e6cc807518e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591c5643829af4b3738d1e6cc807518e">&#9670;&nbsp;</a></span>read_raw_vector&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehelib.html#a9e907022dc0cd7bdf40f457b786ab924">helib::read_raw_vector</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f201a18aa3be048c7935a97c1bd4e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f201a18aa3be048c7935a97c1bd4e82">&#9670;&nbsp;</a></span>read_raw_vector&lt; long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehelib.html#a9e907022dc0cd7bdf40f457b786ab924">helib::read_raw_vector</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad981561d84bb94d22a6c5c3e1619806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad981561d84bb94d22a6c5c3e1619806">&#9670;&nbsp;</a></span>read_raw_xdouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::xdouble helib::read_raw_xdouble </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfd83ed995cf19419ab46fa84b2711a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd83ed995cf19419ab46fa84b2711a7">&#9670;&nbsp;</a></span>read_raw_ZZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::read_raw_ZZ </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7b88eb3fd0aa4821cb6700fa65ecee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b88eb3fd0aa4821cb6700fa65ecee2">&#9670;&nbsp;</a></span>readContextBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::readContextBase </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>gens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>ords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read [m p r gens ords] data, needed to construct context </p>
<p>read [m p r] data, needed to construct context </p>

</div>
</div>
<a id="acb88b203e4e9aeaf5fe329e7cc276aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb88b203e4e9aeaf5fe329e7cc276aad">&#9670;&nbsp;</a></span>readContextBaseBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::readContextBaseBinary </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>gens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>ords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read [m p r gens ords] data, needed to construct context </p>

</div>
</div>
<a id="a4a07fadbe58c0bf5c4be26d9bb245755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a07fadbe58c0bf5c4be26d9bb245755">&#9670;&nbsp;</a></span>readContextBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::readContextBinary </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e0de63e6a004056417fc6532985ce6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0de63e6a004056417fc6532985ce6f">&#9670;&nbsp;</a></span>readEyeCatcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int helib::readEyeCatcher </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc9656603a03fba1b8720db0d2e5cee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9656603a03fba1b8720db0d2e5cee9">&#9670;&nbsp;</a></span>readPubKeyBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::readPubKeyBinary </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_pub_key.html">PubKey</a> &amp;&#160;</td>
          <td class="paramname"><em>pk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69b0297bb0e296d5dc39bb328d735007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b0297bb0e296d5dc39bb328d735007">&#9670;&nbsp;</a></span>readSecKeyBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::readSecKeyBinary </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb2f4d4c24b1b5926fc02206f9b5db6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2f4d4c24b1b5926fc02206f9b5db6a">&#9670;&nbsp;</a></span>realToEstimatedNoise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::realToEstimatedNoise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b0cf6b325974c5fb87c29686d82e414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0cf6b325974c5fb87c29686d82e414">&#9670;&nbsp;</a></span>recordAutomorphVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::recordAutomorphVal </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a479ecb7208f177739fa83913e8515192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479ecb7208f177739fa83913e8515192">&#9670;&nbsp;</a></span>recordAutomorphVal2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::recordAutomorphVal2 </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e4662264ee1fcd34eb7ff13d6bbf008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4662264ee1fcd34eb7ff13d6bbf008">&#9670;&nbsp;</a></span>reducedCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::reducedCount </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7afc81441c478d7cd4749a69cbccc984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afc81441c478d7cd4749a69cbccc984">&#9670;&nbsp;</a></span>reduceModPhimX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::reduceModPhimX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_p_algebra.html">PAlgebra</a> &amp;&#160;</td>
          <td class="paramname"><em>palg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7957fca02eb250ab71f07ae1e03f4f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7957fca02eb250ab71f07ae1e03f4f5c">&#9670;&nbsp;</a></span>registerTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::registerTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_f_h_etimer.html">FHEtimer</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99839e8493aba44c6de4085217a4edc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99839e8493aba44c6de4085217a4edc6">&#9670;&nbsp;</a></span>RelaxedInv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::RelaxedInv </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::GF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Mat&lt; NTL::GF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d5bff694c1cfdb4a55a02f01aa27ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5bff694c1cfdb4a55a02f01aa27ce7">&#9670;&nbsp;</a></span>RelaxedInv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::RelaxedInv </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Mat&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7b15d5fbf553550437df6ca02d5a282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b15d5fbf553550437df6ca02d5a282">&#9670;&nbsp;</a></span>rem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::rem </td>
          <td>(</td>
          <td class="paramtype">NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1zz__p_x_modulus1.html">zz_pXModulus1</a> &amp;&#160;</td>
          <td class="paramname"><em>ff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a048eb699c3e26a99ac2198bcc984ac75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048eb699c3e26a99ac2198bcc984ac75">&#9670;&nbsp;</a></span>removeDups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::removeDups </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa43f61b11865cfa98e7999d1027cdd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43f61b11865cfa98e7999d1027cdd37">&#9670;&nbsp;</a></span>repack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::repack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>unpacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52373565df70e730f9b11263a5c4434f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52373565df70e730f9b11263a5c4434f">&#9670;&nbsp;</a></span>repack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::repack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>unpacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae14f023af8c881464a3dbaf01b18d7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14f023af8c881464a3dbaf01b18d7da">&#9670;&nbsp;</a></span>replicate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scheme &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::replicate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replicate single slot of a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> object across all of its slots. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scheme</td><td>Encryption scheme used (must be <code><a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a></code> or <code><a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a></code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptxt</td><td>Plaintext on which to do the replication. </td></tr>
    <tr><td class="paramname">i</td><td>Position of the slot to replicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code> post replication. </dd></dl>

</div>
</div>
<a id="a28bebe2d214c86938103f34adecb7ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bebe2d214c86938103f34adecb7ff3">&#9670;&nbsp;</a></span>replicate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::replicate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value in slot #pos is replicated in all other slots. On an n-slot ciphertext, this algorithm performs O(log n) 1D rotations. </p>

</div>
</div>
<a id="a2c6d6a64a8c538bb0189ac908896ac6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6d6a64a8c538bb0189ac908896ac6c">&#9670;&nbsp;</a></span>replicate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::replicate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb07910b30bab32f4ebf91af705e3c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb07910b30bab32f4ebf91af705e3c6d">&#9670;&nbsp;</a></span>replicate0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::replicate0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A lower-level routine. Same as replicate, but assumes all slots are zero except slot #pos. </p>

</div>
</div>
<a id="a55f84fcea62365a27445739f444d81db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f84fcea62365a27445739f444d81db">&#9670;&nbsp;</a></span>replicateAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::replicateAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_replicate_handler.html">ReplicateHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>recBound</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RepAuxDim *&#160;</td>
          <td class="paramname"><em>repAuxPtr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>replicateAll uses a hybrid strategy, combining the O(log n) strategy of the replicate method, with an O(1) strategy, which is faster but introduces more noise. This tradeoff is controlled by the parameter recBound:</p>
<ul>
<li>recBound &lt; 0: recursion to depth |recBound| (faster, noisier) </li>
<li>recBound ==0: no recursion (slower, less noise) </li>
<li>recBound &gt; 0: the recursion depth is chosen heuristically, but is capped at recBound</li>
</ul>
<p>The default value for recBound is 64, this ensures that the choice is based only on the heuristic, which will introduce noise corresponding to O(log log n) levels of recursion, but still gives an algorithm that theoretically runs in time O(n). </p>

</div>
</div>
<a id="ab0a2f3a3e50d07abc0a16161003fc0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a2f3a3e50d07abc0a16161003fc0b5">&#9670;&nbsp;</a></span>replicateAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::replicateAll </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>recBound</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RepAuxDim *&#160;</td>
          <td class="paramname"><em>repAuxPtr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the result as a std::vector of ciphertexts, mostly useful for debugging purposes (for real parameters would take a lot of memory) </p>

</div>
</div>
<a id="a80787c8857d1d8b8b4fad63f11201626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80787c8857d1d8b8b4fad63f11201626">&#9670;&nbsp;</a></span>replicateAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scheme &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::replicateAll </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a vector of plaintexts with each slot replicated in each plaintext. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scheme</td><td>Encryption scheme used (must be <code><a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a></code> or <code><a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a></code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector of replicated plaintext slots. </td></tr>
    <tr><td class="paramname">ptxt</td><td>Plaintext whose slots will be replicated.</td></tr>
  </table>
  </dd>
</dl>
<p>The order of the return vector agrees with the order of the slots. i.e. the <code>i</code>th plaintext in the return value is a replication of <code>*this[i]</code>. </p>

</div>
</div>
<a id="ae12fb4b6143d8e2cb6a5dbf36922fbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12fb4b6143d8e2cb6a5dbf36922fbe7">&#9670;&nbsp;</a></span>replicateAllOrig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::replicateAllOrig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_replicate_handler.html">ReplicateHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RepAux *&#160;</td>
          <td class="paramname"><em>repAuxPtr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is obsolete, and is kept for historical purposes only. It was a first attempt at implementing the O(1)-amortized algorithm, but is less efficient than the function above. </p>

</div>
</div>
<a id="a3203575203906fc8b66bef7fe7a577cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3203575203906fc8b66bef7fe7a577cd">&#9670;&nbsp;</a></span>resetAllTimers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::resetAllTimers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49b481e5ebaa9bc469124e7c2d5eae38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b481e5ebaa9bc469124e7c2d5eae38">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::resize </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad61eac49543dd3559b386f94ca7112c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61eac49543dd3559b386f94ca7112c9">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::resize </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65519409bc5c0f7c328147d8664ce5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65519409bc5c0f7c328147d8664ce5fb">&#9670;&nbsp;</a></span>resize() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhelib_1_1_ptr_matrix.html">PtrMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a810f01874466a0f57b41f96b8cb7a96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810f01874466a0f57b41f96b8cb7a96c">&#9670;&nbsp;</a></span>resize() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a1574e2c95b30b1eb204d669f029368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1574e2c95b30b1eb204d669f029368">&#9670;&nbsp;</a></span>resize() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91e17a6dd739205036bdc410372608cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e17a6dd739205036bdc410372608cc">&#9670;&nbsp;</a></span>resize() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::resize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8aea4186c17622aa24763219ba2e39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8aea4186c17622aa24763219ba2e39c">&#9670;&nbsp;</a></span>resize() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::resize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dfd59b19280a7a98989bbc0dd6a8c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfd59b19280a7a98989bbc0dd6a8c2c">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::reverse </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse a vector in place. </p>

</div>
</div>
<a id="a1f74d875dc046b81eef94c8f091e5c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f74d875dc046b81eef94c8f091e5c09">&#9670;&nbsp;</a></span>RLWE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::RLWE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZ *&#160;</td>
          <td class="paramname"><em>prgSeed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose random c0,c1 such that c0+s*c1 = p*e for a short e Returns a high-probability bound on the L-infty norm of the canonical embedding </p>

</div>
</div>
<a id="a4349e62cf946950025929996328abf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4349e62cf946950025929996328abf7c">&#9670;&nbsp;</a></span>RLWE1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::RLWE1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as RLWE, but assumes that c1 is already chosen by the caller. </p>

</div>
</div>
<a id="a34783d4707b52b8cb0341187d50f8265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34783d4707b52b8cb0341187d50f8265">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1688528ff1a377be38502ae7c048336c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1688528ff1a377be38502ae7c048336c">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::rotate </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate a vector in place using swaps. </p>

</div>
</div>
<a id="a55aba5934157b9d7517101534a0053a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55aba5934157b9d7517101534a0053a2">&#9670;&nbsp;</a></span>runningSums() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::runningSums </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A ctxt that encrypts <img class="formulaInl" alt="$(x_1, ..., x_n)$" src="form_0.png" width="56" height="14"/> is replaced by an encryption of <img class="formulaInl" alt="$(y_1, ..., y_n)$" src="form_1.png" width="55" height="14"/>, where <img class="formulaInl" alt="$y_i = sum_{j\le i} x_j$" src="form_2.png" width="80" height="10"/>. </p>

</div>
</div>
<a id="a3ec4c5776cc1a48bb6d6a3ae4e64a4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec4c5776cc1a48bb6d6a3ae4e64a4b7">&#9670;&nbsp;</a></span>runningSums() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::runningSums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dac9d465c144cdd7f736730704c38e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dac9d465c144cdd7f736730704c38e6">&#9670;&nbsp;</a></span>sameObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool helib::sameObject </td>
          <td>(</td>
          <td class="paramtype">const T1 *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Testing if two vectors point to the same object. </p>

</div>
</div>
<a id="a6d1e9c8e38d8a8f73b315b2cf874cebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1e9c8e38d8a8f73b315b2cf874cebe">&#9670;&nbsp;</a></span>sampleGaussian() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sampleGaussian </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adccfccbd4c008360cc40afa2fa8bc3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccfccbd4c008360cc40afa2fa8bc3ad">&#9670;&nbsp;</a></span>sampleGaussian() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sampleGaussian </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose a vector of continuous Gaussians. </p>

</div>
</div>
<a id="a1d8ea79ceef3847786a1f9422fc011e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8ea79ceef3847786a1f9422fc011e7">&#9670;&nbsp;</a></span>sampleGaussian() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::sampleGaussian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ca8304d01fccbbac9264eee5d5a24cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca8304d01fccbbac9264eee5d5a24cb">&#9670;&nbsp;</a></span>sampleGaussian() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sampleGaussian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample polynomials with Gaussian coefficients. </p>

</div>
</div>
<a id="abc2cb417d4cb136fe2f25fea08aaff16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2cb417d4cb136fe2f25fea08aaff16">&#9670;&nbsp;</a></span>sampleGaussianBounded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::sampleGaussianBounded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa510a5dd7033e859ab4e6759a1b1b207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa510a5dd7033e859ab4e6759a1b1b207">&#9670;&nbsp;</a></span>sampleHWt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sampleHWt </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Hwt</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af97518f36b0358f1f178ce85e51c5d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97518f36b0358f1f178ce85e51c5d82">&#9670;&nbsp;</a></span>sampleHWt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::sampleHWt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Hwt</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cebf12977a97396ba96bdc5fe8162e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cebf12977a97396ba96bdc5fe8162e7">&#9670;&nbsp;</a></span>sampleHWt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sampleHWt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Hwt</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample a degree-(n-1) poly as above, with only Hwt nonzero coefficients. </p>

</div>
</div>
<a id="ae703021ed961c9a45e32d09c4b965781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae703021ed961c9a45e32d09c4b965781">&#9670;&nbsp;</a></span>sampleHWtBounded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::sampleHWtBounded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Hwt</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e75ae20952ceae0b4e92034d7128457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e75ae20952ceae0b4e92034d7128457">&#9670;&nbsp;</a></span>sampleHWtBoundedEffectiveBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::sampleHWtBoundedEffectiveBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Hwt</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7aab1a9871644fc36223b8009290ef66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aab1a9871644fc36223b8009290ef66">&#9670;&nbsp;</a></span>sampleSmall() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sampleSmall </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa20a241c380919c47e8375ac01d61187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20a241c380919c47e8375ac01d61187">&#9670;&nbsp;</a></span>sampleSmall() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::sampleSmall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc5ec6f6ac945f2c5bcdf04fb7bcf0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5ec6f6ac945f2c5bcdf04fb7bcf0a9">&#9670;&nbsp;</a></span>sampleSmall() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sampleSmall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sample a degree-(n-1) poly, with -1/0/+1 coefficients. Each coefficients is +-1 with probability prob/2 each, and 0 with probability 1-prob. By default, pr[nonzero]=1/2. </p>

</div>
</div>
<a id="a50866077cb1daad6200cd8b374613539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50866077cb1daad6200cd8b374613539">&#9670;&nbsp;</a></span>sampleSmallBounded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::sampleSmallBounded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c90da3ab82439eb3574afc268f88050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c90da3ab82439eb3574afc268f88050">&#9670;&nbsp;</a></span>sampleUniform() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::xdouble helib::sampleUniform </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>B</em> = <code>NTL::ZZ(100L)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2882109801afa606ee6ec39f6fd48348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2882109801afa606ee6ec39f6fd48348">&#9670;&nbsp;</a></span>sampleUniform() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sampleUniform </td>
          <td>(</td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>B</em> = <code>NTL::ZZ(100L)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa21875fc9b1d3c8dad59e1c3f66f0718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21875fc9b1d3c8dad59e1c3f66f0718">&#9670;&nbsp;</a></span>sampleUniform() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double helib::sampleUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>B</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b922617fd57c98218c1eada9ffb9cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b922617fd57c98218c1eada9ffb9cb5">&#9670;&nbsp;</a></span>sampleUniform() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sampleUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>B</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample a degree-(n-1) ZZX, with coefficients uniform in [-B,B]. </p>

</div>
</div>
<a id="a0df3789de0744e7c90d5a5d6cf54a5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df3789de0744e7c90d5a5d6cf54a5ed">&#9670;&nbsp;</a></span>seekPastChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::seekPastChar </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the input stream beyond white spaces and a single instance of the char cc. </p>

</div>
</div>
<a id="a1784c6548249c484976efcf52a0416d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1784c6548249c484976efcf52a0416d7">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_poly_mod.html">PolyMod</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output <code>std::ostream</code>. </td></tr>
    <tr><td class="paramname">poly</td><td><code><a class="el" href="classhelib_1_1_poly_mod.html" title="An object that contains an NTL::ZZX polynomial along with a coefficient modulus p2r and a polynomial ...">PolyMod</a></code> object to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input <code>std::ostream</code> post writing. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>p2r and G are not serialized, see note of <code>deserialize</code>.</dd></dl>
<p>The output stream will be formatted as a comma-separated list surrounded by '[' and ']'.<br  />
Each coefficient of <code>poly</code> will be serialized in an element of such list by the <code>&gt;&gt;</code> operator.<br  />
For example if we have a <code><a class="el" href="classhelib_1_1_poly_mod.html" title="An object that contains an NTL::ZZX polynomial along with a coefficient modulus p2r and a polynomial ...">PolyMod</a></code> object <code>poly</code> such that <code>poly[0]=coef0</code>, <code>poly[1]=coef1</code>, <code>poly[2]=coef2</code>, and <code>poly[i]=0</code> for <code>i&gt;2</code>, it will be serialized as '['coef0', 'coef1', 'coef2']'. </p>

</div>
</div>
<a id="ab41ed1eb42cb018a129e7cb2fbbb29ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41ed1eb42cb018a129e7cb2fbbb29ff">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scheme &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; Scheme &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to serialize a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;Scheme&gt;</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scheme</td><td>The <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> object scheme. Can be only be <code><a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a></code> or <code><a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output <code>std::ostream</code>. </td></tr>
    <tr><td class="paramname">ptxt</td><td><code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> object to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input <code>std::ostream</code> post serializing. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a></code> <code>context</code> is not serialized, see note of <code>deserialize</code>.</dd></dl>
<p>The output stream will be formatted as a comma-separated list surrounded by '[' and ']'.<br  />
Each slot of <code>ptxt</code> will be serialized in an element of such list by the <code>serialize</code> function determined by the scheme.<br  />
For example if we have a plaintext <code>ptxt</code> such that <code>ptxt[0]=slot0</code>, <code>ptxt[1]=slot1</code>, <code>ptxt[2]=slot2</code>, and <code>ptxt[i]=0</code> for <code>i&gt;2</code>, it will be serialized as '['slot0', 'slot1', 'slot2', <code>0</code>, <code>0</code> ...]'. </p>

</div>
</div>
<a id="adcb4ae8ef54886b93b4639999a620630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb4ae8ef54886b93b4639999a620630">&#9670;&nbsp;</a></span>serialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize a <code>std::complex&lt;double&gt;</code> to the output stream <code>os</code> delimited by '[' and ']' (instead of the default '(', ')'). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream reference. </td></tr>
    <tr><td class="paramname">num</td><td>The complex number to serialize.</td></tr>
  </table>
  </dd>
</dl>
<p>The output will be formatted as '['<code>num.real()</code>', '<code>num.imag()</code>']'. </p>

</div>
</div>
<a id="ad6f0ba91399ca673009e2d72a2c5db8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f0ba91399ca673009e2d72a2c5db8f">&#9670;&nbsp;</a></span>serialize&lt; BGV &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacehelib.html#adcb4ae8ef54886b93b4639999a620630">helib::serialize</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3acb5806f04e3ec63ebef2f1b64fac03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acb5806f04e3ec63ebef2f1b64fac03">&#9670;&nbsp;</a></span>serialize&lt; CKKS &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacehelib.html#adcb4ae8ef54886b93b4639999a620630">helib::serialize</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ce92a7a0f311e90d9022ea931a671ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce92a7a0f311e90d9022ea931a671ec">&#9670;&nbsp;</a></span>setAutomorphVals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::setAutomorphVals </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; long &gt; *&#160;</td>
          <td class="paramname"><em>aVals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fab1809e50aa6fc8c0f80e66943f490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fab1809e50aa6fc8c0f80e66943f490">&#9670;&nbsp;</a></span>setAutomorphVals2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::setAutomorphVals2 </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; long &gt; *&#160;</td>
          <td class="paramname"><em>aVals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8f51eef1d124d7e046b6a276d857fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f51eef1d124d7e046b6a276d857fdb">&#9670;&nbsp;</a></span>setDryRun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::setDryRun </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toWhat</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcd8aedd768d6294cf41cd0c32b48b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd8aedd768d6294cf41cd0c32b48b7d">&#9670;&nbsp;</a></span>setHyperColumn() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::setHyperColumn </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5926b1368764799c58fbbedb10704593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5926b1368764799c58fbbedb10704593">&#9670;&nbsp;</a></span>setHyperColumn() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::setHyperColumn </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada3f2a2d4e46f0069338139732ca4113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3f2a2d4e46f0069338139732ca4113">&#9670;&nbsp;</a></span>setHyperColumn() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::setHyperColumn </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab90fa0fa3007a94813b26131c7ae3a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90fa0fa3007a94813b26131c7ae3a1d">&#9670;&nbsp;</a></span>setHyperColumn() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void helib::setHyperColumn </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; NTL::zz_p &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_p &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa12cedff32fc67534e469690637bee2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12cedff32fc67534e469690637bee2d">&#9670;&nbsp;</a></span>setHyperColumn() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::setHyperColumn </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>setHyperColumn does the reverse of getHyperColumn, setting the column to the given vector </p>

</div>
</div>
<a id="abfbaf86183c619b1eef87517dcaeacd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbaf86183c619b1eef87517dcaeacd3">&#9670;&nbsp;</a></span>setHyperColumn() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::setHyperColumn </td>
          <td>(</td>
          <td class="paramtype">const NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_cube_slice.html">CubeSlice</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this version of setHyperColumn implicitly pads v with a default value, if v is too short </p>

</div>
</div>
<a id="a07b53294ce70bc1a04b741ef3ac4512d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b53294ce70bc1a04b741ef3ac4512d">&#9670;&nbsp;</a></span>setLengthZero() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::setLengthZero </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c0a4656214afc3e52fa83408be3ff6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0a4656214afc3e52fa83408be3ff6a">&#9670;&nbsp;</a></span>setLengthZero() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::setLengthZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhelib_1_1_ptr_matrix.html">PtrMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a030064c52dceba94106ffbd8afb564ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030064c52dceba94106ffbd8afb564ef">&#9670;&nbsp;</a></span>setLengthZero() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::setLengthZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2de6d470f49ed882f0bde7b67f5c456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2de6d470f49ed882f0bde7b67f5c456">&#9670;&nbsp;</a></span>setLengthZero() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::setLengthZero </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4672b8f7cb141fc61055c0ccf5f09e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4672b8f7cb141fc61055c0ccf5f09e56">&#9670;&nbsp;</a></span>setTimersOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::setTimersOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84fe94a9675113ebaf52d87806572cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fe94a9675113ebaf52d87806572cf8">&#9670;&nbsp;</a></span>setTimersOn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::setTimersOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad44440822118a09af899ff2798464d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad44440822118a09af899ff2798464d3">&#9670;&nbsp;</a></span>setupDebugGlobals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::setupDebugGlobals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> *&#160;</td>
          <td class="paramname"><em>debug_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>debug_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZX&#160;</td>
          <td class="paramname"><em>debug_ptxt</em> = <code>NTL::ZZX{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup function for setting up the global debug variables. </p>
<dl class="section note"><dt>Note</dt><dd>Works only if <code>HELIB_DEBUG</code> is defined. It does not do anything otherwise </dd></dl>

</div>
</div>
<a id="ae2250fb1a88c915ce004837c63aa5ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2250fb1a88c915ce004837c63aa5ad7">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5442620f8d9b1e48c79e6d0c30eb9cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5442620f8d9b1e48c79e6d0c30eb9cec">&#9670;&nbsp;</a></span>splitBinaryNums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::splitBinaryNums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>leftSplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>rightSplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a single binary number into two binary numbers <code>leftSplit</code> and <code>rightSplit</code>. </p>
<p>Split a binary number into two separate binary numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftSplit</td><td>Left hand side of the split. </td></tr>
    <tr><td class="paramname">rightSplit</td><td>Right hand side of the split. </td></tr>
    <tr><td class="paramname">input</td><td>Binary number to be split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of <code>leftSplit</code> and <code>rightSplit</code> must sum to the size of <code>input</code>. </dd>
<dd>
The location of the split is defined by the sizes of <code>leftSplit</code> and <code>rightSplit</code>. </dd></dl>

</div>
</div>
<a id="a305064dc4866c160a571bd653556c113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305064dc4866c160a571bd653556c113">&#9670;&nbsp;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3828f8e07ee92999ebe6163fb96c5fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3828f8e07ee92999ebe6163fb96c5fd5">&#9670;&nbsp;</a></span>subtractBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::subtractBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts <code>rhs</code> from <code>lhs</code> where <code>lhs</code>, <code>rhs</code> are in 2's complement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">difference</td><td>Reference to the difference post subtraction. </td></tr>
    <tr><td class="paramname">lhs</td><td>Left hand side of subtraction. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side of subtraction. </td></tr>
    <tr><td class="paramname">unpackSlotEncoding</td><td>vector of constants for unpacking, as used in bootstrapping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>lhs</code> and <code>rhs</code> must have the same size. </dd></dl>

</div>
</div>
<a id="a31dcd6fc8861bd6ead98d082fba87214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dcd6fc8861bd6ead98d082fba87214">&#9670;&nbsp;</a></span>sumOfCoeffs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ helib::sumOfCoeffs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcbfc533a08e770ed13e226150f57298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbfc533a08e770ed13e226150f57298">&#9670;&nbsp;</a></span>sumOfCoeffs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ helib::sumOfCoeffs </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb375497516b4f80ee52cca6bbdf07fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb375497516b4f80ee52cca6bbdf07fa">&#9670;&nbsp;</a></span>sumOfCoeffs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::sumOfCoeffs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16a28125fbbf867ea3394513923a6abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a28125fbbf867ea3394513923a6abb">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Cloner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::swap </td>
          <td>(</td>
          <td class="paramtype">cloned_ptr&lt; X, Cloner &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cloned_ptr&lt; X, Cloner &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad420c276576021ed7278823e82771b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad420c276576021ed7278823e82771b6b">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X , typename Cloner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::swap </td>
          <td>(</td>
          <td class="paramtype">copied_ptr&lt; X, Cloner &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">copied_ptr&lt; X, Cloner &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57a5ec00207d3ca4206aaa810e04dc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a5ec00207d3ca4206aaa810e04dc5f">&#9670;&nbsp;</a></span>tableLookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::tableLookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The input is a plaintext table T[] and an array of encrypted bits I[], holding the binary representation of an index i into T. The output is the encrypted value T[i]. </p>

</div>
</div>
<a id="a5c931bc04df2c12ffb4e48ae6eb7b404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c931bc04df2c12ffb4e48ae6eb7b404">&#9670;&nbsp;</a></span>tableWriteIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::tableWriteIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; *&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The input is an encrypted table T[] and an array of encrypted bits I[], holding the binary representation of an index i into T. This function increments by one the entry T[i]. </p>

</div>
</div>
<a id="aa50b24ebf9fb1d59089cf974eee2ac90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50b24ebf9fb1d59089cf974eee2ac90">&#9670;&nbsp;</a></span>timer_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::timer_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_f_h_etimer.html">FHEtimer</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_f_h_etimer.html">FHEtimer</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac584b135744603cdff25e2db01b9463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac584b135744603cdff25e2db01b9463a">&#9670;&nbsp;</a></span>to_ZZX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX helib::to_ZZX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_double_c_r_t.html">DoubleCRT</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3259e4f89f7c305b12bd13bab812ef72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3259e4f89f7c305b12bd13bab812ef72">&#9670;&nbsp;</a></span>TofftRep_trunc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::TofftRep_trunc </td>
          <td>(</td>
          <td class="paramtype">NTL::fftRep &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab19a0354bdc3a0ef4ba47d01c8a4aaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19a0354bdc3a0ef4ba47d01c8a4aaaf">&#9670;&nbsp;</a></span>TofftRep_trunc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::TofftRep_trunc </td>
          <td>(</td>
          <td class="paramtype">NTL::fftRep &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::zz_pX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNUSED long&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d9530775923f034eadc4f3e80f355ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9530775923f034eadc4f3e80f355ff">&#9670;&nbsp;</a></span>totalProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::totalProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af72790276847439369c96063c3cdc803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72790276847439369c96063c3cdc803">&#9670;&nbsp;</a></span>totalSums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::totalSums </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc63b124cf6bc1dc82f4b599d373066c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc63b124cf6bc1dc82f4b599d373066c">&#9670;&nbsp;</a></span>traceMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::traceMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a445beffa0d612929f2237315b80d494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445beffa0d612929f2237315b80d494b">&#9670;&nbsp;</a></span>TraceMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::TraceMap </td>
          <td>(</td>
          <td class="paramtype">NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2XModulus &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::GF2X &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02352b1415d1c647d5b8468cd479647b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02352b1415d1c647d5b8468cd479647b">&#9670;&nbsp;</a></span>unpack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::unpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>unpacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a610ab903802e50b91b45788be635dfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610ab903802e50b91b45788be635dfc1">&#9670;&nbsp;</a></span>unpack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::unpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehelib.html#afac4e5ae4b272f9ffd07daee26285dad">CtPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>unpacked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacehelib.html#a4d6002f36f1a61982fded09adf1331ca">zzX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unpackSlotEncoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a611d3a80278b6196f62385f0d4d0efe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611d3a80278b6196f62385f0d4d0efe9">&#9670;&nbsp;</a></span>unpackSlots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::unpackSlots </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa135454e9085fe5e1f4b9f9dbc8eb55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa135454e9085fe5e1f4b9f9dbc8eb55c">&#9670;&nbsp;</a></span>unpackSlots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::unpackSlots </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhelib_1_1_plaintext_array.html">PlaintextArray</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &amp;&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29ccc2648ee5736fe519c1c884bf1b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ccc2648ee5736fe519c1c884bf1b68">&#9670;&nbsp;</a></span>Vec_replicate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; helib::Vec_replicate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b1de5f6a3cb9f9da27cd496659cc899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1de5f6a3cb9f9da27cd496659cc899">&#9670;&nbsp;</a></span>vecCopy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::vecCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sizeLimit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7dd2ecf9ca1ddd7c2e7372fb8999030d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd2ecf9ca1ddd7c2e7372fb8999030d">&#9670;&nbsp;</a></span>vecCopy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::vecCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sizeLimit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4d8218e2c0fee25ebec6d40d2a6036d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d8218e2c0fee25ebec6d40d2a6036d">&#9670;&nbsp;</a></span>vecCopy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::vecCopy </td>
          <td>(</td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelib_1_1_ptr_vector.html">PtrVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sizeLimit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03ca08051d06a786cf812e238a0cad15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ca08051d06a786cf812e238a0cad15">&#9670;&nbsp;</a></span>vecCopy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V1 , typename V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::vecCopy </td>
          <td>(</td>
          <td class="paramtype">V1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sizeLimit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae30e7633ce81720d2e73bb8225f82923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30e7633ce81720d2e73bb8225f82923">&#9670;&nbsp;</a></span>vecRed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::vecRed </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; NTL::ZZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; NTL::ZZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bc3d452674c06b19349e1bfc47cd6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc3d452674c06b19349e1bfc47cd6bb">&#9670;&nbsp;</a></span>vecRed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::vecRed </td>
          <td>(</td>
          <td class="paramtype">NTL::Vec&lt; NTL::ZZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Vec&lt; NTL::ZZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f11bbe3deab00c9a1dc525d23958a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f11bbe3deab00c9a1dc525d23958a6c">&#9670;&nbsp;</a></span>vector_replicate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; helib::vector_replicate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa86d423a862384884b7bed74e573e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa86d423a862384884b7bed74e573e8f">&#9670;&nbsp;</a></span>vecToStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string helib::vecToStr </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eafbe78be51b304a8b359f7f6142ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eafbe78be51b304a8b359f7f6142ef5">&#9670;&nbsp;</a></span>Warning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::Warning </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for logging a warning message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The warning message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9582d8b75aec10d74a0a89b48678be1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9582d8b75aec10d74a0a89b48678be1b">&#9670;&nbsp;</a></span>Warning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void helib::Warning </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function for logging a warning message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The warning message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39d92caff425c0086a87a667c88003d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d92caff425c0086a87a667c88003d4">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_moduli_sizes.html#a498f82c06da7dc977f99d215a35481c7">ModuliSizes::Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e05ac58f674ea9b53de6804949dea21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e05ac58f674ea9b53de6804949dea21">&#9670;&nbsp;</a></span>write_ntl_vec_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::write_ntl_vec_long </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::vec_long &amp;&#160;</td>
          <td class="paramname"><em>vl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>intSize</em> = <code>BINIO_64BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafadc64ab3b1c319e37160cd619f3bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafadc64ab3b1c319e37160cd619f3bf5">&#9670;&nbsp;</a></span>write_raw_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::write_raw_double </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab7bbf963ee93061e4bb1204438721b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7bbf963ee93061e4bb1204438721b1">&#9670;&nbsp;</a></span>write_raw_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::write_raw_int </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86af3712f18a5b1fca62330b37dbb9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86af3712f18a5b1fca62330b37dbb9de">&#9670;&nbsp;</a></span>write_raw_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::write_raw_int32 </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaeff8e262314e10ad618189976b9ef93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeff8e262314e10ad618189976b9ef93">&#9670;&nbsp;</a></span>write_raw_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void helib::write_raw_vector </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a374f958d521a444ec5686722c2dfad8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374f958d521a444ec5686722c2dfad8b">&#9670;&nbsp;</a></span>write_raw_vector&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehelib.html#aaeff8e262314e10ad618189976b9ef93">helib::write_raw_vector</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a718430742226b3f7c2b81073ea10cc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718430742226b3f7c2b81073ea10cc64">&#9670;&nbsp;</a></span>write_raw_vector&lt; long &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacehelib.html#aaeff8e262314e10ad618189976b9ef93">helib::write_raw_vector</a>&lt; long &gt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aedb770c4cb5c37da9184d5820a000758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb770c4cb5c37da9184d5820a000758">&#9670;&nbsp;</a></span>write_raw_xdouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::write_raw_xdouble </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::xdouble&#160;</td>
          <td class="paramname"><em>xd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f1521af0f4ab251d30fc4f96531dc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1521af0f4ab251d30fc4f96531dc1d">&#9670;&nbsp;</a></span>write_raw_ZZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::write_raw_ZZ </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8425881cdaaef9fade4dd57cc3cf5e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8425881cdaaef9fade4dd57cc3cf5e8b">&#9670;&nbsp;</a></span>writeContextBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::writeContextBase </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write [m p r gens ords] data </p>
<p>write [m p r] data </p>

</div>
</div>
<a id="a3167b996c8b02f9f390d1d9957693b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3167b996c8b02f9f390d1d9957693b9f">&#9670;&nbsp;</a></span>writeContextBaseBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::writeContextBaseBinary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write [m p r gens ords] data </p>

</div>
</div>
<a id="a1f9bc09cb4de5422bb79e9c4d67db80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9bc09cb4de5422bb79e9c4d67db80a">&#9670;&nbsp;</a></span>writeContextBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::writeContextBinary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_context.html">Context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d1ce128c2df30ef155f565c6435bccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1ce128c2df30ef155f565c6435bccb">&#9670;&nbsp;</a></span>writeEyeCatcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::writeEyeCatcher </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eye</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fe91feb5d65b0afc826f181557a56e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe91feb5d65b0afc826f181557a56e4">&#9670;&nbsp;</a></span>writePubKeyBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::writePubKeyBinary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_pub_key.html">PubKey</a> &amp;&#160;</td>
          <td class="paramname"><em>pk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a360f4b2c5989ceac05b2f37fe89239f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360f4b2c5989ceac05b2f37fe89239f2">&#9670;&nbsp;</a></span>writeSecKeyBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::writeSecKeyBinary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> &amp;&#160;</td>
          <td class="paramname"><em>sk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85715fb3484281444706eba875bfbe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85715fb3484281444706eba875bfbe72">&#9670;&nbsp;</a></span>zeroValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T helib::zeroValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an object <code>x</code> return a zero object of the same type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object to use for returning a zero object of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A zero object of type <code>T</code>. </dd></dl>

</div>
</div>
<a id="a25a05627840d03ffb2f39269ad6323c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a05627840d03ffb2f39269ad6323c7">&#9670;&nbsp;</a></span>zeroValue&lt; Ctxt &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> <a class="el" href="namespacehelib.html#a85715fb3484281444706eba875bfbe72">helib::zeroValue</a>&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code> return a zero object of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code> to use for returning a zero object of type <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A zero object of type <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code>. </dd></dl>

</div>
</div>
<a id="af1fa7c571ab911c358c2a01fcbcf3f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1fa7c571ab911c358c2a01fcbcf3f11">&#9670;&nbsp;</a></span>zeroValue&lt; Ptxt&lt; BGV &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_b_g_v.html">BGV</a>&gt; <a class="el" href="namespacehelib.html#a85715fb3484281444706eba875bfbe72">helib::zeroValue</a>&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_b_g_v.html">BGV</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a>&gt;</code> return a zero object of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object to use for returning a zero object of type <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a>&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A zero object of type <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_b_g_v.html" title="Type for BGV scheme, to be used as template parameter.">BGV</a>&gt;</code>. </dd></dl>

</div>
</div>
<a id="aa549403e89c301d7e2e4fa39a07dda0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa549403e89c301d7e2e4fa39a07dda0b">&#9670;&nbsp;</a></span>zeroValue&lt; Ptxt&lt; CKKS &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a>&gt; <a class="el" href="namespacehelib.html#a85715fb3484281444706eba875bfbe72">helib::zeroValue</a>&lt; <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ptxt.html">Ptxt</a>&lt; <a class="el" href="structhelib_1_1_c_k_k_s.html">CKKS</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a>&gt;</code> return a zero object of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The object to use for returning a zero object of type <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a>&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A zero object of type <code><a class="el" href="classhelib_1_1_ptxt.html" title="An object that mimics the functionality of the Ctxt object, and acts as a convenient entry point for ...">Ptxt</a>&lt;<a class="el" href="structhelib_1_1_c_k_k_s.html" title="Type for CKKS scheme, to be used as template parameter.">CKKS</a>&gt;</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3ba322251033959f95b296f34745836e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba322251033959f95b296f34745836e">&#9670;&nbsp;</a></span>activeContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_context.html">Context</a> * helib::activeContext = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a562cdbdb456ba0e706002518589d2b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562cdbdb456ba0e706002518589d2b1f">&#9670;&nbsp;</a></span>CLOCK_SCALE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned long helib::CLOCK_SCALE = (unsigned long)CLOCKS_PER_SEC</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11275c94e69653c6ca1c5b3ea8f85dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11275c94e69653c6ca1c5b3ea8f85dba">&#9670;&nbsp;</a></span>dbg_ptxt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX helib::dbg_ptxt</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f2eab09fe947de2ae6eb8328937f0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2eab09fe947de2ae6eb8328937f0bb">&#9670;&nbsp;</a></span>dbgEa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classhelib_1_1_encrypted_array.html">EncryptedArray</a> &gt; helib::dbgEa = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d7d15973181b665a33077ca529f9d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7d15973181b665a33077ca529f9d47">&#9670;&nbsp;</a></span>dbgKey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_sec_key.html">SecKey</a> * helib::dbgKey = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac088f2fa765a2ab95c318d60df164b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac088f2fa765a2ab95c318d60df164b6d">&#9670;&nbsp;</a></span>erfc_inverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double helib::erfc_inverse[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {0,</div>
<div class="line">                               0.6744897501960817432,</div>
<div class="line">                               1.1503493803760081782,</div>
<div class="line">                               1.5341205443525463117,</div>
<div class="line">                               1.8627318674216514554,</div>
<div class="line">                               2.1538746940614562129,</div>
<div class="line">                               2.4175590162365050618,</div>
<div class="line">                               2.6600674686174596585,</div>
<div class="line">                               2.8856349124267571473,</div>
<div class="line">                               3.0972690781987844623,</div>
<div class="line">                               3.2971933456919633418,</div>
<div class="line">                               3.4871041041144311068,</div>
<div class="line">                               3.6683292851213230192,</div>
<div class="line">                               3.8419306855019108708,</div>
<div class="line">                               4.0087725941685849622,</div>
<div class="line">                               4.1695693233491057549,</div>
<div class="line">                               4.3249190408260462571,</div>
<div class="line">                               4.4753284246542033544,</div>
<div class="line">                               4.6212310014992471565,</div>
<div class="line">                               4.7630010342678139569,</div>
<div class="line">                               4.9009642079631930118}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a369c8e1d9a3a6012dba0e881be855ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369c8e1d9a3a6012dba0e881be855ab6">&#9670;&nbsp;</a></span>fhe_force_chen_han</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long helib::fhe_force_chen_han = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43b6a65490d657b3d2b631fb1fe423e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b6a65490d657b3d2b631fb1fe423e8">&#9670;&nbsp;</a></span>fhe_stats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool helib::fhe_stats = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a443844fce5e8d1b68b5bbc11d7827836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443844fce5e8d1b68b5bbc11d7827836">&#9670;&nbsp;</a></span>fhe_test_force_bsgs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int helib::fhe_test_force_bsgs = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4064daef7469afa9d911c7ba658e9285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4064daef7469afa9d911c7ba658e9285">&#9670;&nbsp;</a></span>fhe_test_force_hoist</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int helib::fhe_test_force_hoist = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15af59c8cd87bc4a475ed3e1ce577cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15af59c8cd87bc4a475ed3e1ce577cc7">&#9670;&nbsp;</a></span>fhe_watcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int helib::fhe_watcher = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43d675d13f2fdad48c20753cbf9a611d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d675d13f2fdad48c20753cbf9a611d">&#9670;&nbsp;</a></span>helog</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhelib_1_1_logger.html">Logger</a> helib::helog</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() -&gt; Logger {</div>
<div class="line">  Logger defaultLog;</div>
<div class="line">  <a class="code" href="namespacehelib.html#a43d675d13f2fdad48c20753cbf9a611d">helog</a>.<a class="code" href="classhelib_1_1_logger.html#a1a71654c15c6dfa5a699c834f671a827">setLogToFile</a>(<span class="stringliteral">&quot;helib.log&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> defaultLog;</div>
<div class="line">}()</div>
</div><!-- fragment -->
<p>Internal global logger. </p>

</div>
</div>
<a id="aa4e11abf6db9206e9dc7ac9397ce28fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e11abf6db9206e9dc7ac9397ce28fb">&#9670;&nbsp;</a></span>PI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long double helib::PI</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    3.1415926535897932384626433832795028841971693993751058209749445923078164L</div>
</div><!-- fragment -->
</div>
</div>
<a id="a244137dad8f49e984df751ef5d044f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244137dad8f49e984df751ef5d044f4c">&#9670;&nbsp;</a></span>printFlag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::printFlag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47f0fb8de69aa81c6224003a79011ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f0fb8de69aa81c6224003a79011ed3">&#9670;&nbsp;</a></span>replicateVerboseFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL_THREAD_LOCAL bool helib::replicateVerboseFlag = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a63df2a7e377c38ac5d33853caff325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a63df2a7e377c38ac5d33853caff325">&#9670;&nbsp;</a></span>thinRecrypt_initial_level</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long helib::thinRecrypt_initial_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespacehelib_html_aa69f30064b062723cecac335a73fdcdd"><div class="ttname"><a href="namespacehelib.html#aa69f30064b062723cecac335a73fdcdd">helib::deserialize</a></div><div class="ttdeci">void deserialize(std::istream &amp;is, std::complex&lt; double &gt; &amp;num)</div><div class="ttdoc">Deserialize a std::complex&lt;double&gt; from the input stream is delimited by '[' and ']' (instead of the ...</div><div class="ttdef"><b>Definition:</b> Ptxt.cpp:19</div></div>
<div class="ttc" id="anamespacehelib_html_a43d675d13f2fdad48c20753cbf9a611d"><div class="ttname"><a href="namespacehelib.html#a43d675d13f2fdad48c20753cbf9a611d">helib::helog</a></div><div class="ttdeci">Logger helog</div><div class="ttdoc">Internal global logger.</div><div class="ttdef"><b>Definition:</b> log.cpp:29</div></div>
<div class="ttc" id="aclasshelib_1_1_logger_html_a1a71654c15c6dfa5a699c834f671a827"><div class="ttname"><a href="classhelib_1_1_logger.html#a1a71654c15c6dfa5a699c834f671a827">helib::Logger::setLogToFile</a></div><div class="ttdeci">void setLogToFile(const std::string &amp;filepath, bool overwrite=false)</div><div class="ttdoc">Set the logger object to write to specified file.</div><div class="ttdef"><b>Definition:</b> log.cpp:49</div></div>
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.19
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
